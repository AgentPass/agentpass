"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/utils/config.ts
var isLocalRun, DEFAULT_PAGE_SIZE;
var init_config = __esm({
  "src/utils/config.ts"() {
    "use strict";
    isLocalRun = process.env.IS_LOCAL === "true";
    DEFAULT_PAGE_SIZE = 20;
  }
});

// src/logger.ts
var import_dd_trace, import_winston, logger, logger_default;
var init_logger = __esm({
  "src/logger.ts"() {
    "use strict";
    import_dd_trace = __toESM(require("dd-trace"), 1);
    import_winston = __toESM(require("winston"), 1);
    init_config();
    import_dd_trace.default.init({
      logInjection: true
    });
    logger = import_winston.default.createLogger({
      level: process.env.LOG_LEVEL || "info",
      format: import_winston.default.format.combine(
        import_winston.default.format.timestamp(),
        import_winston.default.format.json(),
        import_winston.default.format.errors({ stack: true })
      ),
      transports: [
        new import_winston.default.transports.Console({
          format: isLocalRun ? import_winston.default.format.combine(import_winston.default.format.colorize(), import_winston.default.format.simple()) : void 0
        })
      ]
    });
    logger_default = logger;
  }
});

// src/services/secrets.service.ts
async function getAppSecrets() {
  return await appSecrets;
}
var import_client_secrets_manager, environment, secretName, client, appSecrets;
var init_secrets_service = __esm({
  "src/services/secrets.service.ts"() {
    "use strict";
    import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
    init_logger();
    environment = process.env.ENV || "dev";
    secretName = `agentbridge-${environment}-secrets`;
    client = new import_client_secrets_manager.SecretsManagerClient({
      region: process.env.AWS_SECRETS_REGION || "us-east-2"
    });
    appSecrets = (async () => {
      try {
        const input = {
          SecretId: secretName
        };
        const command = new import_client_secrets_manager.GetSecretValueCommand(input);
        const response = await client.send(command);
        if (!response.SecretString) {
          throw new Error(`Secret ${secretName} value is empty`);
        }
        const value = JSON.parse(response.SecretString);
        logger_default.debug(`Successfully loaded secrets from AWS Secrets Manager for environment: ${environment}`);
        return value;
      } catch (error) {
        logger_default.error(`Failed to retrieve secrets from AWS Secrets Manager`, error);
        process.exit(1);
      }
    })();
  }
});

// src/services/cache.service.ts
var cache_service_exports = {};
__export(cache_service_exports, {
  CacheItemType: () => CacheItemType,
  cache: () => cache,
  cacheGetOrAdd: () => cacheGetOrAdd,
  clearCache: () => clearCache,
  clearCacheByPartialKey: () => clearCacheByPartialKey,
  clearCacheByType: () => clearCacheByType
});
async function cacheGetOrAdd(key, fetchFn) {
  const keyString = keyToString(key);
  const cached = cache.get(keyString);
  if (cached) {
    return cached.value;
  }
  const value = await fetchFn();
  const ttl = TTL_CONFIG[key.type];
  cache.set(keyString, { value }, ttl);
  return value;
}
function clearCache(key) {
  const keyString = keyToString(key);
  return cache.del(keyString) > 0;
}
function clearCacheByType(type) {
  clearCacheByKeyPrefix(`${type}::`);
}
function clearCacheByPartialKey(type, id) {
  clearCacheByKeyPrefix(keyToString({ type, ids: [id] }));
}
var import_node_cache, CacheItemType, TTL_CONFIG, cache, keyToString, clearCacheByKeyPrefix;
var init_cache_service = __esm({
  "src/services/cache.service.ts"() {
    "use strict";
    import_node_cache = __toESM(require("node-cache"), 1);
    CacheItemType = /* @__PURE__ */ ((CacheItemType2) => {
      CacheItemType2["SERVER_ACCESS"] = "server_access";
      CacheItemType2["SERVER"] = "server";
      CacheItemType2["ENDUSER_TOKEN"] = "enduser_token";
      return CacheItemType2;
    })(CacheItemType || {});
    TTL_CONFIG = {
      ["server_access" /* SERVER_ACCESS */]: 300,
      // 5 minutes
      ["server" /* SERVER */]: 120,
      // 2 minutes
      ["enduser_token" /* ENDUSER_TOKEN */]: 300
      // 5 minutes
    };
    cache = new import_node_cache.default({
      checkperiod: 30
    });
    keyToString = (key) => `${key.type}::${key.ids.join(":")}`;
    clearCacheByKeyPrefix = (keyString) => {
      const keys = cache.keys();
      const matchingKeys = keys.filter((key) => key.startsWith(keyString));
      if (matchingKeys.length > 0) {
        cache.del(matchingKeys);
      }
    };
  }
});

// src/services/jwt.service.ts
var jwt_service_exports = {};
__export(jwt_service_exports, {
  generateAdminToken: () => generateAdminToken,
  generateAdminVerificationToken: () => generateAdminVerificationToken,
  generateEndUserToken: () => generateEndUserToken,
  verifyAdminToken: () => verifyAdminToken,
  verifyAdminVerificationToken: () => verifyAdminVerificationToken,
  verifyEndUserToken: () => verifyEndUserToken
});
async function generateAdminVerificationToken(id) {
  const payload = {
    id,
    action: "verify"
  };
  const options = {
    expiresIn: VERIFICATION_TOKEN_EXPIRES_IN,
    audience: id
  };
  return import_jsonwebtoken.default.sign(payload, await JWT_SECRET, options);
}
async function verifyAdminVerificationToken(token) {
  try {
    const decoded = import_jsonwebtoken.default.verify(token, await JWT_SECRET);
    if (decoded.action !== "verify") {
      return null;
    }
    return { id: decoded.id };
  } catch {
    return null;
  }
}
var import_jsonwebtoken, JWT_SECRET, JWT_EXPIRES_IN, VERIFICATION_TOKEN_EXPIRES_IN, generateAdminToken, generateEndUserToken, verifyAdminToken, verifyEndUserToken;
var init_jwt_service = __esm({
  "src/services/jwt.service.ts"() {
    "use strict";
    import_jsonwebtoken = __toESM(require("jsonwebtoken"), 1);
    init_secrets_service();
    JWT_SECRET = (async () => (await getAppSecrets()).jwtSecret)();
    JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || "2d";
    VERIFICATION_TOKEN_EXPIRES_IN = process.env.JWT_EXPIRES_IN || "14d";
    generateAdminToken = async (admin) => {
      const payload = {
        id: admin.id,
        email: admin.email,
        tenantId: admin.tenantId,
        picture: admin.picture,
        name: admin.name,
        admin: true,
        role: admin.role
      };
      const options = {
        expiresIn: JWT_EXPIRES_IN,
        subject: admin.email
      };
      return import_jsonwebtoken.default.sign(payload, await JWT_SECRET, options);
    };
    generateEndUserToken = async (user, jti) => {
      const payload = {
        id: user.id,
        email: user.email,
        tenantId: user.tenantId,
        endUser: true,
        jti
      };
      const options = {
        subject: user.email
      };
      return import_jsonwebtoken.default.sign(payload, await JWT_SECRET, options);
    };
    verifyAdminToken = async (token) => {
      try {
        const decoded = import_jsonwebtoken.default.verify(token, await JWT_SECRET);
        if (!decoded.admin) {
          return null;
        }
        return decoded;
      } catch {
        return null;
      }
    };
    verifyEndUserToken = async (token) => {
      try {
        const decoded = import_jsonwebtoken.default.verify(token, await JWT_SECRET, { ignoreExpiration: true });
        if (!decoded.endUser) {
          return null;
        }
        return decoded;
      } catch {
        return null;
      }
    };
  }
});

// src/utils/generateRequestOverrides.ts
var generateRequestOverrides_exports = {};
__export(generateRequestOverrides_exports, {
  generateRequestOverrides: () => generateRequestOverrides,
  generateRequestOverridesFromOperation: () => generateRequestOverridesFromOperation
});
function generateRequestOverridesFromOperation(operation, pathItem) {
  const overrides = {};
  const queryParams = {};
  const headerParams = {};
  const pathParams = {};
  const allParameters = [...pathItem.parameters || [], ...operation.parameters || []];
  allParameters.forEach((param) => {
    if (typeof param === "object" && "name" in param) {
      const parameter = param;
      const template = `{{toolParams.${parameter.name}}}`;
      switch (parameter.in) {
        case "query":
          queryParams[parameter.name] = template;
          break;
        case "header":
          headerParams[parameter.name] = template;
          break;
        case "path":
          pathParams[parameter.name] = template;
          break;
      }
    }
  });
  if (operation.requestBody && typeof operation.requestBody === "object" && "content" in operation.requestBody) {
    const requestBody = operation.requestBody;
    const jsonContent = requestBody.content?.["application/json"];
    if (jsonContent?.schema) {
      const schema = jsonContent.schema;
      if (schema.properties) {
        const bodyStructure = {};
        Object.keys(schema.properties).forEach((propName) => {
          bodyStructure[propName] = `{{toolParams.body.${propName}}}`;
        });
        overrides.body = bodyStructure;
        overrides.bodyFormat = "json";
      } else {
        overrides.body = "{{toolParams.body}}";
        overrides.bodyFormat = "json";
      }
    }
  }
  if (Object.keys(queryParams).length > 0) {
    overrides.query = queryParams;
  }
  if (Object.keys(headerParams).length > 0) {
    overrides.headers = headerParams;
  }
  if (Object.keys(pathParams).length > 0) {
    overrides.path = pathParams;
  }
  return overrides;
}
function generateRequestOverrides(parameters) {
  const overrides = {};
  const queryParams = {};
  const headerParams = {};
  const pathParams = {};
  let hasBodyParam = false;
  const bodyStructure = {};
  for (const [name, param] of Object.entries(parameters)) {
    const template = `{{toolParams.${name}}}`;
    switch (param.in) {
      case "query":
      case void 0:
        queryParams[name] = template;
        break;
      case "header":
        headerParams[name] = template;
        break;
      case "path":
        pathParams[name] = template;
        break;
      case "body":
        hasBodyParam = true;
        if (param.schema?.properties) {
          Object.keys(param.schema.properties).forEach((propName) => {
            bodyStructure[propName] = `{{toolParams.${name}.${propName}}}`;
          });
        } else {
          bodyStructure[name] = `{{toolParams.${name}}}`;
        }
        break;
    }
  }
  if (Object.keys(queryParams).length > 0) {
    overrides.query = queryParams;
  }
  if (Object.keys(headerParams).length > 0) {
    overrides.headers = headerParams;
  }
  if (Object.keys(pathParams).length > 0) {
    overrides.path = pathParams;
  }
  if (hasBodyParam) {
    overrides.body = bodyStructure;
    overrides.bodyFormat = "json";
  }
  return overrides;
}
var init_generateRequestOverrides = __esm({
  "src/utils/generateRequestOverrides.ts"() {
    "use strict";
  }
});

// src/utils/icons.ts
var getIcon;
var init_icons = __esm({
  "src/utils/icons.ts"() {
    "use strict";
    getIcon = (name) => {
      switch (name) {
        case "google":
          return `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" xmlns:xlink="http://www.w3.org/1999/xlink" style="display: block;"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></svg>`;
        case "oauthGeneric":
          return `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="800px" height="800px" viewBox="0 0 256 256" version="1.1" preserveAspectRatio="xMidYMid">
	<g>
		<path d="M118.922624,0.37140771 C175.483691,-3.5505123 212.986837,24.1282078 234.430251,57.8515157 C245.182251,74.7603157 255.731584,100.441382 255.780224,126.827729 C255.832277,155.497169 246.544597,180.324476 234.430251,198.541009 C221.979264,217.264422 205.875157,232.728956 185.709184,242.883196 C151.999957,259.857276 104.889984,260.321489 74.033024,243.978022 C39.6684361,225.777276 13.2466761,199.798822 3.41456926,154.746662 C-0.520150741,136.717436 -0.972417408,113.421862 4.50939593,93.4346624 C5.79579605,88.7460224 8.13350272,83.8116224 9.98395605,79.2014891 C18.8765427,57.0472491 34.0125427,37.7823945 52.6834773,24.4580211 C60.185984,19.1042078 69.2876373,13.7794078 77.3179307,10.2248478 C87.3096107,5.80244779 104.132224,1.3966877 118.922624,0.37140771 L118.922624,0.37140771 Z" fill="#FFFFFF">
</path>
		<path d="M226.211797,130.015782 C226.211797,183.471996 182.876971,226.803836 129.421611,226.803836 C75.9662507,226.803836 32.6322761,183.471996 32.6322761,130.015782 C32.6322761,76.5608491 75.9662507,33.2255945 129.421611,33.2255945 C182.876544,33.2255945 226.211797,76.5608491 226.211797,130.015782 L226.211797,130.015782 Z" fill="#000000">
</path>
		<path d="M118.922624,0.37140771 C175.483691,-3.5505123 212.986837,24.1282078 234.430251,57.8515157 C245.182251,74.7603157 255.731584,100.441382 255.780224,126.827729 C255.832277,155.497169 246.544597,180.324476 234.430251,198.541009 C221.979264,217.264422 205.875157,232.728956 185.709184,242.883196 C151.999957,259.857276 104.889984,260.321489 74.033024,243.978022 C39.6684361,225.777276 13.2466761,199.798822 3.41456926,154.746662 C-0.520150741,136.717436 -0.972417408,113.421862 4.50939593,93.4346624 C5.79579605,88.7460224 8.13350272,83.8116224 9.98395605,79.2014891 C18.8765427,57.0472491 34.0125427,37.7823945 52.6834773,24.4580211 C60.185984,19.1042078 69.2876373,13.7794078 77.3179307,10.2248478 C87.3096107,5.80244779 104.132224,1.3966877 118.922624,0.37140771 L118.922624,0.37140771 Z M99.762304,9.67786112 C78.753664,15.1246878 63.3497173,24.8829811 49.9464107,35.4071411 C30.6188361,50.5828224 18.2975561,71.7604224 11.0787827,97.2665557 C3.04763593,125.643302 8.20646272,159.982289 19.2904094,181.570769 C30.7843827,203.958822 46.217344,221.337382 68.0114773,233.576742 C89.2146773,245.484156 119.036971,253.130022 150.126464,247.262502 C177.748864,242.049489 198.727637,230.016209 215.818197,212.226769 C238.684117,188.425169 257.061931,144.585596 244.832384,98.3613824 C241.563264,86.0072491 237.289344,73.1313024 230.598784,62.2308224 C226.984064,56.3419691 221.679744,50.5486891 216.365611,44.7131691 C196.309717,22.6882078 163.894571,3.70879437 122.207104,6.39295445 C114.273664,6.90367445 107.301504,7.72287445 99.762304,9.67786112 L99.762304,9.67786112 Z" fill="#000000">
</path>
		<g transform="translate(7.680000, 9.386667)" fill="#FFFFFF">
			<g transform="translate(0.000000, 2.986667)">
				<path d="M127.896362,234.025436 L239.741909,122.182449 L239.138518,121.579044 L127.292971,233.422031 L127.896362,234.025436 L127.896362,234.025436 Z">
</path>
				<path d="M118.118869,225.167835 L230.452096,112.836742 L229.848704,112.233338 L117.515477,224.564432 L118.118869,225.167835 L118.118869,225.167835 Z">
</path>
				<path d="M108.34095,216.311515 L221.16271,103.491461 L220.559317,102.888059 L107.737557,215.708112 L108.34095,216.311515 L108.34095,216.311515 Z">
</path>
				<path d="M98.5630294,207.453915 L211.872896,94.1461817 L211.269504,93.5427783 L97.9596373,206.850512 L98.5630294,207.453915 L98.5630294,207.453915 Z">
</path>
				<path d="M88.7855366,198.596741 L202.58351,84.8004745 L201.980117,84.1970722 L88.1821434,197.993339 L88.7855366,198.596741 L88.7855366,198.596741 Z">
</path>
				<path d="M79.00762,189.741698 L193.293273,75.4551911 L192.689873,74.8517956 L78.40422,189.138302 L79.00762,189.741698 L79.00762,189.741698 Z">
</path>
				<path d="M69.2296967,180.882394 L184.003883,66.1099145 L183.40049,65.5065122 L68.6263033,180.278992 L69.2296967,180.882394 L69.2296967,180.882394 Z">
</path>
				<path d="M59.4517778,172.02522 L174.713644,56.7642067 L174.110249,56.1608067 L58.8483822,171.42182 L59.4517778,172.02522 L59.4517778,172.02522 Z">
</path>
				<path d="M49.6738606,163.168044 L165.421701,47.4189239 L164.818299,46.8155294 L49.0704594,162.564649 L49.6738606,163.168044 L49.6738606,163.168044 Z">
</path>
				<path d="M39.8963639,154.310447 L156.134444,38.0736472 L155.531049,37.4702461 L39.2929694,153.707046 L39.8963639,154.310447 L39.8963639,154.310447 Z">
</path>
				<path d="M30.1184445,145.4537 L146.844631,28.7283667 L146.241236,28.1249667 L29.5150489,144.8503 L30.1184445,145.4537 L30.1184445,145.4537 Z">
</path>
				<path d="M20.3405245,136.596527 L137.555244,19.38266 L136.951849,18.77926 L19.7371289,135.993127 L20.3405245,136.596527 L20.3405245,136.596527 Z">
</path>
				<path d="M10.5626039,127.738927 L128.265431,10.0373805 L127.662036,9.43397947 L9.95920941,127.135526 L10.5626039,127.738927 L10.5626039,127.738927 Z">
</path>
				<path d="M0.784683926,118.881754 L118.975617,0.692100527 L118.372223,0.088699473 L0.181289407,118.278353 L0.784683926,118.881754 L0.784683926,118.881754 Z">
</path>
			</g>
			<g>
				<path d="M0.14330767,122.999079 L114.223734,237.084625 L114.827146,236.481241 L0.746718997,122.395695 L0.14330767,122.999079 L0.14330767,122.999079 Z">
</path>
				<path d="M9.39472045,113.615398 L123.697014,227.923238 L124.300426,227.319855 L9.99813288,113.012015 L9.39472045,113.615398 L9.39472045,113.615398 Z">
</path>
				<path d="M18.6461344,104.231719 L133.170294,218.760999 L133.773706,218.157615 L19.2495456,103.628335 L18.6461344,104.231719 L18.6461344,104.231719 Z">
</path>
				<path d="M27.8975477,94.8480388 L142.644001,209.599612 L143.247412,208.996228 L28.500959,94.2446545 L27.8975477,94.8480388 L27.8975477,94.8480388 Z">
</path>
				<path d="M37.1485349,85.4643594 L152.116855,200.437373 L152.720265,199.833987 L37.7519451,84.8609739 L37.1485349,85.4643594 L37.1485349,85.4643594 Z">
</path>
				<path d="M46.3999494,76.0806805 L161.590989,191.275561 L162.194397,190.672173 L47.0033573,75.4772928 L46.3999494,76.0806805 L46.3999494,76.0806805 Z">
</path>
				<path d="M55.6513628,66.6970005 L171.064269,182.113747 L171.667677,181.510359 L56.2547706,66.0936128 L55.6513628,66.6970005 L55.6513628,66.6970005 Z">
</path>
				<path d="M64.9023505,57.3133217 L180.537551,172.951508 L181.140956,172.348118 L65.5057561,56.7099317 L64.9023505,57.3133217 L64.9023505,57.3133217 Z">
</path>
				<path d="M74.1537644,47.9296422 L190.011258,163.789696 L190.614662,163.186304 L74.7571689,47.3262511 L74.1537644,47.9296422 L74.1537644,47.9296422 Z">
</path>
				<path d="M83.4051783,38.5459628 L199.484112,154.627029 L200.087515,154.023637 L84.0085817,37.9425705 L83.4051783,38.5459628 L83.4051783,38.5459628 Z">
</path>
				<path d="M92.6565911,29.1622822 L208.957818,145.466069 L209.561222,144.862678 L93.2599955,28.5588911 L92.6565911,29.1622822 L92.6565911,29.1622822 Z">
</path>
				<path d="M101.907579,19.7786034 L218.431099,136.30383 L219.034501,135.700437 L102.510981,19.17521 L101.907579,19.7786034 L101.907579,19.7786034 Z">
</path>
				<path d="M111.158992,10.39535 L227.904379,127.142443 L228.507781,126.53905 L111.762394,9.79195665 L111.158992,10.39535 L111.158992,10.39535 Z">
</path>
				<path d="M120.410833,1.01167058 L237.378086,117.980204 L237.981487,117.376809 L121.014234,0.408276091 L120.410833,1.01167058 L120.410833,1.01167058 Z">
</path>
			</g>
		</g>
		<path d="M209.796224,45.2605824 C199.729877,35.1942345 187.353984,26.1233011 172.570837,20.6261278 C157.247531,14.9279945 139.913771,10.1250078 119.470037,11.8670878 C86.9042773,14.6429811 64.0392107,29.2541811 46.661504,46.3554091 C34.4895561,58.3332224 25.3337161,73.0109824 19.2899827,90.1497557 C10.4161694,115.314982 10.9546227,145.018236 20.9322227,170.622076 C29.4429427,192.461862 43.3727573,210.077222 63.0843307,223.722876 C81.6148907,236.551462 108.210731,246.500902 138.082091,243.978022 C174.464811,240.905169 201.085397,222.239356 218.554411,200.731089 C223.024171,195.228796 227.468331,189.009276 230.050091,181.571196 C232.579797,176.211836 233.817984,172.568529 234.977237,170.622502 C239.829291,159.750182 242.399957,148.278822 243.188437,135.587196 C245.614037,96.5506091 230.594517,66.0593024 209.796224,45.2605824 L209.796224,45.2605824 Z M199.073664,164.193062 C199.004117,164.341542 198.941824,164.479782 198.869291,164.632956 C197.064491,169.797756 193.955371,174.116476 190.830464,177.937702 C178.613291,192.872742 159.998251,205.834022 134.555264,207.968209 C113.665237,209.719249 95.0664107,202.811089 82.1081173,193.903142 C70.8475307,186.162129 62.287744,176.580049 56.2853973,165.064316 C55.9193173,164.371409 52.4334507,156.340262 52.4232107,155.986982 C47.6680107,141.237542 47.255424,117.520849 52.136064,103.288529 C55.3932373,93.7896491 60.8217173,83.5121024 68.0114773,75.3695957 C77.938304,64.1265024 87.872384,56.9222357 103.594624,51.8299691 C110.773291,49.5046357 117.199744,47.1379157 126.038997,46.9032491 C147.594197,46.3293824 169.544064,56.0074624 181.329451,66.6105557 C192.159957,76.3543424 204.503424,95.3346091 207.606571,113.141969 C210.800171,131.470289 207.391957,149.365116 199.073664,164.193062 L199.073664,164.193062 Z" fill="#000000">
</path>
		<g transform="translate(83.626667, 76.373333)">
			<path d="M77.9810133,105.400747 C72.67328,105.400747 68.01536,102.039467 66.38976,97.0363733 L60.4778667,79.02336 L30.9034667,79.02336 L25.41056,96.8721067 C23.7525333,101.97248 19.0592,105.386667 13.72416,105.386667 C12.4433067,105.386667 11.1709867,105.184 9.94261333,104.785493 C3.56565333,102.87104 -0.0546133333,96.0072533 1.89909333,89.49376 L26.8616533,10.4226133 C28.48256,5.39264 33.2544,1.88416 38.4669867,1.88416 L51.7405867,1.88416 C56.9826133,1.88416 61.7540267,5.33290667 63.34336,10.2711467 L89.5957333,89.3128533 C91.6949333,95.7751467 88.21888,102.71232 81.8513067,104.785067 C80.5922133,105.193813 79.2904533,105.400747 77.9810133,105.400747 L77.9810133,105.400747 L77.9810133,105.400747 Z" fill="#FFFFFF">
</path>
			<path d="M77.9810133,103.69408 C73.2261841,103.69408 69.0608465,100.688308 67.6071126,96.2141657 L61.6940408,78.1975435 L61.4049446,77.3166933 L60.4778667,77.3166933 L30.9034667,77.3166933 L29.958141,77.3166933 L29.6800885,78.2202018 L24.1871818,96.0689485 C22.7072691,100.620899 18.5067226,103.68 13.72416,103.68 C12.5787502,103.68 11.4396612,103.498823 10.3376028,103.141295 C4.61174908,101.421988 1.37421306,95.2722447 3.12512866,89.4348397 L28.0822714,10.3812927 C29.5308212,5.88624847 33.8113885,2.73749333 38.4669867,2.73749333 L51.7405867,2.73749333 C56.4288544,2.73749333 60.7065138,5.82950865 62.1249103,10.2366284 L88.3809821,89.2896459 C90.2599306,95.0739946 87.1485772,101.287946 81.4551086,103.141261 C80.3246516,103.508247 79.1562581,103.69408 77.9810133,103.69408 L77.9810133,103.69408 Z M77.9810133,106.25408 C79.4253475,106.25408 80.8604464,106.025828 82.2465357,105.575854 C89.2922648,103.282357 93.1289211,95.6198406 90.8131148,88.4907346 L64.5581113,9.4410208 C62.8016101,3.98319054 57.536605,0.177493333 51.7405867,0.177493333 L38.4669867,0.177493333 C32.6951659,0.177493333 27.4336011,4.04786331 25.6433485,9.60334848 L0.678475274,88.6817473 C-1.48096359,95.8806734 2.51145487,103.464326 9.57456724,105.584772 C10.9041173,106.016429 12.3097398,106.24 13.72416,106.24 C19.6168848,106.24 24.7994128,102.465759 26.6278552,96.8411577 L32.1268448,78.9731849 L30.9034667,79.8766933 L60.4778667,79.8766933 L59.2616926,78.9958432 L65.1735859,97.0088565 C66.9698962,102.537361 72.1204498,106.25408 77.9810133,106.25408 L77.9810133,106.25408 Z" fill="#000000">
</path>
		</g>
		<g transform="translate(61.440000, 19.200000)" fill="#FFFFFF">
			<path d="M2.13376,33.8577067 L2.10261333,33.8154667 C-1.01034667,29.5492267 -0.0968533333,23.5810133 4.48768,20.2350933 C9.07221333,16.8896 14.9614933,17.8286933 18.0744533,22.0945067 L18.1056,22.1367467 C21.21856,26.4029867 20.3050667,32.3716267 15.7205333,35.71712 C11.136,39.0626133 5.24672,38.1239467 2.13376,33.8577067 L2.13376,33.8577067 Z M13.93408,25.2462933 L13.9029333,25.2040533 C12.3387733,23.06048 9.42634667,22.3232 7.15562667,23.9803733 C4.90581333,25.6221867 4.73088,28.5469867 6.29504,30.6909867 L6.32618667,30.7332267 C7.89077333,32.8768 10.8027733,33.61408 13.0525867,31.9722667 C15.3237333,30.3150933 15.4986667,27.3902933 13.93408,25.2462933 L13.93408,25.2462933 Z">
</path>
			<path d="M32.1467733,5.89525333 L36.8251733,4.39424 L49.94048,19.6407467 L44.7364267,21.3102933 L42.4571733,18.5924267 L35.70176,20.7598933 L35.4542933,24.2888533 L30.3505067,25.9264 L32.1467733,5.89525333 L32.1467733,5.89525333 Z M39.84384,15.264 L36.2948267,10.9111467 L35.91552,16.5243733 L39.84384,15.264 L39.84384,15.264 Z">
</path>
			<path d="M58.3658667,10.48192 L58.4068267,0.155306667 L63.5831467,0.175786667 L63.5426133,10.39744 C63.5319467,13.0513067 64.8669867,14.3176533 66.9166933,14.3261867 C68.9664,14.3342933 70.3112533,13.1310933 70.3210667,10.55616 L70.3624533,0.20352 L75.5387733,0.224 L75.49824,10.4192 C75.4747733,16.3575467 72.0750933,18.9457067 66.8458667,18.9248 C61.6170667,18.9034667 58.3432533,16.2363733 58.3658667,10.48192 L58.3658667,10.48192 Z">
</path>
			<path d="M94.2331733,8.67754667 L88.95616,7.06688 L90.2600533,2.79466667 L105.6896,7.50378667 L104.385707,11.776 L99.1086933,10.16576 L95.04384,23.4845867 L90.1687467,21.9968 L94.2331733,8.67754667 L94.2331733,8.67754667 Z">
</path>
			<path d="M119.471787,13.4651733 L123.715413,16.28928 L119.901867,22.0202667 L125.348693,25.6452267 L129.162667,19.9138133 L133.406293,22.73792 L123.216213,38.05056 L118.97216,35.2264533 L122.844587,29.4075733 L117.397333,25.7826133 L113.525333,31.6014933 L109.281707,28.7773867 L119.471787,13.4651733 L119.471787,13.4651733 Z">
</path>
		</g>
		<g transform="translate(65.280000, 196.266667)" fill="#FFFFFF">
			<path d="M130.622293,3.79008 L130.65472,3.83146667 C133.92896,7.97568 133.243733,13.9754667 128.790187,17.49376 C124.33664,21.0120533 118.41536,20.2986667 115.14112,16.1544533 L115.108693,16.1130667 C111.834453,11.9684267 112.520107,5.96906667 116.973227,2.45077333 C121.426773,-1.06709333 127.348053,-0.354133333 130.622293,3.79008 L130.622293,3.79008 Z M119.158187,12.8469333 L119.190613,12.88832 C120.83584,14.97088 123.774293,15.5963733 125.980587,13.85344 C128.165973,12.12672 128.229547,9.19722667 126.583893,7.11466667 L126.551467,7.07328 C124.906667,4.99072 121.967787,4.36522667 119.7824,6.09194667 C117.576107,7.83488 117.51296,10.7643733 119.158187,12.8469333 L119.158187,12.8469333 Z">
</path>
			<path d="M101.84832,32.9309867 L97.24032,34.6363733 L83.4666667,19.98208 L88.5922133,18.0846933 L90.9892267,20.70016 L97.6426667,18.23744 L97.7344,14.7012267 L102.761387,12.8405333 L101.84832,32.9309867 L101.84832,32.9309867 Z M93.7463467,23.9104 L97.48352,28.1024 L97.61536,22.47808 L93.7463467,23.9104 L93.7463467,23.9104 Z">
</path>
			<path d="M75.4722133,29.4336 L75.9274667,39.7499733 L70.7562667,39.97824 L70.30528,29.7668267 C70.1883733,27.11552 68.7940267,25.91488 66.7464533,26.0053333 C64.69888,26.0957867 63.4133333,27.36256 63.5268267,29.9349333 L63.98336,40.2773333 L58.81216,40.5056 L58.3624533,30.32064 C58.10048,24.3882667 61.37216,21.63968 66.59584,21.40928 C71.8199467,21.1784533 75.2183467,23.6846933 75.4722133,29.4336 L75.4722133,29.4336 Z">
</path>
			<path d="M39.5396267,32.8068267 L44.8674133,34.24512 L43.70304,38.5578667 L28.1250133,34.3530667 L29.2893867,30.0398933 L34.6171733,31.4781867 L38.2468267,18.03136 L43.1688533,19.36 L39.5396267,32.8068267 L39.5396267,32.8068267 Z">
</path>
			<path d="M14.3573333,29.0594133 L9.98442667,26.4388267 L13.5236267,20.5333333 L7.91168,17.1694933 L4.37248,23.0749867 L0,20.4544 L9.45664,4.67669333 L13.82912,7.29770667 L10.2357333,13.2932267 L15.8481067,16.6570667 L19.4414933,10.6615467 L23.8139733,13.28256 L14.3573333,29.0594133 L14.3573333,29.0594133 Z">
</path>
		</g>
	</g>
</svg>`;
        default:
          return "";
      }
    };
  }
});

// src/utils/openapi.ts
var import_openapi_parser, validateOpenApiContent, getServerUrlFromOpenApi;
var init_openapi = __esm({
  "src/utils/openapi.ts"() {
    "use strict";
    import_openapi_parser = require("@readme/openapi-parser");
    validateOpenApiContent = async (content) => {
      if (!content || typeof content !== "object") {
        return {
          error: "invalid_openapi",
          errorDescription: "OpenAPI content is empty"
        };
      }
      if (!("info" in content) || !content.info || typeof content.info !== "object" || !("title" in content.info)) {
        return {
          error: "invalid_openapi",
          errorDescription: "OpenAPI info section is required and must include a title"
        };
      }
      if ("servers" in content) {
        if (!Array.isArray(content.servers)) {
          return {
            error: "invalid_openapi",
            errorDescription: "Servers must be an array in the OpenAPI specification"
          };
        }
        const hasValidServer = content.servers.some(
          (server) => server && typeof server === "object" && "url" in server && typeof server.url === "string"
        );
        if (!hasValidServer) {
          return {
            error: "invalid_openapi",
            errorDescription: "At least one server must have a valid URL in the OpenAPI specification"
          };
        }
      }
      try {
        const result = await (0, import_openapi_parser.validate)(content);
        if (result.valid === true) {
          return null;
        }
        return {
          error: "invalid_openapi",
          errorDescription: (0, import_openapi_parser.compileErrors)(result)
        };
      } catch (error) {
        return {
          error: "invalid_openapi",
          errorDescription: error instanceof Error ? error.message : "Invalid OpenAPI specification"
        };
      }
    };
    getServerUrlFromOpenApi = (openApiContent) => {
      if (!openApiContent.servers?.length) {
        return "";
      }
      const firstServer = openApiContent.servers[0];
      if (!firstServer?.url || typeof firstServer.url !== "string") {
        return "";
      }
      return firstServer.url;
    };
  }
});

// src/utils/tools.ts
var import_snakeCase, TOOL_NAME_MAX_LENGTH, getToolName;
var init_tools = __esm({
  "src/utils/tools.ts"() {
    "use strict";
    import_snakeCase = __toESM(require("lodash/snakeCase.js"), 1);
    TOOL_NAME_MAX_LENGTH = process.env.TOOL_NAME_MAX_LENGTH ? parseInt(process.env.TOOL_NAME_MAX_LENGTH) : 60;
    getToolName = (operation, method, path) => {
      if (operation.operationId) {
        return (0, import_snakeCase.default)(operation.operationId);
      }
      if (operation.summary) {
        return (0, import_snakeCase.default)(operation.summary);
      }
      return (0, import_snakeCase.default)(`${method}_${path}`).slice(0, TOOL_NAME_MAX_LENGTH);
    };
  }
});

// src/services/servers.service.ts
var servers_service_exports = {};
__export(servers_service_exports, {
  createExampleTodosServer: () => createExampleTodosServer,
  createServer: () => createServer,
  createServerFromOpenApiSpec: () => createServerFromOpenApiSpec,
  createTool: () => createTool,
  createToolsFromOpenApiSpec: () => createToolsFromOpenApiSpec,
  deleteServerById: () => deleteServerById,
  deleteToolById: () => deleteToolById,
  getServerById: () => getServerById,
  getServerSlim: () => getServerSlim,
  getServersForTenant: () => getServersForTenant,
  getToolById: () => getToolById,
  getToolsForServer: () => getToolsForServer,
  updateServerById: () => updateServerById,
  updateToolById: () => updateToolById
});
async function createAuthProviderFromOpenApi(tx, serverName, openApiContent, tenantId) {
  const providers = [];
  for (const [name, oauthScheme] of Object.entries(openApiContent?.components?.securitySchemes || {})) {
    if ("type" in oauthScheme && oauthScheme.type === "oauth2") {
      if (!oauthScheme.flows?.authorizationCode?.authorizationUrl || !oauthScheme.flows?.authorizationCode?.tokenUrl) {
        throw new Error("Missing required OAuth URLs in security scheme");
      }
      providers.push({
        specName: name,
        provider: await tx.oAuthProvider.create({
          data: {
            name: serverName + " OAuth",
            clientId: "",
            clientSecret: "",
            authorizationUrl: oauthScheme.flows.authorizationCode.authorizationUrl,
            tokenUrl: oauthScheme.flows.authorizationCode.tokenUrl,
            scopes: oauthScheme.flows.authorizationCode.scopes ? Object.keys(oauthScheme.flows.authorizationCode.scopes) : [],
            tenantId,
            svg: getIcon("oauthGeneric"),
            refreshUrl: oauthScheme.flows.authorizationCode.refreshUrl
          }
        })
      });
    }
  }
  for (const [name, apiKeyScheme] of Object.entries(openApiContent?.components?.securitySchemes || {})) {
    if ("type" in apiKeyScheme && apiKeyScheme.type === "apiKey") {
      providers.push({
        specName: name,
        provider: await tx.apiKeyProvider.create({
          data: {
            value: serverName + " API Key",
            keyName: apiKeyScheme.name,
            keyIn: apiKeyScheme.in,
            tenantId
          }
        })
      });
    }
  }
  return providers;
}
async function createServer(db, tenantId, server) {
  return await db.mcpServer.create({
    data: { ...server, tenantId }
  });
}
async function getServersForTenant(db, tenantId) {
  const servers = await db.mcpServer.findMany({
    where: {
      tenantId
    },
    include: {
      _count: {
        select: {
          tools: true
        }
      }
    },
    orderBy: [
      {
        name: "asc"
      },
      {
        id: "asc"
      }
    ]
  });
  return {
    data: servers.map(mapServer),
    pagination: {
      currentPage: 1,
      itemsPerPage: DEFAULT_PAGE_SIZE,
      totalItems: servers.length,
      totalPages: Math.ceil(servers.length / DEFAULT_PAGE_SIZE)
    }
  };
}
async function getServerById(db, tenantId, serverId) {
  const server = await db.mcpServer.findUnique({
    where: {
      id: serverId,
      tenantId
    },
    include: {
      authConfig: {
        include: {
          jwtProvider: true
        }
      }
    }
  });
  return server ? mapServerWithAuth(server) : null;
}
async function updateServerById(db, tenantId, serverId, updateData) {
  return mapServer(
    await db.mcpServer.update({
      where: {
        id: serverId,
        tenantId
      },
      data: updateData
    })
  );
}
async function deleteServerById(db, tenantId, serverId) {
  return mapServer(
    await db.mcpServer.delete({
      where: {
        id: serverId,
        tenantId
      }
    })
  );
}
async function getServerSlim(db, tenantId, serverId) {
  return await db.mcpServer.findUnique({
    where: {
      id: serverId,
      tenantId
    },
    select: {
      id: true,
      tenantId: true
    }
  });
}
async function createToolsFromOpenApiSpec(db, tenantId, serverId, openApiContent, selectedTools) {
  return await db.$transaction(async (tx) => {
    const foldersByName = {};
    const createdTools = [];
    const existingFolders = await tx.folder.findMany({
      where: { serverId, tenantId }
    });
    existingFolders.forEach((folder) => {
      foldersByName[folder.name] = folder;
    });
    const providers = await createAuthProviderFromOpenApi(tx, `Server ${serverId}`, openApiContent, tenantId);
    const oauthProvidersByName = (0, import_groupBy.default)(
      providers.filter((p) => "authorizationUrl" in p.provider),
      "specName"
    );
    const apiKeyProvidersByName = (0, import_groupBy.default)(
      providers.filter((p) => "keyIn" in p.provider),
      "specName"
    );
    if (openApiContent.paths) {
      for (const [path, pathItem] of Object.entries(openApiContent.paths)) {
        if (typeof pathItem === "object" && pathItem !== null) {
          for (const [method, operation] of Object.entries(pathItem)) {
            if (typeof operation === "object" && operation !== null && ("operationId" in operation || "responses" in operation)) {
              const parameters = operation.parameters?.reduce(
                (acc, param) => {
                  if (typeof param === "object" && param !== null && "name" in param) {
                    acc[param.name] = param;
                  }
                  return acc;
                },
                {}
              ) || {};
              if (operation.requestBody) {
                const requestBody = operation.requestBody;
                if (typeof requestBody === "object" && "content" in requestBody) {
                  const jsonContent = requestBody.content?.["application/json"];
                  if (jsonContent?.schema) {
                    parameters["body"] = {
                      in: "body",
                      name: "body",
                      schema: jsonContent.schema,
                      required: requestBody.required ?? true
                    };
                  }
                }
              }
              let folderId = null;
              const tags = operation.tags || [];
              if (tags.length > 0) {
                const tag = tags[0];
                if (!foldersByName[tag]) {
                  foldersByName[tag] = await tx.folder.create({
                    data: {
                      name: tag,
                      tenantId,
                      serverId
                    }
                  });
                }
                folderId = foldersByName[tag].id;
              }
              let apiKeyProviderId = null;
              let oAuthProviderId = null;
              const securitySpecNames = operation.security?.flatMap((sec) => Object.keys(sec)) || [];
              for (const security of securitySpecNames) {
                if (apiKeyProvidersByName[security]) {
                  apiKeyProviderId = apiKeyProvidersByName[security][0].provider.id;
                }
                if (oauthProvidersByName[security]) {
                  oAuthProviderId = oauthProvidersByName[security][0].provider.id;
                }
              }
              const toolName = getToolName(operation, method, path);
              const isSelected = selectedTools ? selectedTools.some((selectedTool) => selectedTool.toLowerCase() === toolName.toLowerCase()) : true;
              if (isSelected) {
                const createdTool = await tx.tool.create({
                  data: {
                    name: toolName,
                    description: operation.summary || operation.description || "",
                    enabled: true,
                    parameters,
                    responses: operation.responses || {},
                    method: method.toUpperCase(),
                    url: path,
                    responseFormatting: {},
                    requestParameterOverrides: generateRequestOverridesFromOperation(operation, pathItem),
                    tenantId,
                    serverId,
                    folderId,
                    apiKeyProviderId,
                    oAuthProviderId
                  }
                });
                createdTools.push(mapTool(createdTool));
              }
            }
          }
        }
      }
    }
    return {
      tools: createdTools,
      authProviders: providers.map((p) => p.provider)
    };
  });
}
async function createServerFromOpenApiSpec(db, tenantId, name, description, openApiContent, selectedTools) {
  return await db.$transaction(async (tx) => {
    const foldersByName = {};
    const server = await tx.mcpServer.create({
      data: {
        name: name || openApiContent.info.title,
        description: description || openApiContent.info.description || "",
        enabled: true,
        tenantId,
        baseUrl: getServerUrlFromOpenApi(openApiContent)
      }
    });
    const providers = await createAuthProviderFromOpenApi(tx, server.name, openApiContent, tenantId);
    const oauthProvidersByName = (0, import_groupBy.default)(
      providers.filter((p) => "authorizationUrl" in p.provider),
      "specName"
    );
    const apiKeyProvidersByName = (0, import_groupBy.default)(
      providers.filter((p) => "keyIn" in p.provider),
      "specName"
    );
    if (openApiContent.paths) {
      for (const [path, pathItem] of Object.entries(openApiContent.paths)) {
        if (typeof pathItem === "object" && pathItem !== null) {
          for (const [method, operation] of Object.entries(pathItem)) {
            if (typeof operation === "object" && operation !== null && ("operationId" in operation || "responses" in operation)) {
              const parameters = operation.parameters?.reduce(
                (acc, param) => {
                  if (typeof param === "object" && param !== null && "name" in param) {
                    acc[param.name] = param;
                  }
                  return acc;
                },
                {}
              ) || {};
              if (operation.requestBody) {
                const requestBody = operation.requestBody;
                if (typeof requestBody === "object" && "content" in requestBody) {
                  const jsonContent = requestBody.content?.["application/json"];
                  if (jsonContent?.schema) {
                    parameters["body"] = {
                      in: "body",
                      name: "body",
                      schema: jsonContent.schema,
                      required: requestBody.required ?? true
                    };
                  }
                }
              }
              let folderId = null;
              const tags = operation.tags || [];
              if (tags.length > 0) {
                const tag = tags[0];
                if (!foldersByName[tag]) {
                  foldersByName[tag] = await tx.folder.create({
                    data: {
                      name: tag,
                      tenantId,
                      serverId: server.id
                    }
                  });
                }
                folderId = foldersByName[tag].id;
              }
              let apiKeyProviderId = null;
              let oAuthProviderId = null;
              const securitySpecNames = operation.security?.flatMap((sec) => Object.keys(sec)) || [];
              for (const security of securitySpecNames) {
                if (apiKeyProvidersByName[security]) {
                  apiKeyProviderId = apiKeyProvidersByName[security][0].provider.id;
                }
                if (oauthProvidersByName[security]) {
                  oAuthProviderId = oauthProvidersByName[security][0].provider.id;
                }
              }
              const toolName = getToolName(operation, method, path);
              const isSelected = selectedTools ? selectedTools.some((selectedTool) => selectedTool.toLowerCase() === toolName.toLowerCase()) : true;
              await tx.tool.create({
                data: {
                  name: toolName,
                  description: operation.summary || operation.description || "",
                  enabled: isSelected,
                  parameters,
                  responses: operation.responses || {},
                  method: method.toUpperCase(),
                  url: path,
                  responseFormatting: {},
                  requestParameterOverrides: generateRequestOverridesFromOperation(operation, pathItem),
                  tenantId,
                  serverId: server.id,
                  folderId,
                  apiKeyProviderId,
                  oAuthProviderId
                }
              });
            }
          }
        }
      }
    }
    return {
      ...server,
      oauthProviders: Object.values(oauthProvidersByName).map((providers2) => providers2[0].provider)
    };
  });
}
async function createExampleTodosServer(db, tenantId) {
  try {
    return await createServerFromOpenApiSpec(
      db,
      tenantId,
      "Todos API Example",
      "A sample To-Dos API for testing and learning MCP capabilities",
      TODOS_OPENAPI_SPEC
    );
  } catch (error) {
    console.error("Error in createExampleTodosServer:", error);
    throw error;
  }
}
async function getToolsForServer(db, tenantId, serverId, adminEmail) {
  return (await db.tool.findMany({
    where: {
      serverId,
      tenantId
    },
    include: {
      oAuthProvider: {
        include: {
          providerTokens: {
            where: {
              user: {
                email: adminEmail,
                tenantId
              }
            }
          }
        }
      }
    },
    orderBy: [
      {
        name: "asc"
      },
      {
        id: "asc"
      }
    ]
  })).map((tool2) => mapTool(tool2, (tool2.oAuthProvider?.providerTokens || []).length > 0));
}
async function getToolById(db, tenantId, toolId, adminEmail) {
  const tool2 = await db.tool.findUnique({
    where: {
      id: toolId,
      tenantId
    },
    include: {
      oAuthProvider: {
        include: {
          providerTokens: {
            where: {
              user: {
                email: adminEmail,
                tenantId
              }
            }
          }
        }
      }
    }
  });
  return tool2 ? mapTool(tool2, (tool2.oAuthProvider?.providerTokens || []).length > 0) : null;
}
async function createTool(db, serverId, tenantId, toolData) {
  return await db.$transaction(async (tx) => {
    if (toolData.oAuthProviderId) {
      const provider = await tx.oAuthProvider.findUnique({
        where: { id: toolData.oAuthProviderId, tenantId }
      });
      if (!provider) {
        throw new Error(`OAuth provider with ID ${toolData.oAuthProviderId} not found`);
      }
    }
    if (toolData.apiKeyProviderId) {
      const provider = await tx.apiKeyProvider.findUnique({
        where: { id: toolData.apiKeyProviderId, tenantId }
      });
      if (!provider) {
        throw new Error(`API Key provider with ID ${toolData.apiKeyProviderId} not found`);
      }
    }
    const server = await tx.mcpServer.findUnique({
      where: { id: serverId },
      select: { authType: true }
    });
    let requestParameterOverrides = toolData.requestParameterOverrides || {};
    if (server?.authType === "JWT" /* JWT */) {
      requestParameterOverrides = {
        ...requestParameterOverrides,
        Authorization: {
          value: "Bearer {{toolParams.jwt}}",
          location: "header" /* HEADER */
        }
      };
    }
    return await tx.tool.create({
      data: {
        name: (0, import_snakeCase2.default)(toolData.name).slice(0, TOOL_NAME_MAX_LENGTH),
        description: toolData.description,
        folderId: toolData.folderId,
        parameters: toolData.parameters || {},
        method: toolData.method || "GET",
        url: toolData.url || "",
        oAuthProviderId: toolData.oAuthProviderId,
        apiKeyProviderId: toolData.apiKeyProviderId,
        responseFormatting: toolData.responseFormatting || {},
        requestParameterOverrides: requestParameterOverrides || null,
        tenantId,
        serverId
      }
    });
  });
}
async function updateToolById(db, tenantId, toolId, updateData) {
  const { requestParameterOverrides, responseFormatting, parameters, responses, ...rest } = updateData;
  const jsonFields = {};
  if (requestParameterOverrides !== null && requestParameterOverrides !== void 0) {
    jsonFields.requestParameterOverrides = requestParameterOverrides;
  }
  if (responseFormatting !== null && responseFormatting !== void 0) {
    jsonFields.responseFormatting = responseFormatting;
  }
  if (parameters !== null && parameters !== void 0) {
    jsonFields.parameters = parameters;
  }
  if (responses !== null && responses !== void 0) {
    jsonFields.responses = responses;
  }
  return mapTool(
    await db.tool.update({
      where: {
        id: toolId,
        tenantId
      },
      data: {
        ...(0, import_omit2.default)(rest, ["folderId", "providerId"]),
        ...jsonFields,
        ...updateData.name ? { name: (0, import_snakeCase2.default)(updateData.name).slice(0, TOOL_NAME_MAX_LENGTH) } : {},
        ..."folderId" in updateData ? updateData.folderId ? {
          folder: {
            connect: {
              id: updateData.folderId
            }
          }
        } : {
          folder: {
            disconnect: true
          }
        } : {},
        ...updateData.providerId ? {
          oAuthProvider: {
            connect: {
              id: updateData.providerId
            }
          }
        } : {
          oAuthProvider: {
            disconnect: true
          }
        }
      }
    })
  );
}
async function deleteToolById(db, tenantId, toolId) {
  return await db.tool.delete({
    where: {
      id: toolId,
      tenantId
    }
  });
}
var import_groupBy, import_omit2, import_snakeCase2, mapServer, mapServerWithAuth, mapTool, TODOS_OPENAPI_SPEC;
var init_servers_service = __esm({
  "src/services/servers.service.ts"() {
    "use strict";
    import_groupBy = __toESM(require("lodash/groupBy.js"), 1);
    import_omit2 = __toESM(require("lodash/omit.js"), 1);
    import_snakeCase2 = __toESM(require("lodash/snakeCase.js"), 1);
    init_config();
    init_generateRequestOverrides();
    init_icons();
    init_openapi();
    init_tools();
    mapServer = (server) => ({
      ...server,
      description: server.description || void 0,
      toolCount: server._count?.tools,
      authType: server.authType,
      authConfigId: server.authConfigId || void 0,
      createdAt: server.createdAt.toISOString(),
      updatedAt: server.updatedAt.toISOString()
    });
    mapServerWithAuth = (server) => ({
      ...mapServer(server),
      authConfig: server.authConfig ? {
        id: server.authConfig.id,
        serverId: server.authConfig.serverId,
        authType: server.authConfig.authType,
        createdAt: server.authConfig.createdAt.toISOString(),
        updatedAt: server.authConfig.updatedAt.toISOString(),
        jwtProvider: server.authConfig.jwtProvider ? {
          id: server.authConfig.jwtProvider.id,
          name: server.authConfig.jwtProvider.name,
          jwksUrl: server.authConfig.jwtProvider.jwksUrl,
          enabled: server.authConfig.jwtProvider.enabled
        } : void 0
      } : void 0
    });
    mapTool = (tool2, adminAuthorized = false) => ({
      ...tool2,
      folderId: tool2.folderId || void 0,
      parameters: tool2.parameters || {},
      method: tool2.method,
      oAuthProviderId: tool2.oAuthProviderId || void 0,
      apiKeyProviderId: tool2.apiKeyProviderId || void 0,
      responseFormatting: tool2.responseFormatting,
      requestParameterOverrides: tool2.requestParameterOverrides,
      responses: tool2.responses,
      adminAuthorized,
      enabled: tool2.enabled,
      createdAt: tool2.createdAt.toISOString(),
      updatedAt: tool2.updatedAt.toISOString()
    });
    TODOS_OPENAPI_SPEC = {
      openapi: "3.0.0",
      info: {
        title: "Todos API",
        description: "A REST API for testing and prototyping applications that need to interact with a TODO list.",
        version: "1.0.0",
        contact: {
          name: "Todos API",
          url: "https://jsonplaceholder.typicode.com"
        }
      },
      servers: [
        {
          url: "https://jsonplaceholder.typicode.com",
          description: "JSONPlaceholder API Server"
        }
      ],
      tags: [
        {
          name: "todos",
          description: "Operations related to todo items"
        }
      ],
      paths: {
        "/todos": {
          get: {
            operationId: "get-all-todos",
            tags: ["todos"],
            summary: "Get all todos",
            description: "Returns a list of all todo items",
            parameters: [
              {
                name: "userId",
                in: "query",
                description: "Filter todos by user ID",
                required: false,
                schema: {
                  type: "integer",
                  format: "int64"
                }
              }
            ],
            responses: {
              "200": {
                description: "A list of todo items",
                content: {
                  "application/json": {
                    schema: {
                      type: "array",
                      items: {
                        $ref: "#/components/schemas/Todo"
                      }
                    }
                  }
                }
              }
            }
          },
          post: {
            operationId: "create-a-new-todo",
            tags: ["todos"],
            summary: "Create a new todo",
            description: "Creates a new todo item",
            requestBody: {
              description: "Todo item to create",
              required: true,
              content: {
                "application/json": {
                  schema: {
                    $ref: "#/components/schemas/TodoInput"
                  }
                }
              }
            },
            responses: {
              "201": {
                description: "Todo created successfully",
                content: {
                  "application/json": {
                    schema: {
                      $ref: "#/components/schemas/Todo"
                    }
                  }
                }
              }
            }
          }
        },
        "/todos/{id}": {
          get: {
            operationId: "get-a-todo",
            tags: ["todos"],
            summary: "Get a todo by ID",
            description: "Returns a single todo by ID",
            parameters: [
              {
                name: "id",
                in: "path",
                description: "ID of the todo to retrieve",
                required: true,
                schema: {
                  type: "integer",
                  format: "int64"
                }
              }
            ],
            responses: {
              "200": {
                description: "Todo found",
                content: {
                  "application/json": {
                    schema: {
                      $ref: "#/components/schemas/Todo"
                    }
                  }
                }
              }
            }
          },
          put: {
            operationId: "update-a-todo",
            tags: ["todos"],
            summary: "Update a todo completely",
            description: "Replaces all properties of a todo item",
            parameters: [
              {
                name: "id",
                in: "path",
                description: "ID of the todo to update",
                required: true,
                schema: {
                  type: "integer",
                  format: "int64"
                }
              }
            ],
            requestBody: {
              description: "Updated todo object",
              required: true,
              content: {
                "application/json": {
                  schema: {
                    $ref: "#/components/schemas/TodoUpdate"
                  }
                }
              }
            },
            responses: {
              "200": {
                description: "Todo updated successfully",
                content: {
                  "application/json": {
                    schema: {
                      $ref: "#/components/schemas/Todo"
                    }
                  }
                }
              }
            }
          },
          delete: {
            operationId: "delete-a-todo",
            tags: ["todos"],
            summary: "Delete a todo",
            description: "Deletes a todo item",
            parameters: [
              {
                name: "id",
                in: "path",
                description: "ID of the todo to delete",
                required: true,
                schema: {
                  type: "integer",
                  format: "int64"
                }
              }
            ],
            responses: {
              "200": {
                description: "Todo deleted successfully"
              }
            }
          }
        }
      },
      components: {
        schemas: {
          Todo: {
            type: "object",
            required: ["id", "userId", "title", "completed"],
            properties: {
              id: {
                type: "integer",
                format: "int64",
                description: "Unique identifier for the todo",
                example: 1
              },
              userId: {
                type: "integer",
                format: "int64",
                description: "ID of the user who owns this todo",
                example: 1
              },
              title: {
                type: "string",
                description: "Task description",
                example: "Complete project documentation"
              },
              completed: {
                type: "boolean",
                description: "Whether the task is completed",
                example: false
              }
            }
          },
          TodoInput: {
            type: "object",
            required: ["userId", "title"],
            properties: {
              userId: {
                type: "integer",
                format: "int64",
                description: "ID of the user who owns this todo",
                example: 1
              },
              title: {
                type: "string",
                description: "Task description",
                example: "Write unit tests"
              },
              completed: {
                type: "boolean",
                description: "Whether the task is completed",
                example: false,
                default: false
              }
            }
          },
          TodoUpdate: {
            type: "object",
            required: ["id", "userId", "title", "completed"],
            properties: {
              id: {
                type: "integer",
                format: "int64",
                description: "ID of the todo (must match path parameter)",
                example: 1
              },
              userId: {
                type: "integer",
                format: "int64",
                description: "ID of the user who owns this todo",
                example: 1
              },
              title: {
                type: "string",
                description: "Task description",
                example: "Updated task description"
              },
              completed: {
                type: "boolean",
                description: "Whether the task is completed",
                example: true
              }
            }
          }
        }
      }
    };
  }
});

// src/main.ts
var import_cors = __toESM(require("cors"), 1);
var import_express15 = __toESM(require("express"), 1);
var import_http_status_codes19 = require("http-status-codes");

// src/utils/connection.ts
var import_client = require("@prisma/client");
var import_prisma_field_encryption = require("prisma-field-encryption");
init_logger();
init_secrets_service();

// src/utils/logger-cls.ts
var import_cls_hooked = require("cls-hooked");
var requestLoggerNamespace = (0, import_cls_hooked.createNamespace)("req-logger");
var requestLoggerKey = "logger";
var withRequestLogger = (logger2, action) => {
  requestLoggerNamespace.run(() => {
    requestLoggerNamespace.set(requestLoggerKey, logger2);
    action();
  });
};
var getRequestLogger = () => {
  return requestLoggerNamespace.get(requestLoggerKey);
};

// src/utils/connection.ts
var prisma = new import_client.PrismaClient({
  log: [
    {
      emit: "event",
      level: "query"
    },
    {
      emit: "event",
      level: "error"
    },
    {
      emit: "event",
      level: "info"
    },
    {
      emit: "event",
      level: "warn"
    }
  ]
});
var auditLog = (model, operation, args) => {
  if (!model || !operation.startsWith("create") && !operation.startsWith("update") && !operation.startsWith("delete")) {
    return;
  }
  const id = args["data"]?.["id"];
  const name = args["data"]?.["name"];
  const keys = Object.keys(args["data"] || {});
  getRequestLogger()?.info("DB Audit Log", {
    model,
    operation,
    id,
    name,
    keys
  });
};
prisma.$on("query", (e) => {
  logger_default.debug("Query:", {
    query: e.query,
    duration: e.duration,
    timestamp: e.timestamp
  });
});
prisma.$on("error", (e) => {
  logger_default.error("Database error:", {
    error: e.message,
    timestamp: e.timestamp
  });
});
prisma.$on("warn", (e) => {
  logger_default.warn("Database warning:", {
    warning: e.message,
    timestamp: e.timestamp
  });
});
prisma.$on("info", (e) => {
  logger_default.debug("Database info:", {
    info: e.message,
    timestamp: e.timestamp
  });
});
process.on("SIGINT", async () => {
  await prisma.$disconnect();
  process.exit(0);
});
var disconnectDatabase = async () => {
  try {
    await prisma.$disconnect();
    logger_default.debug("Database connection closed");
  } catch (error) {
    logger_default.error("Error disconnecting from database", error);
  }
};
var connection_default = (async () => {
  const secrets = await getAppSecrets();
  return prisma.$extends(
    (0, import_prisma_field_encryption.fieldEncryptionExtension)({
      encryptionKey: secrets.dbEncryptionKey
    })
  ).$extends({
    name: "auditLog",
    query: {
      $allOperations({ model, operation, args, query }) {
        const res = query(args);
        auditLog(model, operation, args);
        return res;
      }
    }
  });
})();

// src/middlewares/db.middleware.ts
var dbMiddleware = async (req, _res, next) => {
  req.db = await connection_default;
  next();
};

// src/middlewares/error.middleware.ts
var import_http_status_codes = require("http-status-codes");

// src/utils/req-guards.ts
var isAppRequest = (req) => "logger" in req && "db" in req;
var isWithServerIdRequest = (req) => "serverId" in req;
var isAdminRequest = (req) => "admin" in req;
var TypeGuardError = class extends Error {
  constructor() {
    super("Type guard failed");
  }
};

// src/middlewares/error.middleware.ts
var errorHandler = (err, req, res, next) => {
  if (isAppRequest(req)) {
    req.logger.error("Error", err);
  }
  res.status(import_http_status_codes.StatusCodes.INTERNAL_SERVER_ERROR).json({
    error: err.message
  });
};

// src/middlewares/logger.middleware.ts
var crypto2 = __toESM(require("crypto"), 1);
init_logger();
var loggerMiddleware = (req, res, next) => {
  req.logger = logger_default.child({
    request: {
      id: crypto2.randomUUID(),
      method: req.method,
      path: req.path,
      params: Object.keys(req.params || {}),
      bodyLen: req.headers["content-length"] || null
    }
  });
  withRequestLogger(req.logger, () => {
    next();
  });
};

// src/middlewares/session.middleware.ts
var import_client2 = require("@prisma/client");
var import_http_status_codes3 = require("http-status-codes");
init_cache_service();
init_jwt_service();

// src/services/oauth.service.ts
var import_axios = __toESM(require("axios"), 1);
var import_http_status_codes2 = require("http-status-codes");
var import_omit = __toESM(require("lodash/omit.js"), 1);
var import_qs = __toESM(require("qs"), 1);

// src/types/error.types.ts
var JSONRPC_INTERNAL_ERROR = -32603;
var JSONRPC_METHOD_NOT_ALLOWED = -32e3;
var APP_INSUFFICIENT_PERMISSIONS = -33001;
var APP_INVALID_SERVER = -33003;
var APP_BAD_REQUEST = -33400;
var OAuthError = class extends Error {
  constructor(message, statusCode, errorCode) {
    super(message);
    this.name = "OAuthError";
    this.statusCode = statusCode;
    this.errorCode = errorCode;
  }
};

// src/services/oauth.service.ts
init_config();
var ENDUSER_SCOPE = "enduser";
var TOOL_SCOPE = "tool";
var encodeData = (data) => Buffer.from(JSON.stringify(data)).toString("base64");
var decodeData = (encoded) => JSON.parse(Buffer.from(encoded, "base64").toString());
var oauthAuthHeader = (provider) => "Basic " + Buffer.from(`${provider.clientId}:${provider.clientSecret}`).toString("base64");
var getHostUrl = (req, useServerHost) => {
  if (useServerHost) {
    const protocol = isLocalRun ? req.get("X-Forwarded-Proto") || req.protocol : "https";
    const host = `${protocol}://${req.get("host")}`;
    return host.endsWith("/") ? host.slice(0, -1) : host;
  }
  return process.env.CONSOLE_URL;
};
var callbackUrl = (req) => `${getHostUrl(req, isLocalRun)}/api/oauth/callback`;
var exchangeCodeForToken = async (logger2, provider, code, callbackUrl2) => {
  logger2.debug(`Exchanging auth code for token with provider: ${provider.name} (${provider.id})`);
  logger2.debug(`Using callback URL: ${callbackUrl2}`);
  const tokenRequestData = {
    redirect_uri: callbackUrl2,
    code,
    grant_type: "authorization_code"
  };
  const refreshUrl = provider.refreshUrl || provider.tokenUrl;
  logger2.debug(`Making token request to: ${refreshUrl}`);
  const contentType = provider.contentType || "application/json";
  try {
    const tokenResponse = await import_axios.default.post(
      provider.refreshUrl || provider.tokenUrl,
      contentType.includes("form") ? import_qs.default.stringify(tokenRequestData) : tokenRequestData,
      {
        headers: {
          "Content-Type": contentType,
          Authorization: oauthAuthHeader(provider)
        }
      }
    );
    logger2.debug(
      `Token exchange successful, received access_token: ${tokenResponse.data.access_token ? "\u2713" : "\u2717"}, refresh_token: ${tokenResponse.data.refresh_token ? "\u2713" : "\u2717"}`
    );
    return {
      accessToken: tokenResponse.data.access_token,
      refreshToken: tokenResponse.data.refresh_token,
      expiresIn: tokenResponse.data.expires_in || 3600,
      scope: tokenResponse.data.scope
    };
  } catch (error) {
    const errorMessage = import_axios.default.isAxiosError(error) && error.response ? `${error.response.statusText}: ${error.response.data}` : "Failed to grant token";
    logger2.warn(
      `Token exchange failed`,
      import_axios.default.isAxiosError(error) && error.response ? (0, import_omit.default)(error, ["request", "response"]) : error,
      {
        refreshUrl,
        contentType,
        ...import_axios.default.isAxiosError(error) && error.response ? {
          status: error.response.status,
          data: error.response.data
        } : {}
      }
    );
    throw new OAuthError(errorMessage, import_http_status_codes2.StatusCodes.BAD_REQUEST, "token_grant_failed");
  }
};
var refreshAndPersistAccessToken = async (db, logger2, userId, provider, refreshToken, originAddress) => {
  try {
    const tokenRequestData = {
      refresh_token: refreshToken,
      grant_type: "refresh_token"
    };
    const contentType = provider.contentType || "application/json";
    const tokenResponse = await import_axios.default.post(
      provider.refreshUrl || provider.tokenUrl,
      contentType.includes("form") ? import_qs.default.stringify(tokenRequestData) : tokenRequestData,
      {
        headers: {
          "Content-Type": contentType,
          Authorization: oauthAuthHeader(provider)
        }
      }
    );
    const tokenData = {
      accessToken: tokenResponse.data.access_token,
      expiresIn: tokenResponse.data.expires_in || 3600,
      scope: tokenResponse.data.scope,
      refreshToken: tokenResponse.data.refresh_token || refreshToken
    };
    return await persistToken(db, logger2, userId, provider.id, tokenData, originAddress);
  } catch (error) {
    logger2.warn(`Token refresh failed`, error, {
      ...import_axios.default.isAxiosError(error) && error.response ? {
        status: error.response.status,
        data: error.response.data
      } : {}
    });
    throw new OAuthError(`Failed to refresh token`, import_http_status_codes2.StatusCodes.BAD_REQUEST, "token_refresh_failed");
  }
};
var persistToken = async (db, logger2, userId, providerId, token, originAddress, jti = null) => {
  logger2.debug(`Persisting token for user ${userId} and provider ${providerId}`);
  if (providerId) {
    await db.providerToken.deleteMany({
      where: {
        providerId,
        userId
      }
    });
  }
  return await db.providerToken.create({
    data: {
      id: jti || void 0,
      providerId,
      userId,
      accessToken: token.accessToken,
      refreshToken: token.refreshToken,
      scopes: token.scope?.split(" "),
      issuedAt: /* @__PURE__ */ new Date(),
      expiresAt: token.expiresIn === null ? null : new Date(Date.now() + token.expiresIn * 1e3),
      originAddress
    }
  });
};
var getAuthorizeUrl = (req, provider, clientState, serverId, userId, origScope, originAddress, origRedirectUri = null, origClientId = null, responseType = "code") => {
  const stateData = {
    redirectUri: origRedirectUri,
    clientState,
    clientId: origClientId,
    serverId,
    scope: origScope,
    providerId: provider.id,
    originAddress,
    userId
  };
  const stateParam = encodeData(stateData);
  const authUrl = new URL(provider.authorizationUrl);
  authUrl.searchParams.append("client_id", provider.clientId);
  authUrl.searchParams.append("redirect_uri", callbackUrl(req));
  authUrl.searchParams.append("response_type", responseType);
  authUrl.searchParams.append("scope", provider.scopes.join(" "));
  authUrl.searchParams.append("state", stateParam);
  authUrl.searchParams.append("prompt", "consent");
  return authUrl.toString();
};
var getUserUseableTokens = async (db, userId, providerId) => {
  return await db.providerToken.findMany({
    where: {
      userId,
      providerId,
      OR: [
        {
          expiresAt: null
        },
        {
          expiresAt: { gte: /* @__PURE__ */ new Date() }
        },
        {
          NOT: {
            refreshToken: null
          }
        }
      ]
    },
    orderBy: {
      expiresAt: "desc"
    }
  });
};
var markTokenAsUsed = async (db, tokenId) => await db.providerToken.update({
  where: {
    id: tokenId
  },
  data: {
    lastUsedAt: /* @__PURE__ */ new Date()
  }
});

// src/utils/hash.ts
var crypto3 = __toESM(require("crypto"), 1);
var encoder = new TextEncoder();
function hashForLogging(str) {
  const data = encoder.encode(str);
  return crypto3.subtle.digest("SHA-256", data).then((hashBuffer) => {
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const base64 = Buffer.from(hashArray).toString("base64");
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  });
}

// src/middlewares/session.middleware.ts
var sessionMiddleware = async (req, res, next, scope, verifier, setter) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    req.logger.warn(`No authorization header for ${scope} provided on request to ${req.path}`);
    return res.status(import_http_status_codes3.StatusCodes.UNAUTHORIZED).json({
      error: "unauthorized",
      errorDescription: "No token provided"
    });
  }
  const token = authHeader.split(" ")[1];
  try {
    const decoded = await verifier(token);
    if (!decoded) {
      req.logger.debug("Token verification failed");
      return res.status(import_http_status_codes3.StatusCodes.UNAUTHORIZED).json({
        error: "unauthorized",
        errorDescription: "Invalid token"
      });
    }
    if (scope === "user") {
      const token2 = await cacheGetOrAdd(
        { type: "enduser_token" /* ENDUSER_TOKEN */, ids: [decoded.email, decoded.jti || ""] },
        async () => await req.db.providerToken.findUnique({
          where: {
            id: decoded.jti
          }
        })
      );
      if (!token2) {
        req.logger.warn("Token not found in database", decoded.jti);
        return res.status(import_http_status_codes3.StatusCodes.UNAUTHORIZED).json({
          error: "unauthorized",
          errorDescription: "Invalid token"
        });
      }
      setImmediate(() => markTokenAsUsed(req.db, token2.id));
    }
    setter(req, decoded);
    req.logger = req.logger.child({
      tenantId: decoded.tenantId,
      [scope === "user" ? "endUserId" : "adminId"]: decoded.id,
      email: await hashForLogging(decoded.email)
    });
    return next();
  } catch {
    return res.status(import_http_status_codes3.StatusCodes.UNAUTHORIZED).json({
      error: "unauthorized",
      errorDescription: "Invalid token"
    });
  }
};
var adminSessionMiddleware = async (req, res, next) => {
  return sessionMiddleware(req, res, next, "admin", verifyAdminToken, (req2, decoded) => req2.admin = decoded);
};
var superAdminOnlyMiddleware = (req, res, next) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  if (req.admin.role === import_client2.AdminRole.superadmin) {
    return next();
  }
  return res.status(import_http_status_codes3.StatusCodes.FORBIDDEN).json({
    error: "forbidden",
    errorDescription: "Superadmin privileges required"
  });
};

// src/routes/admins.routes.ts
var import_express = require("express");

// src/controllers/admins.controller.ts
var import_http_status_codes4 = require("http-status-codes");

// src/services/admins.service.ts
var import_client3 = require("@prisma/client");

// ../../libs/agentbridge-utils/src/lib/openapi/parse.ts
var import_json_schema_ref_resolver = require("json-schema-ref-resolver");
var import_openapi_types = require("openapi-types");

// ../../libs/agentbridge-utils/src/analytics-events.ts
var AnalyticsEvents = {
  // Authentication & Authorization Events
  ADMIN_LOGIN_ATTEMPTED: "admin.login.attempted",
  ADMIN_LOGIN_SUCCESS: "admin.login.success",
  ADMIN_LOGIN_FAILED: "admin.login.failed",
  ADMIN_LOGOUT_COMPLETED: "admin.logout.completed",
  ADMIN_SESSION_STARTED: "admin.session.started",
  ADMIN_ACCOUNT_ACTIVATED: "admin.account.activated",
  ADMIN_PERMISSION_DENIED: "admin.permission.denied",
  // Waitlist Management Events
  WAITLIST_SIGNUP_SUBMITTED: "waitlist.signup.submitted",
  // MCP Server Management Events
  MCP_SERVER_CREATE_COMPLETED: "mcp.server.create.completed",
  MCP_SERVER_CREATE_FAILED: "mcp.server.create.failed",
  // Tool Management Events
  MCP_TOOL_CREATE_COMPLETED: "mcp.tool.create.completed",
  MCP_TOOL_UPDATE_COMPLETED: "mcp.tool.update.completed",
  // Tool Execution Events
  MCP_TOOL_EXECUTION_API_CALL: "mcp.tool.execution.api_call",
  MCP_TOOL_PLAYGROUND_OPENED: "mcp.tool.playground.opened",
  // Analytics View Events
  MCP_ANALYTICS_VIEWED: "mcp.analytics.viewed",
  // Tenant Management Events
  TENANT_INVITATION_SENT: "tenant.invitation.sent",
  TENANT_INVITATION_ACCEPTED: "tenant.invitation.accepted",
  TENANT_INVITATION_CANCELLED: "tenant.invitation.cancelled",
  TENANT_USER_REMOVED: "tenant.user.removed",
  // OAuth Provider Events
  OAUTH_PROVIDER_CREATED: "oauth.provider.created",
  OAUTH_FLOW_STARTED: "oauth.flow.started",
  OAUTH_FLOW_COMPLETED: "oauth.flow.completed"
};

// src/services/analytics.service.ts
var import_posthog_node = require("posthog-node");
var AnalyticsService = class {
  constructor() {
    this.posthog = new import_posthog_node.PostHog("phc_RWNzgaQfuBegaxtWVT6QGMXJF5oirldPLdOP1uDVHtJ", {
      host: "https://app.posthog.com"
    });
  }
  track(distinctId, event, properties = {}) {
    this.posthog.capture({
      distinctId,
      event,
      properties: {
        ...properties,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        source: "backend"
      }
    });
  }
  identify(distinctId, properties) {
    this.posthog.identify({
      distinctId,
      properties
    });
  }
  async shutdown() {
    await this.posthog.shutdown();
  }
};
var analytics = new AnalyticsService();

// src/services/email.service.ts
var import_nodemailer = __toESM(require("nodemailer"), 1);

// src/services/email.service.templates.ts
var getAdminApprovalEmailTemplate = (adminEmail, verificationLink) => {
  return `<!doctype html>
  <html lang="en">
    <body style="margin: 0; padding: 0; background-color: #171e29; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #f8f9fb;">
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: #171e29; padding: 40px 0">
        <tr>
          <td align="center">
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="max-width: 600px; background-color: #1f2937; padding: 40px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);">
              <tr>
                <td style="padding: 32px 0; text-align: center; font-size: 18px">
                  A new admin has requested access:<br/>
                  <strong style="color: #2276fc">${adminEmail}</strong><br/><br/>
                  Click the button below to approve their access:
                </td>
              </tr>
              <tr>
                <td style="text-align: center; padding-bottom: 32px">
                  <a href="${verificationLink}" style="background: #2276fc; color: #FFFFFF; display: inline-block; padding: 12px 32px; text-align: center; text-decoration: none; border-radius: 4px; font-weight: bold;">Approve Admin</a>
                </td>
              </tr>
              <tr>
                <td style="text-align: center; font-size: 14px; color: #a7b0bd">
                  If you did not expect this request, you can safely ignore this message.
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </body>
  </html>`;
};
var getAdminApprovedEmailTemplate = (appLink) => {
  return `<!doctype html>
  <html lang="en">
    <body style="margin: 0; padding: 0; background-color: #171e29; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #f8f9fb;">
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: #171e29; padding: 40px 0">
        <tr>
          <td align="center">
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="max-width: 600px; background-color: #1f2937; padding: 40px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);">
              <tr>
                <td style="padding: 16px 0; text-align: center; font-size: 16px; color: #f8f9fb;">
                  Great news! Your account has been approved and you're now ready to start using AgentPass.<br/><br/>
                  Click the button below to access your dashboard and start exploring:
                </td>
              </tr>
              <tr>
                <td style="text-align: center;">
                  <a href="${appLink}" style="background: #2276fc; color: #FFFFFF; display: inline-block; padding: 12px 32px; text-align: center; text-decoration: none; border-radius: 4px; font-weight: bold;">Go to AgentPass</a>
                </td>
              </tr>
              <tr>
                <td style="padding: 16px 0; text-align: center; font-size: 15px; color: #f8f9fb;">
                  We're excited to have you onboard!<br/>
                  <span style="color: #b0b7c3;">The AgentPass Team</span>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </body>
  </html>`;
};
var getEasterEggWelcomeEmailTemplate = (appLink) => {
  return `<!doctype html>
  <html lang="en">
    <body style="margin: 0; padding: 0; background-color: #171e29; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #f8f9fb;">
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: #171e29; padding: 40px 0">
        <tr>
          <td align="center">
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="max-width: 600px; background-color: #1f2937; padding: 40px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);">
              <tr>
                <td style="text-align: center; font-size: 28px; font-weight: bold; padding-bottom: 10px">
                  <span style="color: #2276fc">\u{1F680} AgentPass.ai</span>
                </td>
              </tr>
              <tr>
                <td style="padding: 24px 0; text-align: center; font-size: 18px">
                  <strong style="color: #2276fc;">Rocket launch detected!</strong><br/><br/>
                  Congratulations on discovering our easter egg! Your curiosity and exploration have earned you instant access to AgentPass.<br/><br/>
                  Your account has been activated and you're ready to start connecting AI agents to APIs:
                </td>
              </tr>
              <tr>
                <td style="text-align: center; padding-bottom: 32px">
                  <a href="${appLink}" style="background: #2276fc; color: #FFFFFF; display: inline-block; padding: 12px 32px; text-align: center; text-decoration: none; border-radius: 4px; font-weight: bold;">\u{1F680} Launch into AgentPass</a>
                </td>
              </tr>
              <tr>
                <td style="padding: 16px 0; text-align: center; font-size: 15px; color: #f8f9fb;">
                  Thanks for launching the rocket! We're excited to have curious explorers like you onboard.<br/>
                  <span style="color: #b0b7c3;">The AgentPass Team</span>
                </td>
              </tr>
              <tr>
                <td style="text-align: center; font-size: 13px; color: #a7b0bd; padding-top: 16px;">
                  P.S. Keep exploring - there might be more surprises waiting! \u{1F3AF}
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </body>
  </html>`;
};
var getTenantInvitationEmailTemplate = (inviter, tenantName, role, invitationLink, expiresAt) => {
  return `<!doctype html>
  <html lang="en">
    <body style="margin: 0; padding: 0; background-color: #171e29; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #f8f9fb;">
      <table cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: #171e29; padding: 40px 0">
        <tr>
          <td align="center">
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="max-width: 600px; background-color: #1f2937; padding: 40px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);">
              <tr>
                <td style="text-align: center; font-size: 28px; font-weight: bold; padding-bottom: 10px">
                  <span style="color: #2276fc">AgentPass.ai</span>
                </td>
              </tr>
              <tr>
                <td style="padding: 24px 0; text-align: center; font-size: 18px">
                  <strong>${inviter}</strong> has invited you to join the tenant <strong>${tenantName}</strong> as a <strong>${role}</strong>.<br/><br/>
                  Click the button below to accept your invitation:
                </td>
              </tr>
              <tr>
                <td style="text-align: center; padding-bottom: 32px">
                  <a href="${invitationLink}" style="background: #2276fc; color: #FFFFFF; display: inline-block; padding: 12px 32px; text-align: center; text-decoration: none; border-radius: 4px; font-weight: bold;">Accept Invitation</a>
                </td>
              </tr>
              <tr>
                <td style="text-align: center; font-size: 15px; color: #a7b0bd">
                  This invitation will expire on <strong>${expiresAt.toLocaleDateString()}</strong>.<br/>
                  If you did not expect this invitation, you can safely ignore this message.
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </body>
  </html>`;
};

// src/services/email.service.ts
init_jwt_service();
init_secrets_service();
var notificationEmail = process.env.WAITLIST_NOTIFICATION_EMAIL;
var env = process.env.ENV || "dev";
var baseUrl = process.env.CONSOLE_URL || "http://localhost:4200";
var smtpPort = process.env.SMTP_PORT || "456";
var sendAddToWaitlistEmail = async (logger2, pendingAdmin) => {
  if (!notificationEmail) {
    return true;
  }
  const transporter = await createTransporter();
  logger2.debug("Sending admin approval request email", {
    targetEmail: notificationEmail,
    adminEmail: pendingAdmin.email
  });
  try {
    const verificationToken = await generateAdminVerificationToken(pendingAdmin.id);
    const verificationLink = `${baseUrl}/verify-admin?token=${verificationToken}`;
    await transporter.sendMail({
      from: `agentpass-${env}@ownid.com`,
      to: notificationEmail,
      subject: `AgentPass ${env}: New Admin Approval Required`,
      html: getAdminApprovalEmailTemplate(pendingAdmin.email, verificationLink)
    });
    return true;
  } catch (error) {
    logger2.error("Failed to send admin approval request email", error);
    return false;
  }
};
var sendAdminApprovedNotification = async (logger2, admin, isEasterEgg = false) => {
  const transporter = await createTransporter();
  logger2.debug("Sending admin approved notification email", {
    adminEmail: admin.email,
    isEasterEgg
  });
  try {
    await transporter.sendMail({
      from: `agentpass-${env}@ownid.com`,
      to: admin.email,
      subject: isEasterEgg ? `\u{1F680} Welcome to AgentPass - Rocket Launch Detected!` : `You're in! Welcome to AgentPass`,
      html: isEasterEgg ? getEasterEggWelcomeEmailTemplate(baseUrl) : getAdminApprovedEmailTemplate(baseUrl)
    });
    return true;
  } catch (error) {
    logger2.error("Failed to send admin approved notification email", error);
    return false;
  }
};
var sendTenantInvitationEmail = async (logger2, to, inviter, tenantName, invitationLink, role, expiresAt) => {
  const transporter = await createTransporter();
  logger2.debug("Sending tenant invitation email", {
    to,
    inviter,
    tenantName,
    invitationLink,
    role,
    expiresAt
  });
  try {
    await transporter.sendMail({
      from: `agentpass-${env}@ownid.com`,
      to,
      subject: `You're invited to join ${tenantName} on AgentPass`,
      html: getTenantInvitationEmailTemplate(inviter, tenantName, role, invitationLink, expiresAt)
    });
    return true;
  } catch (error) {
    logger2.error("Failed to send tenant invitation email", error);
    return false;
  }
};
var createTransporter = async () => {
  const appSecrets2 = await getAppSecrets();
  return import_nodemailer.default.createTransport({
    host: appSecrets2.smtpHost,
    port: Number(appSecrets2.smtpPort),
    secure: appSecrets2.smtpPort === smtpPort,
    auth: {
      user: appSecrets2.smtpUsername,
      pass: appSecrets2.smtpPassword
    }
  });
};

// src/services/admins.service.ts
init_jwt_service();
async function createAdminUser(db, email, tenantId, extras) {
  let role;
  if (email.endsWith("@ownid.com")) {
    role = import_client3.AdminRole.superadmin;
  } else {
    role = import_client3.AdminRole.admin;
  }
  return await db.admin.create({
    data: {
      ...extras,
      email: email.toLowerCase(),
      tenantId,
      role
    }
  });
}
async function createTenant(db, name) {
  return await db.tenant.create({
    data: {
      name
    }
  });
}
async function setAdminOwnIdData(db, email, ownIdData) {
  const admin = await db.admin.findFirst({
    where: {
      email: {
        equals: email,
        mode: "insensitive"
      }
    }
  });
  if (!admin) {
    return { status: "NOT_FOUND", error: "Admin not found" };
  }
  await db.admin.update({
    where: {
      id: admin.id
    },
    data: {
      ownidData: ownIdData
    }
  });
  return { status: "OK", error: null };
}
async function getAdminOwnIdData(db, logger2, email) {
  const admin = await db.admin.findFirst({
    where: {
      email: {
        equals: email,
        mode: "insensitive"
      }
    }
  });
  if (!admin) {
    logger2.debug("Admin not found", { email });
    return { status: "NOT_FOUND", error: "Admin not found" };
  }
  logger2.debug("Admin found", { email, ownidData: admin.ownidData, enabled: admin.enabled });
  if (!admin.enabled) {
    return { status: "LOCKED", error: "Admin not enabled" };
  }
  if (admin.ownidData) {
    return { status: "OK", data: { ownIdData: admin.ownidData } };
  }
  return { status: "NO_CONTENT" };
}
async function createAdminSession(db, logger2, email) {
  const admin = await db.admin.findFirst({
    where: {
      email: {
        equals: email,
        mode: "insensitive"
      }
    }
  });
  if (!admin) {
    logger2.debug("Admin not found", { email });
    return { status: "NOT_FOUND", error: "Admin not found" };
  }
  const token = await generateAdminToken(admin);
  return { status: "OK", data: { token } };
}
async function getAdmins(db) {
  return db.admin.findMany({
    where: {
      role: {
        in: ["admin", "superadmin"]
      }
    },
    orderBy: [{ name: "asc" }, { id: "asc" }],
    include: { tenant: true }
  });
}
async function putEnabled(db, logger2, adminId, enabled, sendNotification, approvedByAdminId) {
  const admin = await db.admin.update({
    where: { id: adminId },
    data: { enabled },
    include: { tenant: true }
  });
  if (enabled) {
    analytics.track(admin.id, AnalyticsEvents.ADMIN_ACCOUNT_ACTIVATED, {
      email: admin.email,
      tenant_id: admin.tenantId,
      activation_method: "manual_approval",
      approved_by: approvedByAdminId || "system",
      wait_time_hours: admin.createdAt ? Math.floor((Date.now() - new Date(admin.createdAt).getTime()) / (1e3 * 60 * 60)) : 0
    });
  }
  if (sendNotification) {
    await sendAdminApprovedNotification(logger2, admin);
  }
  return admin;
}
async function putUpdateAdmin(db, adminId, updates) {
  const data = {};
  if (updates.name !== void 0) {
    data.name = updates.name;
  }
  if (updates.role !== void 0) {
    data.role = updates.role.toLowerCase();
  }
  return db.admin.update({
    where: { id: adminId },
    data
  });
}
async function getAdmin(db, adminId) {
  return db.admin.findUnique({
    where: { id: adminId }
  });
}

// src/controllers/admins.controller.ts
init_jwt_service();
var addToWaitlist = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  const email = req.body.email.toLowerCase();
  const easterEggBypass = req.body.easterEggBypass || false;
  req.logger.debug("Processing waitlist request", { email, easterEggBypass });
  try {
    const existingAdmin = await req.db.admin.findFirst({
      where: {
        email: {
          equals: email,
          mode: "insensitive"
        }
      }
    });
    if (existingAdmin) {
      if (easterEggBypass && !existingAdmin.enabled) {
        await req.db.admin.update({
          where: { id: existingAdmin.id },
          data: { enabled: true }
        });
        await sendAdminApprovedNotification(req.logger, existingAdmin, true);
        req.logger.info("\u{1F680} Easter egg bypass used - enabled existing user", { email });
        return res.status(import_http_status_codes4.StatusCodes.OK).json({ message: "Account enabled via easter egg bypass!" });
      }
      const message = existingAdmin.enabled ? "User already has access" : "User already on waitlist";
      return res.status(import_http_status_codes4.StatusCodes.OK).json({ message });
    }
    let admin;
    try {
      const tenant = await createTenant(req.db, email);
      admin = await createAdminUser(req.db, email, tenant.id, {
        emailVerified: true,
        enabled: easterEggBypass
      });
      if (easterEggBypass) {
        analytics.track(admin.id, AnalyticsEvents.ADMIN_ACCOUNT_ACTIVATED, {
          email: admin.email,
          tenant_id: admin.tenantId,
          activation_method: "easter_egg",
          approved_by: "easter_egg",
          wait_time_hours: 0
        });
      }
    } catch (createError) {
      const error = createError;
      if (error.code === "P2002" && error.meta?.target?.includes("email")) {
        req.logger.info("Admin was created concurrently, fetching existing", { email });
        const existingAdmin2 = await req.db.admin.findFirst({
          where: { email: { equals: email, mode: "insensitive" } }
        });
        if (existingAdmin2) {
          if (easterEggBypass && !existingAdmin2.enabled) {
            admin = await req.db.admin.update({
              where: { id: existingAdmin2.id },
              data: { enabled: true }
            });
            analytics.track(admin.id, AnalyticsEvents.ADMIN_ACCOUNT_ACTIVATED, {
              email: admin.email,
              tenant_id: admin.tenantId,
              activation_method: "easter_egg",
              approved_by: "easter_egg",
              wait_time_hours: Math.round((Date.now() - existingAdmin2.createdAt.getTime()) / (1e3 * 60 * 60))
            });
            await sendAdminApprovedNotification(req.logger, admin, true);
            req.logger.info("\u{1F680} Easter egg bypass used - enabled concurrent user", { email });
          } else {
            admin = existingAdmin2;
          }
        } else {
          throw createError;
        }
      } else {
        throw createError;
      }
    }
    const success = easterEggBypass ? await sendAdminApprovedNotification(req.logger, admin, true) : await sendAddToWaitlistEmail(req.logger, admin);
    if (easterEggBypass) {
      req.logger.info("\u{1F680} Easter egg bypass used", { email });
    }
    if (success) {
      const message = easterEggBypass ? "Account created and enabled via easter egg bypass!" : "Added to waitlist";
      res.status(import_http_status_codes4.StatusCodes.OK).json({ message });
    } else {
      res.status(import_http_status_codes4.StatusCodes.INTERNAL_SERVER_ERROR).json({ message: "Failed to send email" });
    }
  } catch (error) {
    req.logger.error("Error in addToWaitlist", { error, email });
    res.status(import_http_status_codes4.StatusCodes.INTERNAL_SERVER_ERROR).json({ message: "Failed to process request" });
  }
};
var listAdmins = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  const admins = await getAdmins(req.db);
  if (!admins) {
    return res.status(import_http_status_codes4.StatusCodes.NOT_FOUND).json({ message: "No admins found" });
  }
  res.json(admins);
};
var updateAdmin = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  const admin = await putUpdateAdmin(req.db, req.params.adminId, req.body);
  res.json(admin);
};
var enableAdmin = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  let adminId = req.params.adminId;
  if (req.body.token) {
    const admin2 = await verifyAdminVerificationToken(req.body.token);
    if (!admin2) {
      return res.status(import_http_status_codes4.StatusCodes.UNAUTHORIZED).json({ message: "Invalid verification token" });
    }
    adminId = admin2.id;
  }
  const admin = await putEnabled(
    req.db,
    req.logger,
    adminId,
    req.body.enabled,
    req.body.sendNotification,
    req.admin.id
  );
  res.json(admin);
};
var sendAdminApprovedNotification2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  const admin = await getAdmin(req.db, req.params.adminId);
  if (!admin) {
    return res.status(import_http_status_codes4.StatusCodes.NOT_FOUND).json({ message: "Admin not found" });
  }
  await sendAdminApprovedNotification(req.logger, admin);
  res.json(admin);
};

// src/routes/admins.routes.ts
var router = (0, import_express.Router)();
router.post("/waitlist", addToWaitlist);
router.put("/:adminId/enable", adminSessionMiddleware, superAdminOnlyMiddleware, enableAdmin);
router.put("/:adminId", adminSessionMiddleware, superAdminOnlyMiddleware, updateAdmin);
router.get("/", adminSessionMiddleware, superAdminOnlyMiddleware, listAdmins);
router.post(
  "/:adminId/send-approved-notification",
  adminSessionMiddleware,
  superAdminOnlyMiddleware,
  sendAdminApprovedNotification2
);
var admins_routes_default = router;

// src/routes/ai.routes.ts
var import_express2 = require("express");

// src/controllers/ai.controller.ts
var import_zod2 = require("zod");

// src/services/ai.service.ts
var import_anthropic = require("@ai-sdk/anthropic");
var import_openai = require("@ai-sdk/openai");
var import_ai = require("ai");
var import_zod = require("zod");

// src/services/prompts.service.ts
var prompts = /* @__PURE__ */ new Map();
initializePrompts();
function initializePrompts() {
  prompts.set("ai-agent-system", {
    id: "ai-agent-system",
    name: "AI Agent System Prompt",
    description: "System prompt for AI assistant specialized in creating API tools for MCP servers",
    content: `You are an AI assistant specialized EXCLUSIVELY in creating API tools for MCP servers. You ONLY help with API integrations, tool creation, and related technical tasks.

CRITICAL BOUNDARIES:
- You help create API tools and integrations for MCP servers
- When users mention APIs, tools, or integrations (like "fetch figma designs", "github PR", "weather data"), understand they want to create MCP tools
- Only redirect off-topic requests that are clearly unrelated (recipes, personal advice, etc.)
- Be helpful and interpret tool-related requests correctly

MANDATORY WEB SEARCH RULE:
- You MUST search the web for API documentation BEFORE designing any tool
- Even if you think you know the API well, search for the latest documentation
- This ensures you have the most current endpoints, authentication methods, and parameters
- Start your response with something like "Let me search for the latest [API name] documentation..."

RESPONSE STYLE:
- Be conversational but concise
- Show your reasoning process naturally by starting thoughts with "[THINKING] " on separate lines
- NEVER use [SEARCHING] or any other tags - only [THINKING] is allowed
- Focus on understanding what the user needs and delivering it efficiently

CORE CAPABILITIES:
- Expert knowledge of REST APIs, OAuth 2.0, and API authentication patterns
- Familiar with popular APIs (GitHub, Slack, OpenWeatherMap, Stripe, Discord, etc.)
- Can infer common use cases from minimal context
- Access to web search for verifying current API documentation and finding latest endpoints
- ALWAYS use web search BEFORE creating any tool definition to get the most accurate API information
- Do NOT create tools unless the user explicitly confirms they want the tool created

WHAT MAKES A SUITABLE API FOR MCP TOOLS:
- Must be an HTTP endpoint (REST or GraphQL)
- REST APIs: GET, POST, PUT, DELETE, PATCH methods
- GraphQL APIs: POST method with query/mutation in the body
- Must return JSON or XML responses
- Can use authentication (OAuth, API keys, Bearer tokens)
- NOT suitable: File downloads (CSV, GTFS), SOAP services, websockets, non-HTTP protocols

WEB SEARCH BEST PRACTICES:
- When you search the web and find information, always mention the source (e.g., "According to docs.ownid.com...")
- If documentation reveals important details (authentication, headers, etc.), quote them specifically
- Web search results will be displayed to the user with clickable links
- Look specifically for REST APIs or HTTP endpoints that can be called directly
- If you only find data files (CSV, GTFS, etc.) or non-API solutions, BE HONEST about it

CONVERSATION FLOW:
1. When a user mentions an API or service, understand their intent
2. ALWAYS search the web FIRST to find the latest API documentation, even if you think you know the API
3. When web search reveals authentication requirements (HMAC, signatures, timestamps, etc.), ALWAYS include them in your tool specification
4. After finding a suitable API (REST or GraphQL), YOU MUST create a complete JSON tool specification - this is NOT optional
5. For GraphQL: Even if it's a simple mutation, CREATE THE TOOL SPECIFICATION
6. If genuinely ambiguous, ask a clarifying question
7. ALWAYS present your tool design as clean JSON with explanations, citing the sources you found
8. ALWAYS end with: "Does this look good? Would you like me to create it, or would you prefer any changes?"
9. Wait for user feedback - they might want changes or have questions
10. Only proceed to tool creation when the user explicitly confirms with phrases like:
    - "yes", "create it", "looks good", "go ahead", "perfect", "that's correct"
    - NOT when they ask questions like "did you create it?", "has it been created?", "is it done?"

IMPORTANT AUTHENTICATION RULES:
- If web search reveals HMAC signatures, include them as header parameters
- If timestamps are required for request validation, include them as header parameters
- If the API uses custom authentication headers, include ALL of them
- Don't forget path parameters like appId, organizationId, etc. that are often part of the URL
- Include response schemas when documentation provides them

CRITICAL RULE - COMPLETE THE FLOW:
When you find a suitable API (REST or GraphQL), you MUST:
1. Create the complete JSON tool specification
2. Include all parameters, authentication, and responses
3. End with the confirmation question
DO NOT stop after explaining the API - you MUST provide the tool specification!

VIOLATION WARNING: If you explain an API without providing the JSON tool specification, you are FAILING to complete your task!

TOOL SPECIFICATION FORMAT:
Only create tool specifications for HTTP endpoints (REST or GraphQL). When you've found a suitable API, present the tool specification in a JSON code block (use triple backticks with json language identifier):

{
  "tool": {
    "name": "descriptiveName",
    "description": "Clear description of what this tool does",
    "method": "GET/POST/PUT/DELETE",
    "url": "https://api.example.com/endpoint/{params}",
    "parameters": {
      "paramName": {
        "name": "paramName",
        "description": "What this parameter is for",
        "schema": {
          "type": "string/number/boolean",
          "description": "Same description for API validation"
        },
        "required": true/false,
        "in": "path/query/header/body"
      }
    },
    "responses": {
      "200": { "statusCode": 200, "description": "Success" }
    }
  },
  "auth": {
    "type": "oauth/apikey",
    "oauth": {
      "name": "ServiceName OAuth",
      "authorizationUrl": "https://...",
      "tokenUrl": "https://...",
      "scopes": ["scope1", "scope2"]
    },
    "apikey": {
      "name": "ServiceName API",
      "keyName": "API-Key-Header-Name",
      "keyIn": "header/query"
    }
  },
  "service": "ServiceName"
}

Note: Always wrap your JSON specification in a markdown code block with triple backticks and 'json' language identifier.

For REST APIs: The system will automatically generate requestParameterOverrides from your parameters.
For GraphQL: You MUST include requestParameterOverrides with the hardcoded query/mutation.

GRAPHQL SPECIFIC FORMAT:
For GraphQL endpoints, always use:
- method: "POST"
- url: The GraphQL endpoint URL (usually ends with /graphql)
- parameters: {} (empty object if no variables), or only variable parameters
- requestParameterOverrides: ALWAYS include this with the hardcoded query/mutation
  - body: { "query": "your GraphQL query here" } (add "variables" only if needed)
  - headers: { "Content-Type": "application/json" }
- DO NOT make the query itself a parameter - it should be hardcoded in requestParameterOverrides

WHY: The GraphQL query/mutation is part of the API definition, not a runtime parameter. By hardcoding it in requestParameterOverrides, the tool becomes easier to use and the query is guaranteed to be correct.

After presenting the specification, ALWAYS ask: "Does this look good? Would you like me to create it, or would you prefer any changes?"

NEVER skip this question - it's required for the flow to continue!

EXAMPLE WHEN NO API FOUND:
"Let me search for the latest Mallorca bus schedule API documentation...

[THINKING] I'm searching for REST APIs that provide Mallorca bus schedules

I searched for Mallorca bus schedule APIs, but I couldn't find a suitable REST API. What I found instead:
- The CTM (Consorcio de Transportes de Mallorca) provides GTFS files that need to be downloaded
- This is static data in file format, not a REST API endpoint

Unfortunately, GTFS files aren't suitable for MCP tools because they require downloading and parsing files rather than making HTTP API calls. 

For bus schedule data, you might want to:
1. Look for third-party transit APIs that serve GTFS data via REST endpoints
2. Check if there's a regional transport API that includes Mallorca
3. Consider APIs like Transitland or OpenTripPlanner that might have imported this data

Would you like me to search for alternative transit APIs that might cover Mallorca?"

EXAMPLE OF COMPLETE FLOW (OpenWeatherMap):
User: "I need to get weather for Mallorca"
Assistant: Let me search for the latest OpenWeatherMap API documentation to find how we can retrieve weather for Mallorca.

[THINKING] I'm searching for REST APIs providing weather data, specifically OpenWeatherMap, as it's a popular choice.

According to OpenWeatherMap's documentation (openweathermap.org), their API provides comprehensive weather data worldwide. Here's a tool to get weather for Mallorca:

\`\`\`json
{
  "tool": {
    "name": "getMallorcaWeather",
    "description": "Get current weather data for any location in Mallorca using OpenWeatherMap API",
    "method": "GET",
    "url": "https://api.openweathermap.org/data/2.5/weather",
    "parameters": {
      "q": {
        "name": "q",
        "description": "City name in Mallorca (e.g., 'Palma,ES', 'Inca,ES', 'Manacor,ES')",
        "schema": {
          "type": "string",
          "description": "City name with country code"
        },
        "required": true,
        "in": "query"
      },
      "lat": {
        "name": "lat",
        "description": "Latitude coordinate (e.g., 39.5696 for Palma)",
        "schema": {
          "type": "number",
          "description": "Latitude coordinate"
        },
        "required": false,
        "in": "query"
      },
      "lon": {
        "name": "lon",
        "description": "Longitude coordinate (e.g., 2.6502 for Palma)",
        "schema": {
          "type": "number",
          "description": "Longitude coordinate"
        },
        "required": false,
        "in": "query"
      },
      "units": {
        "name": "units",
        "description": "Units of measurement. standard, metric and imperial units are available",
        "schema": {
          "type": "string",
          "enum": ["standard", "metric", "imperial"],
          "default": "metric",
          "description": "Temperature units"
        },
        "required": false,
        "in": "query"
      },
      "lang": {
        "name": "lang",
        "description": "Language for weather descriptions (e.g., 'es' for Spanish, 'en' for English)",
        "schema": {
          "type": "string",
          "description": "Language code"
        },
        "required": false,
        "in": "query"
      }
    },
    "responses": {
      "200": {
        "statusCode": 200,
        "description": "Successful response with weather data"
      },
      "404": {
        "statusCode": 404,
        "description": "City not found"
      },
      "401": {
        "statusCode": 401,
        "description": "Invalid API key"
      }
    }
  },
  "auth": {
    "type": "apikey",
    "apikey": {
      "name": "OpenWeatherMap API",
      "keyName": "appid",
      "keyIn": "query"
    }
  },
  "service": "openweathermap"
}
\`\`\`

This tool will let you get current weather for any city in Mallorca. You can either use city names (like "Palma,ES") or coordinates. The API key will be added automatically as a query parameter.

Does this look good? Would you like me to create it, or would you prefer any changes?"

EXAMPLE OF GRAPHQL FLOW (Adobe Commerce):
User: "I want to create an empty cart for a guest user using Adobe Commerce GraphQL"
Assistant: Let me search for the latest Adobe Commerce GraphQL API documentation to find how to create an empty cart for guest users.

[THINKING] Adobe Commerce (Magento) uses GraphQL for many operations. Let me find the specific mutation for creating guest carts.

According to Adobe Commerce documentation (developer.adobe.com), their GraphQL API provides cart management capabilities. The createGuestCart mutation creates an empty shopping cart for a guest user. Here's a tool to create an empty cart:

\`\`\`json
{
  "tool": {
    "name": "createGuestCart",
    "description": "Create an empty cart for a guest user in Adobe Commerce",
    "method": "POST",
    "url": "https://your-store.com/graphql",
    "parameters": {},
    "requestParameterOverrides": {
      "body": {
        "query": "mutation { createGuestCart { cart { id } } }"
      },
      "headers": {
        "Content-Type": "application/json"
      }
    },
    "responses": {
      "200": {
        "statusCode": 200,
        "description": "Returns the cart ID as a string"
      }
    }
  },
  "auth": {
    "type": "none"
  },
  "service": "adobe-commerce"
}
\`\`\`

This tool will create an empty cart for a guest user and return the cart ID. The cart ID can then be used for subsequent operations like adding items or checking out.

Note: The GraphQL mutation is hardcoded in the requestParameterOverrides, so users don't need to pass it as a parameter.

Does this look good? Would you like me to create it, or would you prefer any changes?"

EXAMPLE OF GRAPHQL WITH VARIABLES:
For GraphQL operations that need variables, include them as parameters:

\`\`\`json
{
  "tool": {
    "name": "addProductToCart",
    "description": "Add a product to the cart",
    "method": "POST",
    "url": "https://your-store.com/graphql",
    "parameters": {
      "cartId": {
        "name": "cartId",
        "description": "The cart ID",
        "schema": { "type": "string" },
        "required": true,
        "in": "body"
      },
      "sku": {
        "name": "sku",
        "description": "Product SKU to add",
        "schema": { "type": "string" },
        "required": true,
        "in": "body"
      },
      "quantity": {
        "name": "quantity",
        "description": "Quantity to add",
        "schema": { "type": "number", "minimum": 1 },
        "required": true,
        "in": "body"
      }
    },
    "requestParameterOverrides": {
      "body": {
        "query": "mutation($cartId: String!, $sku: String!, $qty: Float!) { addSimpleProductsToCart(input: { cart_id: $cartId, cart_items: [{ data: { sku: $sku, quantity: $qty } }] }) { cart { items { product { name } quantity } } } }",
        "variables": {
          "cartId": "{{toolParams.cartId}}",
          "sku": "{{toolParams.sku}}",
          "qty": "{{toolParams.quantity}}"
        }
      },
      "headers": {
        "Content-Type": "application/json"
      }
    }
  }
}
\`\`\`

CRITICAL - TOOL-BASED CREATION:
- You have access to a 'createMCPTool' tool that you MUST use to create tools
- Only call this tool AFTER the user explicitly confirms they want to create the tool
- The tool takes the complete specification (tool, auth, service) as parameters
- When the tool call succeeds, the tool is actually created in the system
- Never claim to have created a tool without actually calling the createMCPTool function
- IMPORTANT: When the user confirms, you MUST immediately call the createMCPTool tool in your response
- Do NOT say "I'll proceed with creation" - just call the tool directly
- The tool call should happen in the same message where you acknowledge the confirmation

CREATION STATUS TRACKING:
- Keep track of what you've shown vs. what you've actually created
- If you've only shown a design, you HAVE NOT created the tool yet
- If a user asks "did you create it?" or similar:
  - If you only showed the design: "I've shown you the design, but haven't created it yet. Would you like me to create it now?"
  - If you actually called createMCPTool: "Yes, I've successfully created the tool [name]. It's now available in your workflow."
- Never claim to have created something without calling the createMCPTool tool

AUTHENTICATION PATTERNS:
- OAuth: GitHub, Slack, Google, Salesforce typically use OAuth 2.0
- API Keys in headers: Stripe (Bearer token), OpenAI (Bearer token), SendGrid
- API Keys in query: OpenWeatherMap (appid), some older APIs
- No auth: Some public APIs don't require authentication

WHEN NO SUITABLE API IS FOUND:
- Be HONEST and direct: "I searched but couldn't find a REST API for [service]. I found [what you found] instead."
- Explain why it's not suitable: "GTFS files need to be downloaded and parsed, which isn't suitable for MCP API tools"
- Suggest alternatives if possible: "You might want to look for a third-party API that serves this data"
- Don't try to force a solution that won't work as an MCP tool
- Don't create vague or incomplete tool definitions

IMPORTANT GUIDELINES:
- Read the conversation context to understand if the user already approved a design
- CONFIRMATION vs QUESTIONS: Distinguish between:
  - Confirmations: "yes", "create it", "looks good", "go ahead", "that's right", "perfect"
  - Status questions: "did you create it?", "has it been created?", "is it done?"
  - Respond to questions about status honestly - don't confuse them with confirmations
- If they provide feedback or ask questions, address those before creating
- Never create a tool without showing the complete specification first
- Never claim creation success without actual confirmation from the user
- Be helpful and explain your choices when relevant
- When creation is successful, ALWAYS mention the tool is "now available in your workflow canvas"

TOOL CALLING FORMAT:
When user confirms, you MUST call the tool like this:
1. Acknowledge the confirmation briefly
2. Call createMCPTool with the exact specification you showed
3. Let the tool execution complete
4. The system will show the result automatically

Remember: Good conversation is about understanding intent and responding appropriately. Questions about status are NOT confirmations to proceed.`,
    variables: [],
    category: "system",
    version: "1.0.0",
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  });
  prompts.set("mock-data-generation", {
    id: "mock-data-generation",
    name: "Mock Data Generation Prompt",
    description: "Generate realistic mock data for API tool testing",
    content: `You are an AI assistant helping developers test API tools by generating realistic mock data.

Tool Information:
- Name: {{toolName}}
- Description: {{toolDescription}}
- Method: {{method}} {{url}}
- Server: {{serverName}}

Parameters to populate:
{{parameterDetails}}

Task: Generate realistic, contextually appropriate mock data for each parameter. Consider:
1. The tool's purpose and domain (e.g., user management, e-commerce, analytics)
2. Realistic data types and formats
3. Meaningful relationships between parameters
4. Industry standards and common patterns

For example:
- Email fields should use realistic email addresses
- Names should be common first/last names
- IDs should follow typical patterns (UUIDs, incremental numbers)
- Dates should be reasonable and properly formatted
- Objects/arrays should contain meaningful nested data

Special Instructions for Authentication Fields:
- For API keys, tokens, or auth headers: Generate realistic-looking but fake values (e.g., "sk-test-1234567890abcdef" for API keys, "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..." for tokens)
- These are for testing purposes only and will not work with real APIs

Important: {{#if hasAuthFields}}This tool contains authentication/authorization fields. In your reasoning, include a warning that mock authentication data will likely result in 401/403 errors when testing, and real credentials should be configured through the authorization system.{{else}}Consider if any fields might be related to authentication or authorization.{{/if}}

Provide:
1. Generated parameter values as a key-value object
2. Brief reasoning for your choices{{#if hasAuthFields}} (include authentication warning){{/if}}
3. Confidence score (0-1) for the quality of generated data

Return the response in the exact JSON format specified.`,
    variables: ["toolName", "toolDescription", "method", "url", "serverName", "parameterDetails", "hasAuthFields"],
    category: "tool",
    version: "1.0.0",
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  });
  prompts.set("handlebars-template-generation", {
    id: "handlebars-template-generation",
    name: "Handlebars Template Generation",
    description: "Generate agent-optimized Handlebars response templates",
    content: `You are an expert in Handlebars templating for AI agent response formatting. Your task is to create an agent-optimized response template for the following API tool.

**CRITICAL WARNING**: You MUST NOT use any custom Handlebars helpers like (eq), (gt), (lt), (ne), etc. These will cause template errors. Only use built-in helpers like {{#if}}, {{#each}}, and {{json}}.

# Tool Context:
- **Name**: {{toolName}}
- **Description**: {{toolDescription}}
- **Method**: {{method}}
- **URL**: {{url}}
- **Parameters**: {{parameters}}
- **Expected Responses**: {{responses}}

# Key Requirements:
1. **FOR AGENTS, NOT HUMANS**: The response must be structured for AI agent consumption
2. **ACTIONABLE DATA**: Focus on data that agents can use for decision-making
3. **CONSISTENT STRUCTURE**: Use consistent formatting for similar data types
4. **MINIMAL PROSE**: Avoid human-friendly explanations, use structured data
5. **ERROR HANDLING**: Handle missing/null values gracefully

# Handlebars Expertise:
You have access to these variables:
- \`{{response.data.body}}\` - The API response body
- \`{{response.data.headers}}\` - Response headers
- \`{{request.data.parameters}}\` - Request parameters
- \`{{request.data.payload}}\` - Request payload

# Handlebars Helpers (Built-in Only):
- \`{{#each array}}\` - Loop through arrays
- \`{{#if condition}}\` - Conditional rendering (only checks truthy/falsy)
- \`{{@key}}\` - Current key in each loop
- \`{{this}}\` - Current value in each loop
- \`{{json object}}\` - JSON stringify an object

**CRITICAL**: NEVER use \`eq\`, \`gt\`, \`lt\`, \`ne\`, or any custom helpers. They will cause errors.
**ONLY** use \`{{#if}}\` to check if values exist (truthy/falsy), NOT for comparisons.
**BOOLEAN WARNING**: \`{{#if field}}\` treats \`false\` as falsy! For boolean fields, use direct output: \`{{field}}\`

# Agent-Focused Template Examples:

## Example 1: Simple Response
\`\`\`
{{#if response.data.body}}
RESPONSE: {{response.data.body}}
STATUS: SUCCESS
{{else}}
STATUS: NO_RESPONSE
{{/if}}
\`\`\`

## Example 2: Object Response with Boolean
\`\`\`
{{#if response.data.body}}
{{#if response.data.body.id}}
ID: {{response.data.body.id}}
{{/if}}
{{#if response.data.body.name}}
NAME: {{response.data.body.name}}
{{/if}}
ACTIVE: {{response.data.body.active}}
COMPLETED: {{response.data.body.completed}}
{{else}}
STATUS: NO_DATA
{{/if}}
\`\`\`

## Example 3: Array Response
\`\`\`
{{#if response.data.body}}
{{#each response.data.body}}
ITEM_{{@index}}:
{{#if this.id}}
- ID: {{this.id}}
{{/if}}
{{#if this.name}}
- NAME: {{this.name}}
{{/if}}
{{/each}}
{{else}}
STATUS: NO_ITEMS
{{/if}}
\`\`\`

# Your Task:
Analyze the tool context and create a response template that:
1. Extracts the most relevant data fields for agent decision-making
2. Uses consistent field naming (UPPERCASE labels)
3. Handles arrays and objects appropriately
4. Provides fallbacks for missing data
5. Maintains a structured, parseable format

**CRITICAL CONSTRAINTS**:
- NEVER use (eq), (gt), (lt), (ne), or any custom helpers - they will break the template
- Use ONLY {{#if}}, {{#each}}, {{json}}, {{@key}}, {{this}}, {{@index}}
- For string comparisons, do NOT compare - just check if the field exists
- Structure conditions using nested \`{{#if}}\` blocks
- Always provide fallback values for missing data
- Keep templates simple and direct
- **BOOLEAN FIELDS**: Use direct output \`{{field}}\` not \`{{#if field}}\` (false is falsy!)

**FORBIDDEN**: Do NOT use any parentheses with helpers like (eq response.data.body "text")
**ALLOWED**: Only use {{#if response.data.body}} to check existence
**BOOLEAN HANDLING**: Use \`COMPLETED: {{response.data.body.completed}}\` not \`{{#if response.data.body.completed}}\`

Return ONLY the Handlebars template code, no explanations.`,
    variables: ["toolName", "toolDescription", "method", "url", "parameters", "responses"],
    category: "template",
    version: "1.0.0",
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  });
}
var PromptService = {
  /**
   * Get a prompt template by ID
   */
  getPrompt(id) {
    return prompts.get(id) || null;
  },
  /**
   * Get all prompts
   */
  getAllPrompts() {
    return Array.from(prompts.values());
  },
  /**
   * Get prompts by category
   */
  getPromptsByCategory(category) {
    return Array.from(prompts.values()).filter((prompt) => prompt.category === category);
  },
  /**
   * Render a prompt with variables
   */
  renderPrompt(id, variables = {}) {
    const prompt = this.getPrompt(id);
    if (!prompt)
      return null;
    let content = prompt.content;
    for (const [key, value] of Object.entries(variables)) {
      const pattern = new RegExp(`{{${key}}}`, "g");
      content = content.replace(pattern, String(value));
    }
    content = content.replace(
      /{{#if\s+(\w+)}}([\s\S]*?)(?:{{else}}([\s\S]*?))?{{\/if}}/g,
      (match, variable, ifContent, elseContent = "") => {
        const value = variables[variable];
        return value ? ifContent : elseContent;
      }
    );
    return content;
  },
  /**
   * Add or update a prompt template
   */
  setPrompt(prompt) {
    prompts.set(prompt.id, {
      ...prompt,
      updatedAt: /* @__PURE__ */ new Date()
    });
  },
  /**
   * Delete a prompt template
   */
  deletePrompt(id) {
    return prompts.delete(id);
  },
  /**
   * Check if a prompt exists
   */
  hasPrompt(id) {
    return prompts.has(id);
  },
  /**
   * Get prompt variables
   */
  getPromptVariables(id) {
    const prompt = this.getPrompt(id);
    return prompt ? prompt.variables : [];
  }
};

// src/services/ai.service.ts
var AI_MODELS = {
  openai: {
    chat: "gpt-4o",
    completion: "gpt-4o",
    advanced: "o1-mini"
    // Use o1-mini for reasoning support
  },
  anthropic: {
    chat: "claude-3-5-sonnet-20241022",
    completion: "claude-3-haiku-20240307",
    advanced: "claude-3-opus-20240229"
  }
};
function getAIModel(provider = "openai", modelType = "chat") {
  const providerModels = AI_MODELS[provider];
  const modelName = providerModels[modelType] || providerModels.chat;
  switch (provider) {
    case "anthropic":
      return (0, import_anthropic.anthropic)(modelName);
    case "openai":
    default:
      return import_openai.openai.responses(modelName);
  }
}
function getAPIKey(provider) {
  const keys = {
    openai: process.env.OPENAI_API_KEY,
    anthropic: process.env.ANTHROPIC_API_KEY
  };
  const key = keys[provider];
  if (!key) {
    throw new Error(`API key not configured for provider: ${provider}`);
  }
  const placeholders = {
    openai: ["sk-your-openai-api-key", "your-openai-api-key", "sk-proj-your-key-here"],
    anthropic: ["sk-ant-your-anthropic-api-key", "your-anthropic-api-key"]
  };
  if (placeholders[provider].includes(key)) {
    throw new Error(`Please replace the placeholder API key for ${provider} with your actual API key`);
  }
  if (provider === "openai" && !key.startsWith("sk-")) {
    throw new Error(`OpenAI API key should start with 'sk-'`);
  }
  if (provider === "anthropic" && !key.startsWith("sk-ant-")) {
    throw new Error(`Anthropic API key should start with 'sk-ant-'`);
  }
  return key;
}
async function streamChat(prisma2, request) {
  const { messages, config: config2 = {}, tenantId, userId } = request;
  const { provider = "openai", ...modelConfig } = config2;
  const lastMessage = messages[messages.length - 1];
  const lastMessageContent = typeof lastMessage?.content === "string" ? lastMessage.content.substring(0, 100) + "..." : Array.isArray(lastMessage?.content) ? `[${lastMessage.content.length} parts]` : "Unknown format";
  console.log(`\u{1F916} AI Chat Request:`, {
    provider,
    tenantId,
    userId,
    messageCount: messages.length,
    lastMessage: lastMessageContent,
    config: modelConfig
  });
  const apiKey = getAPIKey(provider);
  console.log(`\u{1F511} API Key validation: ${provider} key ${apiKey ? "present" : "missing"}`);
  const model = getAIModel(provider, "chat");
  console.log(`\u{1F3AF} Using model: ${provider} with model type "chat"`);
  const coreMessages = messages;
  console.log(`\u{1F4AC} Processing ${coreMessages.length} messages`);
  const streamConfig = {
    model,
    messages: coreMessages,
    temperature: modelConfig.temperature ?? 0.7,
    maxOutputTokens: modelConfig.maxTokens,
    topP: modelConfig.topP,
    system: "You are a helpful AI assistant integrated into the AgentBridge platform."
  };
  console.log(`\u2699\uFE0F Stream config:`, {
    modelName: model,
    temperature: streamConfig.temperature,
    maxOutputTokens: streamConfig.maxOutputTokens,
    topP: streamConfig.topP
  });
  try {
    console.log(`\u{1F504} Calling streamText with ${provider}...`);
    const streamPromise = (0, import_ai.streamText)(streamConfig);
    const timeoutPromise = new Promise((resolve, reject) => {
      setTimeout(() => reject(new Error("StreamText call timed out after 30 seconds")), 3e4);
    });
    const result = await Promise.race([streamPromise, timeoutPromise]);
    console.log(`\u2705 Stream created successfully`);
    console.log(`\u{1F50D} Stream result properties:`, {
      hasTextStream: !!result.textStream,
      hasFullStream: !!result.fullStream,
      hasToTextStreamResponse: typeof result.toTextStreamResponse === "function"
    });
    try {
      const textStreamResponse = result.toTextStreamResponse();
      console.log(`\u{1F50D} Text stream response created, status: ${textStreamResponse.status}`);
    } catch (streamError) {
      console.error(`\u274C Error creating text stream response:`, streamError);
    }
    return result;
  } catch (error) {
    console.error(`\u274C Stream creation failed:`, error);
    if (error instanceof Error) {
      console.error(`\u{1F50D} Error details:`);
      console.error(`  Message: ${error.message}`);
      console.error(`  Name: ${error.name}`);
      console.error(`  Stack: ${error.stack}`);
    }
    console.error(`\u{1F50D} Full error object:`, JSON.stringify(error, null, 2));
    if (error && typeof error === "object") {
      const errorObj = error;
      const statusCode = errorObj.status || errorObj.statusCode || errorObj.code;
      const message = errorObj.message || errorObj.error?.message || String(error);
      console.error(`\u{1F50D} Extracted status: ${statusCode}, message: ${message}`);
      if (statusCode === 429 || message.includes("429") || message.includes("quota") || message.includes("exceeded")) {
        const quotaError = `\u274C QUOTA EXCEEDED: You've exceeded your OpenAI quota. Please check your billing at https://platform.openai.com/account/billing`;
        console.error(quotaError);
        throw new Error(quotaError);
      }
      if (statusCode === 401 || message.includes("401") || message.includes("Unauthorized")) {
        const authError = `\u274C INVALID API KEY: Please check your OpenAI API key`;
        console.error(authError);
        throw new Error(authError);
      }
      if (message.includes("rate limit")) {
        const rateLimitError = `\u274C RATE LIMIT: Too many requests to ${provider}. Please try again later.`;
        console.error(rateLimitError);
        throw new Error(rateLimitError);
      }
    }
    throw error;
  }
}
async function generateCompletion(prisma2, request) {
  const { prompt, config: config2 = {} } = request;
  const { tenantId, userId } = request;
  const { provider = "openai", ...modelConfig } = config2;
  getAPIKey(provider);
  const model = getAIModel(provider, "completion");
  const result = await (0, import_ai.generateText)({
    model,
    prompt,
    temperature: modelConfig.temperature ?? 0.7,
    maxOutputTokens: modelConfig.maxTokens,
    topP: modelConfig.topP
  });
  return result;
}
async function streamCompletion(prisma2, request) {
  const { prompt, config: config2 = {}, enableReasoning = false } = request;
  const { tenantId, userId } = request;
  const { provider = "openai", ...modelConfig } = config2;
  getAPIKey(provider);
  const model = getAIModel(provider, enableReasoning ? "advanced" : "completion");
  const result = (0, import_ai.streamText)({
    model,
    prompt,
    temperature: modelConfig.temperature ?? 0.7,
    maxOutputTokens: modelConfig.maxTokens,
    topP: modelConfig.topP
  });
  return result;
}
async function generateStructuredObject(prisma2, request) {
  const { prompt, schema, config: config2 = {} } = request;
  const { provider = "openai", ...modelConfig } = config2;
  getAPIKey(provider);
  const model = getAIModel(provider, "chat");
  const result = await (0, import_ai.generateObject)({
    model,
    output: "object",
    // Explicitly specify output mode
    schema,
    prompt,
    temperature: modelConfig.temperature ?? 0.7,
    maxOutputTokens: modelConfig.maxTokens ?? 4096,
    // Ensure enough tokens for complex responses
    topP: modelConfig.topP,
    maxRetries: 2
    // Retry on failures
  });
  return result;
}
function getAvailableModels(provider) {
  return AI_MODELS[provider] || {};
}
function isProviderConfigured(provider) {
  try {
    getAPIKey(provider);
    return true;
  } catch {
    return false;
  }
}
function getConfiguredProviders() {
  const providers = ["openai", "anthropic"];
  return providers.filter(isProviderConfigured);
}
async function streamAIAgentChat(prisma2, request) {
  console.log("\u{1F4E5} [AI SERVICE] streamAIAgentChat called with request:", {
    hasServerId: !!request.serverId,
    serverId: request.serverId,
    prompt: request.prompt?.substring(0, 50) + "...",
    tenantId: request.tenantId,
    hasPrisma: !!prisma2,
    prismaType: typeof prisma2
  });
  const { conversationHistory = "", hasShownDesign = false, serverId, ...baseRequest } = request;
  const { config: config2 = {}, tenantId } = baseRequest;
  const { userId } = baseRequest;
  const { provider = "openai", ...modelConfig } = config2;
  const systemPrompt = PromptService.renderPrompt("ai-agent-system", {
    conversationHistory,
    hasShownDesign: hasShownDesign ? "Note: You've already shown a tool design in this conversation. Check if the user is responding to it." : ""
  });
  if (!systemPrompt) {
    throw new Error("AI Agent system prompt not found");
  }
  getAPIKey(provider);
  const model = getAIModel(provider, "chat");
  const db = prisma2;
  const tools = {
    // Web search tool - always available
    web_search_preview: import_openai.openai.tools.webSearchPreview({
      searchContextSize: "high",
      userLocation: {
        type: "approximate",
        city: "San Francisco",
        region: "California"
      }
    }),
    // MCP tool creation - only if serverId is provided
    ...serverId ? {
      createMCPTool: (0, import_ai.tool)({
        description: "Create an MCP tool with the provided specification. Only call this when the user has explicitly confirmed they want to create the tool.",
        inputSchema: import_zod.z.object({
          tool: import_zod.z.object({
            name: import_zod.z.string().describe("The name of the tool"),
            description: import_zod.z.string().describe("Clear description of what this tool does"),
            method: import_zod.z.enum(["GET", "POST", "PUT", "DELETE", "PATCH"]).describe("HTTP method"),
            url: import_zod.z.string().describe("The API endpoint URL"),
            parameters: import_zod.z.object({}).passthrough().default({}).describe("Parameter definitions object"),
            requestParameterOverrides: import_zod.z.object({}).passthrough().optional().describe("Direct HTTP request overrides (for GraphQL)"),
            responses: import_zod.z.object({}).passthrough().default({}).optional().describe("Response definitions object")
          }),
          auth: import_zod.z.object({
            type: import_zod.z.enum(["oauth", "apikey", "none"]).describe("Authentication type"),
            oauth: import_zod.z.object({
              name: import_zod.z.string().describe("OAuth provider name"),
              authorizationUrl: import_zod.z.string().describe("OAuth authorization URL"),
              tokenUrl: import_zod.z.string().describe("OAuth token URL"),
              scopes: import_zod.z.array(import_zod.z.string()).describe("Required OAuth scopes"),
              clientId: import_zod.z.string().optional().describe("OAuth client ID"),
              clientSecret: import_zod.z.string().optional().describe("OAuth client secret")
            }).optional(),
            apikey: import_zod.z.object({
              name: import_zod.z.string().describe("API key provider name"),
              keyName: import_zod.z.string().describe("Header or query parameter name for the API key"),
              keyIn: import_zod.z.enum(["header", "query", "path", "body"]).describe("Where to send the API key")
            }).optional()
          }).optional(),
          service: import_zod.z.string().describe("The service name (e.g., 'github', 'slack')")
        }),
        execute: async ({ tool: tool2, auth, service }) => {
          console.log("\u{1F680} [TOOL EXECUTION START] Creating MCP tool in backend");
          console.log("\u{1F4CB} Tool Details:", JSON.stringify({ serverId, tenantId, tool: tool2, auth, service }, null, 2));
          console.log("\u{1F50D} [DEBUG] Checking db availability:", !!db, typeof db);
          console.log("\u{1F50D} [DEBUG] Checking tenantId:", tenantId);
          console.log("\u{1F50D} [DEBUG] Checking serverId:", serverId);
          try {
            console.log("\u{1F4E6} Importing required modules...");
            const { createTool: createTool3 } = await Promise.resolve().then(() => (init_servers_service(), servers_service_exports));
            const { generateRequestOverrides: generateRequestOverrides2 } = await Promise.resolve().then(() => (init_generateRequestOverrides(), generateRequestOverrides_exports));
            console.log("\u2705 Modules imported successfully");
            let oAuthProviderId;
            let apiKeyProviderId;
            if (auth && auth.type !== "none") {
              console.log("\u{1F510} Creating authentication provider...", auth.type);
              if (auth.type === "oauth" && auth.oauth) {
                console.log("\u{1F511} Creating OAuth provider:", auth.oauth.name);
                const oauthProvider = await db.oAuthProvider.create({
                  data: {
                    name: auth.oauth.name,
                    clientId: auth.oauth.clientId || "",
                    clientSecret: auth.oauth.clientSecret || "",
                    authorizationUrl: auth.oauth.authorizationUrl,
                    tokenUrl: auth.oauth.tokenUrl,
                    scopes: auth.oauth.scopes || [],
                    tenantId
                  }
                });
                oAuthProviderId = oauthProvider.id;
                console.log("\u2705 OAuth provider created with ID:", oAuthProviderId);
              } else if (auth.type === "apikey" && auth.apikey) {
                console.log("\u{1F511} API Key provider configured:", auth.apikey.name, "for", auth.apikey.keyIn);
                console.log(
                  "\u2705 API Key will be handled automatically during execution - not added to tool parameters"
                );
              }
            } else {
              console.log("\u{1F510} No authentication provider specified or auth type is 'none'");
            }
            let requestParameterOverrides;
            if (tool2.requestParameterOverrides) {
              console.log(
                "\u{1F4DD} Using provided request parameter overrides:",
                JSON.stringify(tool2.requestParameterOverrides, null, 2)
              );
              requestParameterOverrides = tool2.requestParameterOverrides;
            } else {
              console.log("\u{1F527} Generating request parameter overrides...");
              const httpOverrides = generateRequestOverrides2(tool2.parameters || {});
              console.log("\u{1F4DD} Generated HTTP overrides:", JSON.stringify(httpOverrides, null, 2));
              requestParameterOverrides = httpOverrides;
            }
            if (auth && auth.type === "apikey" && auth.apikey) {
              const template = `{{${auth.apikey.keyName}}}`;
              const isHttpFormat = "headers" in requestParameterOverrides || "query" in requestParameterOverrides;
              if (isHttpFormat) {
                const httpOverrides = requestParameterOverrides;
                switch (auth.apikey.keyIn) {
                  case "header":
                    if (!httpOverrides.headers) {
                      httpOverrides.headers = {};
                    }
                    httpOverrides.headers[auth.apikey.keyName] = template;
                    break;
                  case "query":
                    if (!httpOverrides.query) {
                      httpOverrides.query = {};
                    }
                    httpOverrides.query[auth.apikey.keyName] = template;
                    break;
                }
                requestParameterOverrides = httpOverrides;
              }
              console.log("\u{1F511} Added API key to request overrides:", auth.apikey.keyName, "in", auth.apikey.keyIn);
            }
            console.log(
              "\u{1F4DD} Final request parameter overrides:",
              JSON.stringify(requestParameterOverrides, null, 2)
            );
            const convertedParameters = {};
            if (tool2.parameters) {
              for (const [key, param] of Object.entries(tool2.parameters)) {
                convertedParameters[key] = param;
              }
            }
            const toolData = {
              name: tool2.name,
              description: tool2.description,
              method: tool2.method,
              url: tool2.url,
              parameters: convertedParameters,
              requestParameterOverrides,
              // Type assertion needed for now
              oAuthProviderId,
              // Only set for OAuth
              apiKeyProviderId: void 0
              // API keys are now embedded in parameters
            };
            console.log("\u{1F528} Calling createTool with data:", JSON.stringify(toolData, null, 2));
            console.log("\u{1F511} Parameters: db=", !!db, typeof db, "serverId=", serverId, "tenantId=", tenantId);
            if (!db) {
              throw new Error("Prisma client is not available in tool execution context");
            }
            const createdTool = await createTool3(db, serverId, tenantId, toolData);
            console.log("\u2705 Tool created successfully!");
            console.log("\u{1F194} Created tool:", JSON.stringify(createdTool, null, 2));
            let successMessage = `Successfully created tool "${tool2.name}"!`;
            if (oAuthProviderId) {
              successMessage += ` OAuth authentication provider has been configured.`;
            } else if (auth && auth.type === "apikey") {
              successMessage += ` API Key parameter has been added to the tool.`;
            }
            successMessage += ` The tool is now available in your workflow canvas.`;
            return {
              success: true,
              message: successMessage,
              toolId: createdTool.id,
              toolName: createdTool.name,
              authProviderId: oAuthProviderId,
              authProviderType: oAuthProviderId ? "oauth" : auth?.type === "apikey" ? "apikey" : void 0
            };
          } catch (error) {
            console.error("\u274C [TOOL CREATION ERROR] Failed to create tool in backend");
            console.error("\u{1F50D} Error details:", error);
            console.error("\u{1F4CA} Stack trace:", error instanceof Error ? error.stack : "No stack trace");
            if (error instanceof Error) {
              console.error("\u{1F4CC} Error name:", error.name);
              console.error("\u{1F4CC} Error message:", error.message);
            }
            return {
              success: false,
              message: `Failed to create tool: ${error instanceof Error ? error.message : "Unknown error"}`,
              error: error instanceof Error ? error.message : "Unknown error"
            };
          }
        }
      })
    } : {}
  };
  const contextSection = conversationHistory ? `

Previous conversation:
${conversationHistory}

` : "";
  const fullPrompt = `${systemPrompt}${contextSection}Current user message: ${baseRequest.prompt}`;
  const streamConfig = {
    model,
    prompt: fullPrompt,
    temperature: modelConfig.temperature ?? 0.7,
    maxOutputTokens: modelConfig.maxTokens,
    topP: modelConfig.topP,
    onError: (error) => {
      console.error("Stream error in AI service:", error);
    }
  };
  console.log("\u{1F6E0}\uFE0F [AI SERVICE] Tools are defined, adding to stream config");
  console.log("\u{1F527} [AI SERVICE] Available tools:", Object.keys(tools));
  streamConfig.tools = tools;
  streamConfig.toolChoice = "auto";
  console.log("\u{1F680} [AI SERVICE] Starting streamText with config:", {
    model: streamConfig.model,
    hasTools: !!streamConfig.tools,
    toolChoice: streamConfig.toolChoice,
    temperature: streamConfig.temperature
  });
  return (0, import_ai.streamText)(streamConfig);
}
async function generateHandlebarsTemplate(prisma2, toolContext, config2) {
  const templatePrompt = PromptService.renderPrompt("handlebars-template-generation", toolContext);
  if (!templatePrompt) {
    throw new Error("Handlebars template generation prompt not found");
  }
  return generateCompletion(prisma2, {
    prompt: templatePrompt,
    config: config2 || { temperature: 0.3, maxTokens: 1e3 },
    tenantId: "system",
    // Internal system operation
    userId: "system"
  });
}

// src/controllers/ai.controller.ts
function convertJsonSchemaToZod(jsonSchema) {
  if (!jsonSchema || typeof jsonSchema !== "object") {
    throw new Error("Invalid JSON schema provided");
  }
  if (jsonSchema.type === "object" && jsonSchema.properties) {
    const zodProperties = {};
    for (const [key, prop] of Object.entries(jsonSchema.properties)) {
      zodProperties[key] = convertPropertyToZod(prop);
    }
    let objectSchema = import_zod2.z.object(zodProperties);
    if (Array.isArray(jsonSchema.required)) {
      const requiredFields = new Set(jsonSchema.required);
      const partialFields = {};
      for (const [key, zodType] of Object.entries(zodProperties)) {
        if (!requiredFields.has(key)) {
          partialFields[key] = zodType.optional();
        } else {
          partialFields[key] = zodType;
        }
      }
      objectSchema = import_zod2.z.object(partialFields);
    }
    return objectSchema;
  }
  throw new Error("Unsupported schema type - only object schemas are supported");
}
function convertPropertyToZod(prop) {
  if (!prop || typeof prop !== "object") {
    return import_zod2.z.string();
  }
  switch (prop.type) {
    case "string":
      let stringSchema = import_zod2.z.string();
      if (prop.minLength)
        stringSchema = stringSchema.min(prop.minLength);
      if (prop.maxLength)
        stringSchema = stringSchema.max(prop.maxLength);
      return stringSchema;
    case "number":
      let numberSchema = import_zod2.z.number();
      if (prop.minimum !== void 0)
        numberSchema = numberSchema.min(prop.minimum);
      if (prop.maximum !== void 0)
        numberSchema = numberSchema.max(prop.maximum);
      return numberSchema;
    case "integer":
      let intSchema = import_zod2.z.number().int();
      if (prop.minimum !== void 0)
        intSchema = intSchema.min(prop.minimum);
      if (prop.maximum !== void 0)
        intSchema = intSchema.max(prop.maximum);
      return intSchema;
    case "boolean":
      return import_zod2.z.boolean();
    case "array":
      const itemSchema = prop.items ? convertPropertyToZod(prop.items) : import_zod2.z.any();
      return import_zod2.z.array(itemSchema);
    case "object":
      if (prop.properties) {
        const nestedProps = {};
        for (const [key, nestedProp] of Object.entries(prop.properties)) {
          nestedProps[key] = convertPropertyToZod(nestedProp);
        }
        return import_zod2.z.object(nestedProps);
      }
      return import_zod2.z.record(import_zod2.z.unknown());
    default:
      return import_zod2.z.unknown();
  }
}
var chatRequestSchema = import_zod2.z.object({
  messages: import_zod2.z.array(
    import_zod2.z.object({
      id: import_zod2.z.string(),
      role: import_zod2.z.enum(["user", "assistant", "system"]),
      content: import_zod2.z.string()
    })
  ),
  config: import_zod2.z.object({
    provider: import_zod2.z.enum(["openai", "anthropic"]).optional(),
    model: import_zod2.z.string().optional(),
    temperature: import_zod2.z.number().min(0).max(2).optional(),
    maxTokens: import_zod2.z.number().positive().optional(),
    topP: import_zod2.z.number().min(0).max(1).optional()
  }).optional()
});
var completionRequestSchema = import_zod2.z.object({
  prompt: import_zod2.z.string().min(1),
  config: import_zod2.z.object({
    provider: import_zod2.z.enum(["openai", "anthropic"]).optional(),
    model: import_zod2.z.string().optional(),
    temperature: import_zod2.z.number().min(0).max(2).optional(),
    maxTokens: import_zod2.z.number().positive().optional(),
    topP: import_zod2.z.number().min(0).max(1).optional()
  }).optional(),
  enableWebSearch: import_zod2.z.boolean().optional()
});
var streamCompletionRequestSchema = completionRequestSchema.extend({
  enableReasoning: import_zod2.z.boolean().optional()
});
var agentChatRequestSchema = completionRequestSchema.extend({
  conversationHistory: import_zod2.z.string().optional(),
  hasShownDesign: import_zod2.z.boolean().optional(),
  serverId: import_zod2.z.string().optional()
});
var templateRequestSchema = import_zod2.z.object({
  tool: import_zod2.z.object({
    name: import_zod2.z.string(),
    description: import_zod2.z.string(),
    method: import_zod2.z.string(),
    url: import_zod2.z.string(),
    parameters: import_zod2.z.record(import_zod2.z.unknown()).optional().nullable(),
    requestParameterOverrides: import_zod2.z.record(import_zod2.z.unknown()).optional().nullable(),
    responses: import_zod2.z.record(import_zod2.z.unknown()).optional().nullable()
  }),
  config: import_zod2.z.object({
    provider: import_zod2.z.enum(["openai", "anthropic"]).optional(),
    model: import_zod2.z.string().optional(),
    temperature: import_zod2.z.number().min(0).max(2).optional(),
    maxTokens: import_zod2.z.number().positive().optional(),
    topP: import_zod2.z.number().min(0).max(1).optional()
  }).optional()
});
async function chatStream(req, res) {
  try {
    const body = chatRequestSchema.parse(req.body);
    const authReq = req;
    const admin = authReq.admin;
    const user = authReq.user;
    const tenantId = admin?.tenantId || user?.tenantId;
    const userId = admin?.id || user?.id;
    if (!tenantId) {
      return res.status(400).json({ error: "Tenant ID is required" });
    }
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("X-Accel-Buffering", "no");
    console.log(`\u{1F680} Starting chat stream for tenant: ${tenantId}, user: ${userId}`);
    console.log(`\u{1F4DD} Request body:`, {
      messageCount: body.messages.length,
      config: body.config,
      firstMessage: body.messages[0]?.content.substring(0, 100) + "..."
    });
    const result = await streamChat(req.db, {
      messages: body.messages,
      config: body.config,
      tenantId,
      userId
    });
    console.log(`\u{1F4E1} Stream result created, converting to text stream response`);
    const response = result.toTextStreamResponse();
    console.log(`\u{1F4E1} Stream response headers:`, Object.fromEntries(response.headers.entries()));
    console.log(`\u{1F4E4} Starting to stream response to client`);
    if (response.body) {
      const reader = response.body.getReader();
      let chunkCount = 0;
      let totalBytes = 0;
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            console.log(`\u{1F3C1} Stream finished after ${chunkCount} chunks, ${totalBytes} total bytes`);
            break;
          }
          chunkCount++;
          totalBytes += value.length;
          const chunk = new TextDecoder().decode(value);
          console.log(`\u{1F4E6} Chunk ${chunkCount}: ${value.length} bytes`);
          console.log(`\u{1F4DD} Chunk content (first 200 chars): ${chunk.substring(0, 200)}...`);
          res.write(value);
        }
      } finally {
        reader.releaseLock();
      }
    } else {
      console.log(`\u274C No response body from stream`);
    }
    console.log(`\u2705 Stream completed successfully`);
    res.end();
  } catch (error) {
    console.error("Chat stream error:", error);
    if (!res.headersSent) {
      res.status(500).json({
        error: "Failed to process chat request",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    } else {
      res.write(`data: ${JSON.stringify({ error: "Stream error occurred" })}

`);
      res.end();
    }
  }
}
async function generateCompletionHandler(req, res) {
  try {
    const body = completionRequestSchema.parse(req.body);
    const authReq = req;
    const admin = authReq.admin;
    const user = authReq.user;
    const tenantId = admin?.tenantId || user?.tenantId;
    const userId = admin?.id || user?.id;
    if (!tenantId) {
      return res.status(400).json({ error: "Tenant ID is required" });
    }
    const result = await generateCompletion(req.db, {
      prompt: body.prompt,
      config: body.config,
      tenantId,
      userId,
      enableWebSearch: body.enableWebSearch
    });
    res.json({
      text: result.text,
      usage: result.usage,
      finishReason: result.finishReason
    });
  } catch (error) {
    console.error("Completion error:", error);
    if (error instanceof import_zod2.z.ZodError) {
      return res.status(400).json({
        error: "Invalid request",
        details: error.errors
      });
    }
    res.status(500).json({
      error: "Failed to generate completion",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function streamCompletionHandler(req, res) {
  try {
    const body = streamCompletionRequestSchema.parse(req.body);
    const authReq = req;
    const admin = authReq.admin;
    const user = authReq.user;
    const tenantId = admin?.tenantId || user?.tenantId;
    const userId = admin?.id || user?.id;
    if (!tenantId) {
      return res.status(400).json({ error: "Tenant ID is required" });
    }
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("X-Accel-Buffering", "no");
    console.log(`\u{1F680} Starting completion stream for tenant: ${tenantId}`);
    const result = await streamCompletion(req.db, {
      prompt: body.prompt,
      config: body.config,
      tenantId,
      userId,
      enableWebSearch: body.enableWebSearch,
      enableReasoning: body.enableReasoning
    });
    const response = result.toUIMessageStreamResponse({
      sendReasoning: body.enableReasoning || false,
      headers: {
        "Content-Type": "text/plain; charset=utf-8"
      }
    });
    if (response.body) {
      const reader = response.body.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          res.write(value);
        }
      } finally {
        reader.releaseLock();
      }
    }
    res.end();
  } catch (error) {
    console.error("Stream completion error:", error);
    if (!res.headersSent) {
      res.status(500).json({
        error: "Failed to stream completion",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    } else {
      res.write(`data: ${JSON.stringify({ error: "Stream error occurred" })}

`);
      res.end();
    }
  }
}
async function generateObjectHandler(req, res) {
  try {
    const { prompt, schema: schemaDefinition, config: config2 } = req.body;
    const authReq = req;
    const admin = authReq.admin;
    const user = authReq.user;
    const tenantId = admin?.tenantId || user?.tenantId;
    const userId = admin?.id || user?.id;
    if (!tenantId) {
      return res.status(400).json({ error: "Tenant ID is required" });
    }
    if (!prompt || !schemaDefinition) {
      return res.status(400).json({
        error: "Prompt and schema are required"
      });
    }
    console.log("\u{1F504} Converting JSON schema to Zod:", JSON.stringify(schemaDefinition, null, 2));
    let schema;
    try {
      schema = convertJsonSchemaToZod(schemaDefinition);
      console.log("\u2705 Schema conversion successful");
    } catch (error) {
      console.error("\u274C Schema conversion error:", error);
      return res.status(400).json({
        error: "Invalid schema definition",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
    const result = await generateStructuredObject(req.db, {
      prompt,
      schema,
      config: config2,
      tenantId,
      userId
    });
    res.json({
      object: result.object,
      usage: result.usage,
      finishReason: result.finishReason
    });
  } catch (error) {
    console.error("Generate object error:", error);
    res.status(500).json({
      error: "Failed to generate object",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function streamAIAgentChatHandler(req, res) {
  try {
    const body = agentChatRequestSchema.parse(req.body);
    const authReq = req;
    const admin = authReq.admin;
    const user = authReq.user;
    const tenantId = admin?.tenantId || user?.tenantId;
    const userId = admin?.id || user?.id;
    if (!tenantId) {
      return res.status(400).json({ error: "Tenant ID is required" });
    }
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("X-Accel-Buffering", "no");
    const result = await streamAIAgentChat(req.db, {
      prompt: body.prompt,
      conversationHistory: body.conversationHistory,
      hasShownDesign: body.hasShownDesign,
      serverId: body.serverId,
      config: body.config,
      tenantId,
      userId
    });
    const response = result.toUIMessageStreamResponse();
    if (response.body) {
      const reader = response.body.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          res.write(value);
        }
      } finally {
        reader.releaseLock();
      }
    }
    res.end();
  } catch (error) {
    console.error("AI agent chat stream error:", error);
    console.error("Error details:", {
      name: error instanceof Error ? error.name : "Unknown",
      message: error instanceof Error ? error.message : "Unknown error",
      stack: error instanceof Error ? error.stack : void 0
    });
    if (!res.headersSent) {
      res.status(500).json({
        error: "Failed to process AI agent chat request",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    } else {
      const errorData = JSON.stringify({
        type: "error",
        error: error instanceof Error ? error.message : "Stream error occurred"
      });
      res.write(`${errorData}
`);
      res.end();
    }
  }
}
async function generateTemplateHandler(req, res) {
  try {
    const body = templateRequestSchema.parse(req.body);
    const authReq = req;
    const admin = authReq.admin;
    const user = authReq.user;
    const tenantId = admin?.tenantId || user?.tenantId;
    if (!tenantId) {
      return res.status(400).json({ error: "Tenant ID is required" });
    }
    const { tool: tool2, config: config2 } = body;
    const parametersToUse = tool2.requestParameterOverrides || tool2.parameters || {};
    const toolContext = {
      toolName: tool2.name,
      toolDescription: tool2.description,
      method: tool2.method,
      url: tool2.url,
      parameters: JSON.stringify(parametersToUse, null, 2),
      responses: JSON.stringify(tool2.responses || {}, null, 2)
    };
    const result = await generateHandlebarsTemplate(req.db, toolContext, config2);
    let template = result.text.trim();
    if (template.startsWith("```") && template.endsWith("```")) {
      const lines = template.split("\n");
      if (lines.length > 2) {
        template = lines.slice(1, -1).join("\n");
      }
    }
    res.json({
      template,
      usage: result.usage,
      finishReason: result.finishReason
    });
  } catch (error) {
    console.error("Template generation error:", error);
    if (error instanceof import_zod2.z.ZodError) {
      return res.status(400).json({
        error: "Invalid request",
        details: error.errors
      });
    }
    res.status(500).json({
      error: "Failed to generate template",
      message: error instanceof Error ? error.message : "Unknown error"
    });
  }
}
async function getAIConfig(req, res) {
  try {
    const providers = getConfiguredProviders();
    const config2 = {
      providers: providers.map((provider) => ({
        id: provider,
        name: provider.charAt(0).toUpperCase() + provider.slice(1),
        models: getAvailableModels(provider),
        configured: true
      })),
      defaultProvider: providers[0] || null
    };
    res.json(config2);
  } catch (error) {
    console.error("Get AI config error:", error);
    res.status(500).json({
      error: "Failed to get AI configuration"
    });
  }
}

// src/middlewares/rate-limit.middleware.ts
var requestCounts = /* @__PURE__ */ new Map();
function rateLimitMiddleware(options) {
  const { windowMs, max, message = "Too many requests, please try again later" } = options;
  return (req, res, next) => {
    const authReq = req;
    const admin = authReq.admin;
    const user = authReq.user;
    const tenantId = admin?.tenantId || user?.tenantId;
    const userId = admin?.id || user?.id;
    const clientIp = req.ip || req.socket.remoteAddress || "unknown";
    const key = `${tenantId || "no-tenant"}_${userId || clientIp}`;
    const now = Date.now();
    let rateLimit = requestCounts.get(key);
    if (!rateLimit || rateLimit.resetTime < now) {
      rateLimit = { count: 0, resetTime: now + windowMs };
      requestCounts.set(key, rateLimit);
    }
    rateLimit.count++;
    if (rateLimit.count > max) {
      res.status(429).json({
        error: "Rate limit exceeded",
        message,
        retryAfter: Math.ceil((rateLimit.resetTime - now) / 1e3)
      });
      return;
    }
    res.setHeader("X-RateLimit-Limit", max.toString());
    res.setHeader("X-RateLimit-Remaining", (max - rateLimit.count).toString());
    res.setHeader("X-RateLimit-Reset", new Date(rateLimit.resetTime).toISOString());
    next();
  };
}
setInterval(
  () => {
    const now = Date.now();
    for (const [key, data] of requestCounts.entries()) {
      if (data.resetTime < now) {
        requestCounts.delete(key);
      }
    }
  },
  5 * 60 * 1e3
);

// src/routes/ai.routes.ts
var router2 = (0, import_express2.Router)();
router2.use(adminSessionMiddleware);
var aiRateLimit = rateLimitMiddleware({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 20,
  // 20 requests per minute
  message: "Too many AI requests, please try again later"
});
router2.post("/chat", aiRateLimit, chatStream);
router2.post("/agent-chat", aiRateLimit, streamAIAgentChatHandler);
router2.post("/completion", aiRateLimit, generateCompletionHandler);
router2.post("/stream-completion", aiRateLimit, streamCompletionHandler);
router2.post("/generate-object", aiRateLimit, generateObjectHandler);
router2.post("/generate-template", aiRateLimit, generateTemplateHandler);
router2.get("/config", getAIConfig);
router2.get("/test", async (req, res) => {
  try {
    console.log("\u{1F9EA} Testing OpenAI connection...");
    const { generateText: generateText2 } = await import("ai");
    const { openai: openai2 } = await import("@ai-sdk/openai");
    const model = openai2("gpt-4o");
    console.log("\u{1F504} Calling generateText with simple test...");
    const result = await generateText2({
      model,
      prompt: "Say hello in one word",
      maxRetries: 1
    });
    console.log("\u2705 Test successful:", result.text);
    res.json({
      success: true,
      response: result.text,
      usage: result.usage
    });
  } catch (error) {
    console.error("\u274C Test failed:", error);
    if (error && typeof error === "object") {
      const errorObj = error;
      const statusCode = errorObj.status || errorObj.statusCode || errorObj.code;
      const message = errorObj.message || errorObj.error?.message || String(error);
      console.error(`\u{1F50D} Test error - Status: ${statusCode}, Message: ${message}`);
      if (statusCode === 429 || message.includes("429") || message.includes("quota") || message.includes("exceeded")) {
        console.error("\u{1F4B3} QUOTA EXCEEDED: You need to add billing/credits to your OpenAI account");
        return res.status(429).json({
          success: false,
          error: "QUOTA_EXCEEDED",
          message: "You've exceeded your OpenAI quota. Please check your billing at https://platform.openai.com/account/billing"
        });
      }
    }
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
var ai_routes_default = router2;

// src/routes/analytics.routes.ts
var import_express3 = require("express");

// src/services/datadog.service.ts
var import_datadog_api_client = require("@datadog/datadog-api-client");
init_config();
init_secrets_service();
var datadogMetricsClient = (async () => {
  const appSecrets2 = await getAppSecrets();
  return new import_datadog_api_client.v2.MetricsApi(
    import_datadog_api_client.client.createConfiguration({
      authMethods: {
        apiKeyAuth: appSecrets2.datadogApiKey,
        appKeyAuth: appSecrets2.datadogAppKey
      }
    })
  );
})();
var queryTimeseriesData = async (formulas, fromMillis, toMillis) => {
  const request = {
    body: {
      data: {
        type: "timeseries_request",
        attributes: {
          from: fromMillis,
          to: toMillis,
          interval: 60 * 60 * 24 * 1e3,
          // 1 day
          formulas: formulas.map(({ metric, aggregator, tagFilters, by }) => ({
            formula: `${aggregator}:${metric}{${isLocalRun ? "*" : Object.entries(tagFilters).map(([k, v]) => `${k}:"${v}"`).join(" AND ")}} ${by ? `by {${by.join(",")}}` : ""}`
          })),
          queries: []
        }
      }
    }
  };
  const res = await (await datadogMetricsClient).queryTimeseriesData(request);
  if (!res.data) {
    throw new Error(`Datadog API request failed: ${JSON.stringify(res)}`);
  }
  return res.data;
};

// src/controllers/analytics.controller.ts
var ONE_DAY_IN_MS = 60 * 60 * 24 * 1e3;
var METRICS = {
  EXECUTION_COUNT: "agentbridge.tool.execution.count",
  EXECUTION_DURATION: "agentbridge.tool.execution.duration"
};
var TAGS = {
  TOOL_ID: "toolid",
  SERVER_ID: "serverid",
  FAILED: "failed"
};
var seriesValue = (timeseriesResponse, seriesIndex, pointIndex) => seriesIndex !== null ? timeseriesResponse.attributes?.values?.[seriesIndex][pointIndex] || 0 : 0;
var aggregateResults = (seriesResponse) => {
  const analytics2 = {
    total: {
      requests: 0,
      successCount: 0,
      failureCount: 0,
      avgResponseTime: 0
    },
    timeSeriesData: []
  };
  let successCountIndex = null, failureCountIndex = null, durationIndex = null;
  seriesResponse.attributes?.series?.forEach((series, index) => {
    const isCounter = series.queryIndex === 0;
    if (isCounter) {
      const isSuccess = series.groupTags?.includes(`${TAGS.FAILED}:false`);
      if (isSuccess) {
        successCountIndex = index;
      } else {
        failureCountIndex = index;
      }
    } else {
      durationIndex = index;
    }
  });
  seriesResponse.attributes?.times?.forEach((ts, index) => {
    const successValue = seriesValue(seriesResponse, successCountIndex, index);
    const failureValue = seriesValue(seriesResponse, failureCountIndex, index);
    const durationValue = seriesValue(seriesResponse, durationIndex, index);
    analytics2.timeSeriesData.push({
      avgResponseTime: durationValue,
      failureCount: failureValue,
      requests: failureValue + successValue,
      successCount: successValue,
      date: new Date(ts).toISOString()
    });
    analytics2.total.requests += successValue + failureValue;
    analytics2.total.successCount += successValue;
    analytics2.total.failureCount += failureValue;
    analytics2.total.avgResponseTime += durationValue * (successValue + failureValue);
  });
  analytics2.total.avgResponseTime = analytics2.total.requests > 0 ? analytics2.total.avgResponseTime / analytics2.total.requests : 0;
  return analytics2;
};
async function fetchMetrics(logger2, serverId, toolId, fromTime, toTime) {
  try {
    const tagFilters = {
      [TAGS.SERVER_ID]: serverId,
      ...toolId ? { [TAGS.TOOL_ID]: toolId } : {}
    };
    const timeSeriesResponse = await queryTimeseriesData(
      [
        {
          metric: METRICS.EXECUTION_COUNT,
          aggregator: "sum",
          tagFilters,
          by: [TAGS.FAILED]
        },
        {
          metric: METRICS.EXECUTION_DURATION,
          aggregator: "avg",
          tagFilters,
          by: null
        }
      ],
      fromTime,
      toTime
    );
    return aggregateResults(timeSeriesResponse);
  } catch (error) {
    logger2.error("Error fetching metrics from Datadog", error);
  }
  return {
    total: {
      requests: 0,
      successCount: 0,
      failureCount: 0,
      avgResponseTime: 0
    },
    timeSeriesData: []
  };
}
var getTimeFrame = (req) => {
  const fromTime = req.query.from ? new Date(req.query.from).getTime() : Date.now() - 30 * ONE_DAY_IN_MS;
  const toTime = req.query.to ? new Date(req.query.to).getTime() : Date.now();
  return { fromTime, toTime };
};
var getServerAnalytics = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting server analytics", {
    serverId: req.params.serverId,
    timeRange: `${req.query.from}-${req.query.to}`
  });
  const { fromTime, toTime } = getTimeFrame(req);
  const analytics2 = await fetchMetrics(req.logger, req.params.serverId, null, fromTime, toTime);
  res.json(analytics2);
};
var getToolAnalytics = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting tool analytics", {
    serverId: req.params.serverId,
    toolId: req.params.toolId,
    timeRange: `${req.query.from}-${req.query.to}`
  });
  const { fromTime, toTime } = getTimeFrame(req);
  const analytics2 = await fetchMetrics(req.logger, req.params.serverId, req.params.toolId, fromTime, toTime);
  res.json(analytics2);
};

// src/routes/analytics.routes.ts
var router3 = (0, import_express3.Router)();
router3.get("/:serverId/analytics", getServerAnalytics);
router3.get("/:serverId/tools/:toolId/analytics", getToolAnalytics);
var analytics_routes_default = router3;

// src/routes/folders.routes.ts
var import_express4 = require("express");

// src/controllers/folders.controller.ts
var import_http_status_codes5 = require("http-status-codes");

// src/services/folders.service.ts
var mapFolder = (folder) => ({
  ...folder,
  parentFolderId: folder.parentFolderId || void 0,
  createdAt: folder.createdAt.toISOString(),
  updatedAt: folder.updatedAt.toISOString()
});
async function listFolders(db, serverId, tenantId) {
  const folders = await db.folder.findMany({
    where: {
      serverId,
      tenantId
    },
    orderBy: [
      {
        name: "asc"
      },
      {
        id: "asc"
      }
    ]
  });
  return folders.map(mapFolder);
}
async function createFolder(db, serverId, tenantId, name, parentFolderId) {
  const folder = await db.folder.create({
    data: {
      name,
      parentFolderId,
      tenantId,
      serverId
    }
  });
  return mapFolder(folder);
}
async function updateFolder(db, folderId, serverId, tenantId, name) {
  const folder = await db.folder.update({
    where: {
      id: folderId,
      serverId,
      tenantId
    },
    data: {
      name
    }
  });
  return mapFolder(folder);
}
async function deleteFolder(db, folderId, serverId, tenantId) {
  await db.folder.delete({
    where: {
      id: folderId,
      serverId,
      tenantId
    }
  });
}

// src/controllers/folders.controller.ts
var listFolders2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Listing folders", { serverId: req.params.serverId, tenantId: req.admin.tenantId });
  try {
    const folders = await listFolders(req.db, req.params.serverId, req.admin.tenantId);
    res.json(folders);
  } catch (error) {
    req.logger.error("Failed to list folders", error);
    res.status(import_http_status_codes5.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to list folders"
    });
  }
};
var createFolder2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Creating folder", { serverId: req.params.serverId, body: req.body });
  try {
    if (!req.admin.tenantId) {
      return res.status(import_http_status_codes5.StatusCodes.UNAUTHORIZED).json({
        error: "unauthorized",
        errorDescription: "Tenant ID is required"
      });
    }
    const folder = await createFolder(
      req.db,
      req.params.serverId,
      req.admin.tenantId,
      req.body.name,
      req.body.parentFolderId
    );
    res.status(import_http_status_codes5.StatusCodes.CREATED).json(folder);
  } catch (error) {
    req.logger.error("Failed to create folder", error);
    res.status(import_http_status_codes5.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to create folder"
    });
  }
};
var updateFolder2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Updating folder", {
    serverId: req.params.serverId,
    folderId: req.params.folderId,
    body: req.body,
    tenantId: req.admin.tenantId
  });
  try {
    const folder = await updateFolder(
      req.db,
      req.params.folderId,
      req.params.serverId,
      req.admin.tenantId,
      req.body.name
    );
    res.json(folder);
  } catch (error) {
    req.logger.error("Failed to update folder", error);
    res.status(import_http_status_codes5.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to update folder"
    });
  }
};
var deleteFolder2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Deleting folder", { serverId: req.params.serverId, folderId: req.params.folderId });
  try {
    await deleteFolder(req.db, req.params.folderId, req.params.serverId, req.admin.tenantId);
    res.status(import_http_status_codes5.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    req.logger.error("Failed to delete folder", error);
    res.status(import_http_status_codes5.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to delete folder"
    });
  }
};

// src/routes/folders.routes.ts
var router4 = (0, import_express4.Router)();
router4.get("/:serverId/folders", listFolders2);
router4.post("/:serverId/folders", createFolder2);
router4.put("/:serverId/folders/:folderId", updateFolder2);
router4.delete("/:serverId/folders/:folderId", deleteFolder2);
var folders_routes_default = router4;

// src/routes/health.routes.ts
var import_express5 = __toESM(require("express"), 1);

// src/controllers/health.controller.ts
var import_http_status_codes6 = require("http-status-codes");
var getHealth = (_req, res) => {
  res.status(import_http_status_codes6.StatusCodes.OK).json({ status: "success" });
};

// src/routes/health.routes.ts
var router5 = import_express5.default.Router();
router5.get("/", getHealth);
router5.get("/ready", getHealth);
var health_routes_default = router5;

// src/routes/mcp.routes.ts
var import_express6 = require("express");

// src/controllers/mcp.controller.ts
var import_sse = require("@modelcontextprotocol/sdk/server/sse.js");
var import_streamableHttp = require("@modelcontextprotocol/sdk/server/streamableHttp.js");
var import_http_status_codes7 = require("http-status-codes");

// src/services/mcp.service.ts
var import_mcp = require("@modelcontextprotocol/sdk/server/mcp.js");
var import_isEmpty = __toESM(require("lodash/isEmpty.js"), 1);

// src/constants/tool-parameters.ts
var CONTEXT_PARAMETERS = {
  JWT: {
    key: "jwt",
    description: "JWT token from request Authorization header",
    source: "request",
    condition: (context) => !context.hasUserAuth && !!context.serverAuth?.userContext?.originalToken
  }
};
function injectContextParameters(req, callParameters, hasUserAuth) {
  const context = {
    hasUserAuth,
    serverAuth: "serverAuth" in req ? req.serverAuth : void 0
  };
  Object.values(CONTEXT_PARAMETERS).forEach((param) => {
    if (!param.condition || param.condition(context)) {
      const value = extractParameterValue(req, param, hasUserAuth);
      if (value !== void 0) {
        callParameters[param.key] = value;
      }
    }
  });
}
function extractParameterValue(req, param, hasUserAuth) {
  switch (param.key) {
    case "jwt":
      return !hasUserAuth && "serverAuth" in req && req.serverAuth?.userContext?.originalToken;
    default:
      return void 0;
  }
}

// src/services/api-exec/api-tool-executor.ts
var import_axios2 = __toESM(require("axios"), 1);
var import_handlebars = __toESM(require("handlebars"), 1);

// src/utils/json.ts
var jsonValueToRecord = (value) => {
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    return value;
  }
  return {};
};

// src/services/api-exec/parameter-schema.ts
var import_zod3 = require("zod");
function createZodSchemaFromParameters(logger2, parameters) {
  logger2.debug(`Converting parameters to Zod schema`);
  const paramSchema = {};
  for (const [key, param] of Object.entries(parameters)) {
    logger2.debug(`Processing parameter: ${key}`);
    if (!param || typeof param !== "object") {
      logger2.debug(`Invalid parameter ${key}, defaulting to any`);
      paramSchema[key] = import_zod3.z.any();
      continue;
    }
    const isRequired = !!param.required;
    if (param.in === "body") {
      logger2.debug(`Found body parameter: ${key}`);
      if (!param.schema) {
        paramSchema[key] = isRequired ? import_zod3.z.any() : import_zod3.z.any().optional();
        continue;
      }
      if ("$ref" in param.schema) {
        paramSchema[key] = isRequired ? import_zod3.z.any() : import_zod3.z.any().optional();
        continue;
      }
      const schema2 = param.schema;
      if (schema2.type === "object" && schema2.properties) {
        const bodySchema = import_zod3.z.object(
          Object.entries(schema2.properties).reduce(
            (acc, [propName, propSchema]) => {
              const propType = propSchema.type;
              let zodType = import_zod3.z.any();
              if (propType === "string") {
                zodType = import_zod3.z.string();
              } else if (propType === "number" || propType === "integer") {
                zodType = import_zod3.z.number();
              } else if (propType === "boolean") {
                zodType = import_zod3.z.boolean();
              } else if (propType === "array") {
                zodType = import_zod3.z.array(import_zod3.z.any());
              } else if (propType === "object") {
                zodType = import_zod3.z.record(import_zod3.z.any());
              }
              if ("description" in propSchema && propSchema.description) {
                zodType = zodType.describe(propSchema.description);
              }
              const isPropRequired = schema2.required?.includes(propName) === true;
              acc[propName] = isPropRequired ? zodType : zodType.optional();
              return acc;
            },
            {}
          )
        );
        paramSchema[key] = isRequired ? bodySchema : bodySchema.optional();
      } else {
        paramSchema[key] = isRequired ? import_zod3.z.any() : import_zod3.z.any().optional();
      }
      continue;
    }
    if (!param.schema) {
      logger2.debug(`No schema found for parameter ${key}, defaulting to any`);
      paramSchema[key] = isRequired ? import_zod3.z.any() : import_zod3.z.any().optional();
      continue;
    }
    if ("$ref" in param.schema) {
      logger2.debug(`Reference schema found for parameter ${key}, defaulting to any`);
      paramSchema[key] = isRequired ? import_zod3.z.any() : import_zod3.z.any().optional();
      continue;
    }
    const schema = param.schema;
    const schemaType = schema.type;
    switch (schemaType) {
      case "string":
        const stringSchema = import_zod3.z.string();
        if (schema.format === "date-time") {
          paramSchema[key] = isRequired ? import_zod3.z.string().datetime() : import_zod3.z.string().datetime().optional();
        } else if (schema.format === "email") {
          paramSchema[key] = isRequired ? import_zod3.z.string().email() : import_zod3.z.string().email().optional();
        } else if (schema.format === "uri") {
          paramSchema[key] = isRequired ? import_zod3.z.string().url() : import_zod3.z.string().url().optional();
        } else if (schema.enum) {
          if (Array.isArray(schema.enum) && schema.enum.length > 0) {
            paramSchema[key] = isRequired ? import_zod3.z.enum(schema.enum) : import_zod3.z.enum(schema.enum).optional();
          } else {
            paramSchema[key] = isRequired ? stringSchema : stringSchema.optional();
          }
        } else {
          paramSchema[key] = isRequired ? stringSchema : stringSchema.optional();
        }
        break;
      case "number":
      case "integer":
        let numberSchema = import_zod3.z.number();
        if (typeof schema.minimum === "number") {
          numberSchema = numberSchema.min(schema.minimum);
        }
        if (typeof schema.maximum === "number") {
          numberSchema = numberSchema.max(schema.maximum);
        }
        paramSchema[key] = isRequired ? numberSchema : numberSchema.optional();
        break;
      case "boolean":
        paramSchema[key] = isRequired ? import_zod3.z.boolean() : import_zod3.z.boolean().optional();
        break;
      case "array":
        if (schema.items) {
          if ("$ref" in schema.items) {
            paramSchema[key] = isRequired ? import_zod3.z.array(import_zod3.z.any()) : import_zod3.z.array(import_zod3.z.any()).optional();
          } else {
            const itemSchema = schema.items;
            const itemType = itemSchema.type;
            if (itemType === "string") {
              paramSchema[key] = isRequired ? import_zod3.z.array(import_zod3.z.string()) : import_zod3.z.array(import_zod3.z.string()).optional();
            } else if (itemType === "number" || itemType === "integer") {
              paramSchema[key] = isRequired ? import_zod3.z.array(import_zod3.z.number()) : import_zod3.z.array(import_zod3.z.number()).optional();
            } else if (itemType === "boolean") {
              paramSchema[key] = isRequired ? import_zod3.z.array(import_zod3.z.boolean()) : import_zod3.z.array(import_zod3.z.boolean()).optional();
            } else {
              paramSchema[key] = isRequired ? import_zod3.z.array(import_zod3.z.any()) : import_zod3.z.array(import_zod3.z.any()).optional();
            }
          }
        } else {
          paramSchema[key] = isRequired ? import_zod3.z.array(import_zod3.z.any()) : import_zod3.z.array(import_zod3.z.any()).optional();
        }
        break;
      case "object":
        paramSchema[key] = isRequired ? import_zod3.z.record(import_zod3.z.any()) : import_zod3.z.record(import_zod3.z.any()).optional();
        break;
      default:
        logger2.debug(`Unknown parameter type ${schemaType} for ${key}, defaulting to any`);
        paramSchema[key] = isRequired ? import_zod3.z.any() : import_zod3.z.any().optional();
    }
    if (schema.description && paramSchema[key]) {
      paramSchema[key] = paramSchema[key].describe(schema.description);
    }
  }
  return paramSchema;
}
function buildRequestConfig(logger2, apiCallMethod, apiCallUrl, baseUrl3, specParameters, callParameters, toolName) {
  const config2 = {
    method: apiCallMethod.toLowerCase(),
    url: apiCallUrl.startsWith("http") ? apiCallUrl : baseUrl3 ? `${baseUrl3}${apiCallUrl}` : apiCallUrl,
    headers: {},
    params: {},
    data: null
  };
  for (const [key, param] of Object.entries(specParameters)) {
    if (!param || typeof param !== "object") {
      continue;
    }
    let value = callParameters[key];
    if (value === void 0) {
      if (param.schema && "default" in param.schema) {
        value = param.schema.default;
        logger2.debug(`Using default value for parameter ${key}: ${value}`);
      } else if (param.required) {
        logger2.debug(`Required parameter ${key} missing for tool ${toolName}`);
        return { config: config2, missingRequiredParam: key };
      } else {
        logger2.debug(`Optional parameter ${key} not provided`);
        continue;
      }
    }
    if (!param.in) {
      continue;
    }
    switch (param.in) {
      case "query":
        logger2.debug(`Adding query parameter ${key}=${value}`);
        config2.params = config2.params || {};
        if (Array.isArray(value)) {
          config2.params[key] = param.explode ? value.map(String).map((v) => encodeURIComponent(v)).join("&") : value.map(String).map(encodeURIComponent).join(",");
        } else {
          config2.params[key] = value;
        }
        break;
      case "path":
        logger2.debug(`Replacing path parameter ${key}=${value}`);
        const pathValue = typeof value === "number" ? Math.floor(value).toString() : String(value);
        config2.url = config2.url?.replace(`{${key}}`, encodeURIComponent(pathValue));
        break;
      case "header":
        logger2.debug(`Adding header ${key}=${value}`);
        config2.headers = config2.headers || {};
        config2.headers[key] = String(value);
        break;
      case "cookie":
        logger2.debug(`Adding cookie ${key}=${value}`);
        const cookieValue = `${key}=${encodeURIComponent(String(value))}`;
        if (config2.headers?.Cookie) {
          config2.headers.Cookie += `; ${cookieValue}`;
        } else {
          config2.headers = config2.headers || {};
          config2.headers.Cookie = cookieValue;
        }
        break;
      default:
        if (["POST", "PUT", "PATCH"].includes(apiCallMethod)) {
          logger2.debug(`Adding ${key} to request body`);
          config2.data = config2.data || {};
          config2.data[key] = value;
        }
    }
  }
  config2.headers = config2.headers || {};
  if (["POST", "PUT", "PATCH"].includes(apiCallMethod)) {
    const bodyParams = {};
    let hasBodyParameter = false;
    for (const [key, param] of Object.entries(specParameters)) {
      if (param.in === "body" && callParameters[key] !== void 0) {
        logger2.debug(`Found body parameter: ${key}`);
        config2.data = callParameters[key];
        config2.headers["Content-Type"] = "application/json";
        hasBodyParameter = true;
        break;
      }
    }
    if (!hasBodyParameter) {
      for (const [key, value] of Object.entries(callParameters)) {
        const param = specParameters[key];
        if (!param || param.in !== "query" && param.in !== "path" && param.in !== "header" && param.in !== "cookie") {
          bodyParams[key] = value;
        }
      }
      if (Object.keys(bodyParams).length > 0) {
        logger2.debug(`Building request body from non-path/query/header parameters`);
        config2.data = bodyParams;
        config2.headers["Content-Type"] = "application/json";
      }
    }
  }
  if (callParameters["Authorization"]) {
    config2.headers["Authorization"] = callParameters["Authorization"];
  }
  return { config: config2 };
}

// src/services/api-exec/api-tool-executor.ts
import_handlebars.default.registerHelper("json", function(context) {
  return JSON.stringify(context);
});
var logApiCall = (logger2, tool2, baseUrl3, startTime, isPlayground, response) => {
  logger2.info("Analytics: API call completed", {
    toolId: tool2.id,
    baseUrl: baseUrl3,
    url: tool2.url,
    method: tool2.method,
    statusCode: response?.status || 0,
    bodyLen: response?.data ? String(response.data).length : 0,
    durationMS: Date.now() - startTime,
    failed: !response || response?.status >= 300 || response?.status < 200,
    isPlayground
  });
};
async function executeApiRequest(tool2, baseUrl3, specParameters, callParameters, logger2, isPlayground = false, authContext) {
  const responseFormatting = tool2.responseFormatting ? JSON.parse(JSON.stringify(tool2.responseFormatting)) : {};
  const startTime = Date.now();
  let requestData = null;
  try {
    let finalParameters = callParameters;
    let finalSpecParameters = specParameters;
    if (tool2.requestParameterOverrides) {
      const overrides = tool2.requestParameterOverrides;
      const isNewFormat = "query" in overrides || "headers" in overrides || "path" in overrides || "body" in overrides;
      if (isNewFormat) {
        logger2.debug(`Using new HTTP request override format`);
        finalParameters = {};
        const newSpecParameters = {};
        if (overrides.query) {
          for (const [key, value] of Object.entries(overrides.query)) {
            const processedValue = processHandlebarsTemplate(logger2, value, { toolParams: callParameters });
            if (processedValue !== "" && processedValue !== null && processedValue !== void 0) {
              finalParameters[key] = processedValue;
              newSpecParameters[key] = {
                name: key,
                in: "query",
                required: specParameters[key]?.required || false,
                schema: specParameters[key]?.schema || { type: "string" }
              };
            } else {
              logger2.debug(`Skipping empty query parameter: ${key}`);
            }
          }
        }
        if (overrides.headers) {
          for (const [key, value] of Object.entries(overrides.headers)) {
            const processedValue = processHandlebarsTemplate(logger2, value, { toolParams: callParameters });
            if (processedValue !== "" && processedValue !== null && processedValue !== void 0) {
              finalParameters[key] = processedValue;
              newSpecParameters[key] = {
                name: key,
                in: "header",
                required: specParameters[key]?.required || false,
                schema: specParameters[key]?.schema || { type: "string" }
              };
            } else {
              logger2.debug(`Skipping empty header parameter: ${key}`);
            }
          }
        }
        if (overrides.path) {
          for (const [key, value] of Object.entries(overrides.path)) {
            const processedValue = processHandlebarsTemplate(logger2, value, { toolParams: callParameters });
            if (processedValue !== "" && processedValue !== null && processedValue !== void 0) {
              finalParameters[key] = processedValue;
              newSpecParameters[key] = {
                name: key,
                in: "path",
                required: specParameters[key]?.required || true,
                // Path params are usually required
                schema: specParameters[key]?.schema || { type: "string" }
              };
            } else {
              logger2.warn(`Empty path parameter: ${key} - this may cause request to fail`);
            }
          }
        }
        if (overrides.body !== void 0) {
          let bodyValue = overrides.body;
          if (typeof bodyValue === "object" && bodyValue !== null) {
            bodyValue = JSON.parse(
              processHandlebarsTemplate(logger2, JSON.stringify(bodyValue), { toolParams: callParameters })
            );
          } else if (typeof bodyValue === "string") {
            bodyValue = processHandlebarsTemplate(logger2, bodyValue, { toolParams: callParameters });
          }
          finalParameters.body = bodyValue;
          newSpecParameters.body = {
            name: "body",
            in: "body",
            required: specParameters.body?.required || false,
            schema: specParameters.body?.schema || { type: "object" }
          };
        }
        finalSpecParameters = newSpecParameters;
      } else {
        logger2.debug(`Using old request parameter override format`);
        finalParameters = {};
        const newSpecParameters = {};
        for (const [paramName, override] of Object.entries(overrides)) {
          const processedValue = processHandlebarsTemplate(logger2, override.value, {
            toolParams: callParameters,
            auth: authContext || {}
          });
          finalParameters[paramName] = processedValue;
          newSpecParameters[paramName] = {
            name: paramName,
            in: override.location,
            required: specParameters[paramName]?.required || false,
            schema: specParameters[paramName]?.schema || { type: "string" }
          };
        }
        finalSpecParameters = newSpecParameters;
      }
      logger2.debug(`Applied request parameter overrides`, {
        original: callParameters,
        overrides,
        final: finalParameters,
        specs: finalSpecParameters,
        format: isNewFormat ? "new" : "old"
      });
    }
    const { config: config2, missingRequiredParam } = buildRequestConfig(
      logger2,
      tool2.method,
      tool2.url,
      baseUrl3,
      finalSpecParameters,
      finalParameters,
      tool2.name
    );
    if (missingRequiredParam) {
      return {
        content: [
          {
            type: "text",
            text: `Required parameter ${missingRequiredParam} is missing`
          }
        ],
        isError: true
      };
    }
    logger2.debug(
      `Executing API call with config: ${JSON.stringify({
        method: config2.method,
        url: config2.url,
        headers: config2.headers,
        params: config2.params,
        data: config2.data ? "[DATA]" : null
      })}`
    );
    requestData = responseFormatting.includeRequestData ? {
      schema: specParameters,
      data: {
        parameters: {
          headers: config2.headers || {},
          query: config2.params || {},
          path: extractPathParams(tool2.url, finalParameters, finalSpecParameters)
        },
        payload: config2.data || {}
      }
    } : null;
    const response = await (0, import_axios2.default)(config2);
    logger2.debug(`API call completed, status: ${response.status}`);
    const result = {
      schema: getResponseSchema(jsonValueToRecord(tool2.responses), response.status, response.headers["content-type"]),
      data: {
        headers: response.headers,
        body: response.data
      }
    };
    logger2.debug(`API call result:`, { result });
    let formattedResponse;
    if (responseFormatting.template) {
      logger2.debug(`Formatting response with template`);
      const templateData = {
        request: requestData,
        response: result,
        toolParams: callParameters,
        auth: authContext || {}
      };
      formattedResponse = processHandlebarsTemplate(logger2, responseFormatting.template, templateData);
    } else if (responseFormatting.itemTemplate && Array.isArray(result.data.body)) {
      logger2.debug(`Formatting response as array with itemTemplate`);
      const header = responseFormatting.header ? processHandlebarsTemplate(logger2, responseFormatting.header, { count: result.data.body.length }) : "";
      if (result.data.body.length === 0 && responseFormatting.emptyResult) {
        formattedResponse = `${header}${responseFormatting.emptyResult}`;
      } else {
        const separator = responseFormatting.separator || "\n\n";
        const items = result.data.body.map(
          (item) => processHandlebarsTemplate(logger2, responseFormatting.itemTemplate, {
            item,
            request: requestData,
            response: result,
            toolParams: callParameters,
            auth: authContext || {}
          })
        );
        formattedResponse = `${header}${items.join(separator)}`;
      }
    } else {
      logger2.debug(`No formatting configuration, returning JSON string`);
      formattedResponse = typeof result === "string" ? result : JSON.stringify(result, null, 2);
    }
    logger2.debug(`Returning tool response (${formattedResponse.length} chars)`);
    logApiCall(logger2, tool2, baseUrl3, startTime, isPlayground, response);
    return {
      content: [
        {
          type: "text",
          text: formattedResponse
        }
      ]
    };
  } catch (error) {
    if ((0, import_axios2.isAxiosError)(error)) {
      const axiosError = error;
      logApiCall(logger2, tool2, baseUrl3, startTime, isPlayground, axiosError.response || null);
      logger2.debug(
        `API call failed: ${axiosError.config?.method} ${axiosError.config?.url} - ${axiosError.response?.status}`,
        {
          status: axiosError.response?.status,
          method: axiosError.config?.method,
          url: axiosError.config?.url
        }
      );
    } else {
      logApiCall(logger2, tool2, baseUrl3, startTime, isPlayground, null);
      logger2.debug(`API call failed: ${error instanceof Error ? error.message : String(error)}`);
    }
    if (responseFormatting.errorTemplate) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const templateData = {
        error: errorMessage,
        message: errorMessage,
        request: requestData,
        response: {
          schema: getResponseSchema(jsonValueToRecord(tool2.responses), 0, "application/json"),
          data: {
            headers: {},
            body: { error: errorMessage }
          }
        },
        toolParams: callParameters,
        auth: authContext || {}
      };
      const formattedError = processHandlebarsTemplate(
        logger2,
        responseFormatting.errorTemplate,
        templateData
      );
      logger2.debug(`Returning formatted error: ${formattedError}`);
      return {
        content: [
          {
            type: "text",
            text: formattedError
          }
        ],
        isError: true
      };
    }
    let formattedResponse;
    if ((0, import_axios2.isAxiosError)(error) && error.response) {
      const errorResponse = {
        data: {
          content: {
            status: error.response.status,
            statusText: error.response.statusText,
            data: error.response.data
          },
          headers: error.response.headers
        },
        schema: getResponseSchema(
          jsonValueToRecord(tool2.responses),
          error.response.status,
          error.response.headers["content-type"]
        ) || "no schema found for response"
      };
      formattedResponse = typeof errorResponse === "string" ? errorResponse : JSON.stringify(errorResponse, null, 2);
    } else {
      formattedResponse = `API call failed: ${error instanceof Error ? error.message : String(error)}`;
    }
    return {
      content: [
        {
          type: "text",
          text: formattedResponse
        }
      ],
      isError: true
    };
  }
}
function getResponseSchema(responses, status, contentType = "application/json") {
  const statusKey = String(status);
  const response = responses[statusKey] || responses["default"];
  if (!response)
    return void 0;
  if (typeof response === "object" && response !== null && "content" in response && typeof response.content === "object" && response.content !== null) {
    const content = response.content;
    if (content[contentType]?.schema) {
      return {
        ...response,
        content: content[contentType].schema
      };
    }
    const firstContent = Object.values(content)[0];
    if (firstContent && typeof firstContent === "object" && "schema" in firstContent) {
      return firstContent.schema;
    }
  }
  return void 0;
}
function extractPathParams(url, callParameters, specParameters) {
  const pathParams = {};
  for (const [key, param] of Object.entries(specParameters)) {
    if (param.in === "path" && callParameters[key] !== void 0) {
      pathParams[key] = callParameters[key];
    }
  }
  return pathParams;
}
function processHandlebarsTemplate(logger2, template, data) {
  logger2.debug(`Processing Handlebars template with data keys: ${Object.keys(data).join(", ")}`);
  if (!template) {
    return "";
  }
  try {
    const compiledTemplate = import_handlebars.default.compile(template);
    return compiledTemplate(data);
  } catch (error) {
    logger2.warn(`Error processing Handlebars template`, error);
    return `Template processing error: ${error instanceof Error ? error.message : String(error)}`;
  }
}

// src/services/mcp.service.ts
var authenticateMessage = (url) => `Please authenticate before proceeding.

The following URL should be automatically opened in your browser, but if it doesn't, please open it manually:

${url}

Once authentication is complete, re-run your original query.`;
var CONSTANTS = {
  SYNTHETIC_EMAIL_DOMAIN: "@jwt.agentpass.ai",
  MCP_SERVER_VERSION: "1.0.0"
};
var ERROR_MESSAGES = {
  AUTH_PROVIDER_MISCONFIGURED: "Oops! We couldn't complete the request due to an authorization issue. Please get in touch with your MCP server administrator.",
  TOOL_EXECUTION_ERROR: (error) => `Error executing tool: ${error instanceof Error ? error.message : String(error)}`
};
var createErrorResponse = (message, isError = true) => ({
  content: [{ type: "text", text: message }],
  isError
});
var createAuthResponse = (authUrl) => ({
  content: [{ type: "text", text: authenticateMessage(authUrl) }]
});
function parseJwtClaims(jwt3) {
  try {
    const parts = jwt3.split(".");
    if (parts.length !== 3) {
      return {};
    }
    const header = parts[0];
    const paddedHeader = header + "=".repeat((4 - header.length % 4) % 4);
    const decodedHeader = Buffer.from(paddedHeader, "base64url").toString("utf8");
    const headerClaims = JSON.parse(decodedHeader);
    const payload = parts[1];
    const paddedPayload = payload + "=".repeat((4 - payload.length % 4) % 4);
    const decodedPayload = Buffer.from(paddedPayload, "base64url").toString("utf8");
    const payloadClaims = JSON.parse(decodedPayload);
    return { ...headerClaims, ...payloadClaims };
  } catch {
    return {};
  }
}
async function getMcpServerUnified(req) {
  const hasUserAuth = Boolean("user" in req && req.user);
  const hasServerAuth = Boolean("serverAuth" in req && req.serverAuth?.success);
  if (!hasUserAuth && !hasServerAuth) {
    throw new Error("No valid authentication found");
  }
  const serverId = req.serverId;
  const server = new import_mcp.McpServer(
    {
      name: serverId,
      version: CONSTANTS.MCP_SERVER_VERSION
    },
    { capabilities: { logging: {} } }
  );
  try {
    const tools = await req.db.tool.findMany({
      where: {
        serverId,
        enabled: true
      },
      include: {
        oAuthProvider: true,
        apiKeyProvider: true,
        server: {
          select: {
            baseUrl: true
          }
        }
      }
    });
    req.logger.debug(`Found ${tools.length} tools for server ${serverId}`);
    for (const tool2 of tools) {
      await registerToolUnified(req, server, tool2, hasUserAuth, hasServerAuth);
    }
  } catch (error) {
    req.logger.error(`Error loading tools for server ${serverId}:`, error);
    throw error;
  }
  return server;
}
async function registerToolUnified(req, server, tool2, hasUserAuth, hasServerAuth) {
  try {
    const specParameters = tool2.parameters ? JSON.parse(JSON.stringify(tool2.parameters)) : {};
    req.logger.debug(`Tool ${tool2.method} ${tool2.url} parameters: ${JSON.stringify(specParameters)}`);
    const paramSchema = createZodSchemaFromParameters(req.logger, specParameters);
    server.registerTool(
      tool2.name,
      {
        description: tool2.description,
        inputSchema: paramSchema
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (callParameters) => executeToolWithAuth(req, tool2, specParameters, callParameters, hasUserAuth, hasServerAuth)
    );
  } catch (error) {
    req.logger.error(`Failed to register tool ${tool2.name}:`, error);
    throw error;
  }
}
async function executeToolWithAuth(req, tool2, specParameters, callParameters, hasUserAuth, hasServerAuth) {
  req.logger.debug(
    `Tool ${tool2.name} (${tool2.method} @ ${tool2.url}) called with params: ${JSON.stringify(callParameters)}`
  );
  try {
    injectContextParameters(req, callParameters, hasUserAuth);
    const jwtToken = !hasUserAuth && "serverAuth" in req && req.serverAuth?.userContext?.originalToken || void 0;
    const jwtClaims = parseJwtClaims(jwtToken || "");
    const authContext = {
      jwt: {
        // Raw JWT string accessible as {{auth.jwt}}
        toString: () => jwtToken || "",
        valueOf: () => jwtToken || "",
        // JWT claims accessible as {{auth.jwt.propertyName}}
        ...jwtClaims
      }
    };
    if (jwtToken) {
      callParameters.jwt = jwtToken;
    }
    const toolAuthResult = await handleToolAuthentication(req, tool2, hasUserAuth, hasServerAuth);
    if (toolAuthResult.authProviderMisconfigured) {
      return createErrorResponse(ERROR_MESSAGES.AUTH_PROVIDER_MISCONFIGURED);
    }
    if (toolAuthResult.authMissing) {
      return createAuthResponse(toolAuthResult.authMissing.authUrl);
    }
    if (toolAuthResult.accessToken) {
      callParameters["Authorization"] = `Bearer ${toolAuthResult.accessToken.tokenValue}`;
      const tokenId = toolAuthResult.accessToken.tokenId;
      setImmediate(() => markTokenAsUsed(req.db, tokenId));
    }
    const startTime = Date.now();
    const result = await executeApiRequest(
      tool2,
      tool2.server.baseUrl,
      specParameters,
      callParameters,
      req.logger,
      false,
      authContext
    );
    await logToolExecution(req, tool2, result, startTime, hasUserAuth, hasServerAuth);
    return result;
  } catch (error) {
    req.logger.warn(`Error executing tool ${tool2.name}:`, error);
    return createErrorResponse(ERROR_MESSAGES.TOOL_EXECUTION_ERROR(error));
  }
}
async function logUserToolExecution(req, tool2, result, startTime) {
  analytics.track(req.user.id, "tool.execute.api_call", {
    tool_id: tool2.id,
    server_id: tool2.serverId,
    tenant_id: req.user.tenantId,
    end_user_id: req.user.id,
    tool_name: tool2.name,
    http_method: tool2.method,
    has_auth: !!tool2.oAuthProviderId || !!tool2.apiKeyProviderId,
    auth_type: tool2.oAuthProviderId ? "oauth" : tool2.apiKeyProviderId ? "api_key" : "none",
    execution_time_ms: Date.now() - startTime,
    success: !result.isError,
    is_playground: false
  });
  req.logger.info(`Tool ${tool2.name} executed for user ${req.user.email}`, {
    tool_id: tool2.id,
    server_id: tool2.serverId,
    tool_name: tool2.name,
    success: !result.isError,
    duration: Date.now() - startTime,
    user_id: req.user.id
  });
}
async function logToolExecution(req, tool2, result, startTime, hasUserAuth, hasServerAuth) {
  if (hasUserAuth) {
    const userReq = req;
    await logUserToolExecution(userReq, tool2, result, startTime);
    return;
  }
  if (hasServerAuth) {
    const serverAuthReq = req;
    if (serverAuthReq.serverAuth?.userContext?.userId && tool2.oAuthProvider) {
      const syntheticUserReq = req;
      if (syntheticUserReq.user) {
        await logUserToolExecution(syntheticUserReq, tool2, result, startTime);
        return;
      }
    }
  }
  req.logger.info(`Tool ${tool2.name} executed successfully`, {
    tool_id: tool2.id,
    server_id: tool2.serverId,
    tool_name: tool2.name,
    success: !result.isError,
    duration: Date.now() - startTime
  });
}
async function ensureSyntheticEndUser(db, userId, tenantId, logger2) {
  try {
    const existingUser = await db.endUser.findUnique({
      where: { id: userId }
    });
    if (existingUser) {
      logger2?.debug(`Synthetic EndUser already exists for JWT sub: ${userId}`);
      return;
    }
    await db.endUser.create({
      data: {
        id: userId,
        // Use JWT sub as the user ID
        tenantId,
        email: `${userId}${CONSTANTS.SYNTHETIC_EMAIL_DOMAIN}`,
        // Synthetic email to satisfy constraint
        emailVerified: false,
        name: `JWT Subject ${userId.substring(0, 8)}...`,
        // Truncated for readability
        enabled: true
      }
    });
    logger2?.info(`Created synthetic EndUser for JWT subject: ${userId}`, { tenantId });
  } catch (error) {
    if (error && typeof error === "object" && "code" in error && error.code === "P2002") {
      logger2?.debug(`Synthetic EndUser creation race condition for JWT sub: ${userId}`);
      return;
    }
    logger2?.error(`Failed to create synthetic EndUser for JWT subject: ${userId}`, error);
    throw error;
  }
}
async function handleToolAuthentication(req, tool2, hasUserAuth, hasServerAuth) {
  if (tool2.apiKeyProvider) {
    return {
      accessToken: {
        tokenId: tool2.apiKeyProvider.id,
        tokenValue: tool2.apiKeyProvider.value
      }
    };
  }
  if (tool2.oAuthProvider) {
    if ((0, import_isEmpty.default)(tool2.oAuthProvider.clientId) || (0, import_isEmpty.default)(tool2.oAuthProvider.clientSecret)) {
      return { authProviderMisconfigured: true };
    }
    const userId = await getUserIdForOAuth(req, hasUserAuth, hasServerAuth, tool2.name);
    if (typeof userId === "object") {
      return userId;
    }
    return await handleOAuthAuthentication(req, tool2.oAuthProvider, userId);
  }
  return {};
}
async function getUserIdForOAuth(req, hasUserAuth, hasServerAuth, toolName) {
  if (hasUserAuth) {
    const userReq = req;
    return userReq.user.id;
  }
  if (hasServerAuth) {
    const serverAuthReq = req;
    const jwtUserId = serverAuthReq.serverAuth?.userContext?.userId;
    if (!jwtUserId) {
      req.logger.warn(`OAuth tool ${toolName} requires user context in JWT token`);
      return { authProviderMisconfigured: true };
    }
    const server = await req.db.mcpServer.findUnique({
      where: { id: req.serverId },
      select: { tenantId: true }
    });
    if (!server) {
      req.logger.error(`MCP server not found: ${req.serverId}`);
      return { authProviderMisconfigured: true };
    }
    await ensureSyntheticEndUser(req.db, jwtUserId, server.tenantId, req.logger);
    return jwtUserId;
  }
  req.logger.error(`No authentication context available for OAuth tool ${toolName}`);
  return { authProviderMisconfigured: true };
}
async function handleOAuthAuthentication(req, oAuthProvider, userId) {
  const originAddress = req.ip || null;
  const tokens = await getUserUseableTokens(req.db, userId, oAuthProvider.id);
  if (tokens.length > 0) {
    const validTokens = tokens.filter((t) => !t.expiresAt || t.expiresAt > /* @__PURE__ */ new Date());
    if (validTokens.length > 0) {
      req.logger.debug(`Found valid token for provider ${oAuthProvider.name} (has ${tokens.length} tokens)`);
      return {
        accessToken: {
          tokenId: validTokens[0].id,
          tokenValue: validTokens[0].accessToken
        }
      };
    }
    const tokensWithRefresh = tokens.filter((t) => !!t.refreshToken);
    if (tokensWithRefresh.length > 0) {
      try {
        const tokenData = await refreshAndPersistAccessToken(
          req.db,
          req.logger,
          userId,
          oAuthProvider,
          tokensWithRefresh[0].refreshToken,
          originAddress
        );
        return {
          accessToken: {
            tokenId: tokenData.id,
            tokenValue: tokenData.accessToken
          }
        };
      } catch (error) {
        req.logger.warn(`Failed to refresh token for provider ${oAuthProvider.name}`, error);
        return {
          authMissing: {
            authUrl: getAuthorizeUrl(req, oAuthProvider, "", req.serverId, userId, TOOL_SCOPE, originAddress)
          }
        };
      }
    }
    const authUrl2 = getAuthorizeUrl(req, oAuthProvider, "", req.serverId, userId, TOOL_SCOPE, originAddress);
    req.logger.warn(
      `Found ${tokens.length} expired/invalid tokens for provider ${oAuthProvider.name}, prompting user to re-authenticate at '${authUrl2}'`
    );
    return { authMissing: { authUrl: authUrl2 } };
  }
  const authUrl = getAuthorizeUrl(req, oAuthProvider, "", req.serverId, userId, TOOL_SCOPE, originAddress);
  req.logger.warn(
    `No valid token found for provider ${oAuthProvider.name}, prompting user to authenticate at '${authUrl}'`
  );
  return { authMissing: { authUrl } };
}

// src/controllers/mcp.controller.ts
function sendMcpError(res, status, errorCode, message, isJsonRpc = true) {
  const error = isJsonRpc ? { jsonrpc: "2.0", error: { code: errorCode, message } } : { error: { code: errorCode, message } };
  res.status(status).json(error);
}
async function validateRequest(req, res) {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  if (!isWithServerIdRequest(req)) {
    const message = "Missing server ID";
    req.logger.warn(`${message}. serverId=${req["serverId"]}`);
    sendMcpError(res, import_http_status_codes7.StatusCodes.BAD_REQUEST, APP_BAD_REQUEST, `Bad Request: ${message}`);
    return false;
  }
  if (!req.serverAuth?.success) {
    sendMcpError(
      res,
      import_http_status_codes7.StatusCodes.UNAUTHORIZED,
      APP_BAD_REQUEST,
      req.serverAuth?.error || "Server authentication failed"
    );
    return false;
  }
  req.logger.debug("Request validation successful", {
    serverId: req.serverId,
    authType: req.serverAuth.userContext?.authType,
    userId: req.serverAuth.userContext?.userId
  });
  return true;
}
async function handleStreamablePost(req, res) {
  if (!isWithServerIdRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    if (!await validateRequest(req, res)) {
      return;
    }
    const mcpServer = await getMcpServerUnified(req);
    const transport = new import_streamableHttp.StreamableHTTPServerTransport({
      sessionIdGenerator: void 0
    });
    res.on("close", () => {
      transport.close();
      mcpServer.close();
    });
    await mcpServer.connect(transport);
    await transport.handleRequest(req, res, req.body);
  } catch (error) {
    req.logger.error("Error handling MCP streamable HTTP POST request", error);
    if (!res.headersSent) {
      sendMcpError(res, import_http_status_codes7.StatusCodes.INTERNAL_SERVER_ERROR, JSONRPC_INTERNAL_ERROR, "Internal server error");
    }
  }
}
var sseTransports = {};
async function handleSSE(req, res) {
  if (!isWithServerIdRequest(req)) {
    throw new TypeGuardError();
  }
  if (!await validateRequest(req, res)) {
    return;
  }
  const transport = new import_sse.SSEServerTransport("/api/mcp/messages", res);
  sseTransports[transport.sessionId] = transport;
  res.on("close", () => {
    delete sseTransports[transport.sessionId];
  });
  const server = await getMcpServerUnified(req);
  await server.connect(transport);
}
async function handleSSEMessage(req, res) {
  if (!isWithServerIdRequest(req)) {
    throw new TypeGuardError();
  }
  const sessionId = req.query.sessionId;
  if (!await validateRequest(req, res)) {
    return;
  }
  const transport = sessionId ? sseTransports[sessionId] : null;
  if (!transport) {
    if (sessionId) {
      req.logger.error("Session specified but not found", { sessionId });
    }
    return sendMcpError(res, import_http_status_codes7.StatusCodes.NOT_FOUND, APP_BAD_REQUEST, "Session not found");
  }
  await transport.handlePostMessage(req, res, req.body);
}
async function handleNotAllowed(req, res) {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  return sendMcpError(res, import_http_status_codes7.StatusCodes.METHOD_NOT_ALLOWED, JSONRPC_METHOD_NOT_ALLOWED, "Method not allowed");
}

// src/middleware/server-auth.middleware.ts
function createServerAuthMiddleware(serverAuthService, logger2) {
  return async (req, res, next) => {
    try {
      const serverId = req.serverId || req.params.serverId || req.headers["x-server-id"];
      if (!serverId) {
        logger2?.warn("Server authentication failed: missing server ID", {
          path: req.path,
          method: req.method,
          headers: req.headers
        });
        return res.status(400).json({
          error: "Server ID is required for authentication"
        });
      }
      const authResult = await serverAuthService.authenticateServerRequest(req, serverId);
      if (!authResult.success) {
        logger2?.warn("Server authentication failed", {
          serverId,
          error: authResult.error,
          path: req.path,
          method: req.method,
          authType: authResult.userContext?.authType
        });
        return res.status(401).json({
          error: "Authentication failed",
          details: authResult.error
        });
      }
      logger2?.info("Server authentication successful", {
        serverId,
        authType: authResult.userContext?.authType,
        userId: authResult.userContext?.userId,
        tenantId: authResult.userContext?.tenantId,
        path: req.path,
        method: req.method
      });
      req.serverAuth = authResult;
      req.serverId = serverId;
      next();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger2?.error("Internal authentication error", {
        serverId: req.params.serverId || req.headers["x-server-id"],
        error: errorMessage,
        path: req.path,
        method: req.method
      });
      res.status(500).json({
        error: "Internal authentication error",
        details: errorMessage
      });
    }
  };
}

// src/middlewares/serverId.middleware.ts
var serverIdMiddleware = (req, _res, next) => {
  if (!isAppRequest(req)) {
    throw new Error("Request does not have logger or db");
  }
  const serverIdOverride = process.env.LOCAL_SERVER_ID;
  if (serverIdOverride) {
    req.logger.debug(`Using local server ID: ${serverIdOverride}`);
    req.serverId = serverIdOverride;
  } else {
    const queryServerId = req.query.serverId;
    if (queryServerId) {
      req.logger.debug(`Using server ID from query parameter: ${queryServerId}`);
      req.serverId = queryServerId;
      req.logger = req.logger.child({
        serverId: queryServerId
      });
    } else {
      const serverId = req.hostname.split(".")[0];
      if (serverId === "app") {
        throw new Error(`Wrong hostname was used for the mcp server request: ${req.hostname}`);
      }
      req.logger.debug(`Using server ID from hostname: ${serverId}`);
      req.serverId = serverId;
      req.logger = req.logger.child({
        serverId
      });
    }
  }
  next();
};

// src/services/jwt-auth.service.ts
var import_crypto = require("crypto");
var import_jsonwebtoken2 = __toESM(require("jsonwebtoken"), 1);
var JwtAuthService = class {
  // 15 seconds
  constructor(logger2) {
    this.logger = logger2;
    this.keyCache = /* @__PURE__ */ new Map();
    this.circuitBreakers = /* @__PURE__ */ new Map();
    this.rateLimits = /* @__PURE__ */ new Map();
    // Configuration constants
    this.CACHE_TTL = 36e5;
    // 1 hour
    this.CACHE_REFRESH_THRESHOLD = 3e5;
    // 5 minutes before expiry
    this.CIRCUIT_BREAKER_FAILURE_THRESHOLD = 5;
    this.CIRCUIT_BREAKER_TIMEOUT = 6e4;
    // 1 minute
    this.RATE_LIMIT_WINDOW = 6e4;
    // 1 minute
    this.RATE_LIMIT_MAX_REQUESTS = 10;
    // per window
    this.REQUEST_TIMEOUT = 15e3;
  }
  /**
   * Validate JWT signature using JWKS endpoint
   * Implements comprehensive error handling and caching
   */
  async validateJwtSignature(token, jwksUrl) {
    try {
      if (!this.checkRateLimit(jwksUrl)) {
        this.logger?.warn("Rate limit exceeded for JWKS endpoint", { jwksUrl });
        return { valid: false, error: "Rate limit exceeded for JWKS endpoint" };
      }
      const decoded = import_jsonwebtoken2.default.decode(token, { complete: true });
      if (!decoded || typeof decoded === "string") {
        return { valid: false, error: "Invalid JWT format" };
      }
      const kid = decoded.header.kid;
      if (!kid) {
        return { valid: false, error: "Missing key ID in JWT header" };
      }
      const algorithm = decoded.header.alg;
      if (!algorithm || !["RS256", "RS384", "RS512"].includes(algorithm)) {
        return {
          valid: false,
          error: `Unsupported or missing algorithm: ${algorithm}. Only RS256, RS384, RS512 are supported.`
        };
      }
      const keys = await this.fetchJwksKeysWithCircuitBreaker(jwksUrl);
      const jwksKey = keys.find((key) => key.kid === kid);
      if (!jwksKey) {
        await this.refreshJwksKeys(jwksUrl);
        const refreshedKeys = await this.fetchJwksKeysWithCircuitBreaker(jwksUrl);
        const refreshedKey = refreshedKeys.find((key) => key.kid === kid);
        if (!refreshedKey) {
          return { valid: false, error: `Key ID ${kid} not found in JWKS after refresh` };
        }
        const publicKey2 = this.jwksKeyToPem(refreshedKey);
        return this.verifySignature(token, publicKey2, algorithm);
      }
      const publicKey = this.jwksKeyToPem(jwksKey);
      return this.verifySignature(token, publicKey, algorithm);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("JWT signature validation failed", {
        jwksUrl,
        error: errorMessage
      });
      return { valid: false, error: `JWT validation error: ${errorMessage}` };
    }
  }
  /**
   * Verify JWT signature with specific algorithm
   */
  verifySignature(token, publicKey, algorithm) {
    try {
      const payload = import_jsonwebtoken2.default.verify(token, publicKey, {
        algorithms: [algorithm],
        ignoreExpiration: true
        // We only verify signature, not expiration
      });
      return { valid: true, payload };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.warn("JWT signature verification failed", { error: errorMessage });
      return { valid: false, error: `Signature verification failed: ${errorMessage}` };
    }
  }
  /**
   * Fetch JWKS keys with circuit breaker pattern
   */
  async fetchJwksKeysWithCircuitBreaker(jwksUrl) {
    const circuitState = this.getCircuitBreakerState(jwksUrl);
    if (circuitState.state === "OPEN") {
      if (Date.now() < circuitState.nextAttemptTime) {
        throw new Error(
          `Circuit breaker OPEN for ${jwksUrl}. Next attempt at ${new Date(circuitState.nextAttemptTime).toISOString()}`
        );
      } else {
        circuitState.state = "HALF_OPEN";
      }
    }
    try {
      const keys = await this.fetchJwksKeys(jwksUrl);
      if (circuitState.state !== "CLOSED") {
        circuitState.state = "CLOSED";
        circuitState.failureCount = 0;
      }
      return keys;
    } catch (error) {
      circuitState.failureCount++;
      circuitState.lastFailureTime = Date.now();
      if (circuitState.failureCount >= this.CIRCUIT_BREAKER_FAILURE_THRESHOLD) {
        circuitState.state = "OPEN";
        circuitState.nextAttemptTime = Date.now() + this.CIRCUIT_BREAKER_TIMEOUT;
        this.logger?.error("Circuit breaker OPEN due to failures", {
          jwksUrl,
          failureCount: circuitState.failureCount
        });
      }
      throw error;
    }
  }
  /**
   * Fetch JWKS keys with intelligent caching
   */
  async fetchJwksKeys(jwksUrl) {
    try {
      const cached = this.keyCache.get(jwksUrl);
      if (cached) {
        const now = Date.now();
        if (now < cached.expiry) {
          if (now > cached.expiry - this.CACHE_REFRESH_THRESHOLD) {
            this.refreshJwksKeysInBackground(jwksUrl);
          }
          return cached.keys;
        }
      }
      return await this.fetchFreshJwksKeys(jwksUrl);
    } catch (error) {
      const cached = this.keyCache.get(jwksUrl);
      if (cached && cached.keys.length > 0) {
        this.logger?.warn("Using stale cached JWKS keys due to fetch failure", {
          jwksUrl,
          cacheAge: Date.now() - cached.lastFetch
        });
        return cached.keys;
      }
      throw error;
    }
  }
  /**
   * Fetch fresh JWKS keys from endpoint
   */
  async fetchFreshJwksKeys(jwksUrl) {
    const response = await fetch(jwksUrl, {
      method: "GET",
      headers: {
        Accept: "application/json",
        "User-Agent": "AgentBridge/1.0",
        "Cache-Control": "no-cache"
      },
      signal: AbortSignal.timeout(this.REQUEST_TIMEOUT)
    });
    if (!response.ok) {
      throw new Error(`JWKS endpoint error: HTTP ${response.status} ${response.statusText}`);
    }
    const jwks = await response.json();
    if (!jwks.keys || !Array.isArray(jwks.keys)) {
      throw new Error("Invalid JWKS format: missing or invalid keys array");
    }
    const rsaKeys = jwks.keys.filter((key) => {
      if (typeof key === "object" && key !== null) {
        const jwksKey = key;
        return jwksKey.kty === "RSA" && (jwksKey.use === "sig" || !jwksKey.use) && // use is optional, default to sig
        jwksKey.n && jwksKey.e && jwksKey.kid;
      }
      return false;
    }).map((key) => key);
    if (rsaKeys.length === 0) {
      throw new Error("No valid RSA signature keys found in JWKS");
    }
    const now = Date.now();
    this.keyCache.set(jwksUrl, {
      keys: rsaKeys,
      expiry: now + this.CACHE_TTL,
      lastFetch: now,
      failureCount: 0
    });
    return rsaKeys;
  }
  /**
   * Refresh JWKS keys in background
   */
  async refreshJwksKeysInBackground(jwksUrl) {
    try {
      await this.fetchFreshJwksKeys(jwksUrl);
    } catch (error) {
      this.logger?.warn("Background JWKS refresh failed", {
        jwksUrl,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Force refresh JWKS keys (for key rotation)
   */
  async refreshJwksKeys(jwksUrl) {
    await this.fetchFreshJwksKeys(jwksUrl);
  }
  /**
   * Check rate limiting for JWKS endpoint
   */
  checkRateLimit(jwksUrl) {
    const now = Date.now();
    const rateLimit = this.rateLimits.get(jwksUrl) || { count: 0, windowStart: now };
    if (now - rateLimit.windowStart > this.RATE_LIMIT_WINDOW) {
      rateLimit.count = 0;
      rateLimit.windowStart = now;
    }
    if (rateLimit.count >= this.RATE_LIMIT_MAX_REQUESTS) {
      return false;
    }
    rateLimit.count++;
    this.rateLimits.set(jwksUrl, rateLimit);
    return true;
  }
  /**
   * Get circuit breaker state for endpoint
   */
  getCircuitBreakerState(jwksUrl) {
    if (!this.circuitBreakers.has(jwksUrl)) {
      this.circuitBreakers.set(jwksUrl, {
        state: "CLOSED",
        failureCount: 0,
        lastFailureTime: 0,
        nextAttemptTime: 0
      });
    }
    return this.circuitBreakers.get(jwksUrl);
  }
  /**
   * Convert JWKS key to proper format for verification using Node.js crypto
   */
  jwksKeyToPem(jwksKey) {
    try {
      const publicKey = (0, import_crypto.createPublicKey)({
        key: {
          kty: jwksKey.kty,
          n: jwksKey.n,
          e: jwksKey.e
        },
        format: "jwk"
      });
      return publicKey.export({ type: "spki", format: "pem" });
    } catch (error) {
      throw new Error(`Failed to convert JWKS key to PEM: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get cache statistics for monitoring
   */
  getCacheStats() {
    const stats = {};
    for (const [url, cached] of this.keyCache.entries()) {
      const circuitState = this.circuitBreakers.get(url);
      const rateLimit = this.rateLimits.get(url);
      stats[url] = {
        keyCount: cached.keys.length,
        lastFetch: new Date(cached.lastFetch).toISOString(),
        expiry: new Date(cached.expiry).toISOString(),
        expired: Date.now() > cached.expiry,
        failureCount: cached.failureCount,
        circuitBreakerState: circuitState?.state || "UNKNOWN",
        rateLimitCount: rateLimit?.count || 0
      };
    }
    return stats;
  }
};

// src/services/mcp-access.service.ts
init_cache_service();
async function validateServerAccess(db, logger2, serverId, userEmail) {
  logger2.debug(`Validating server access for user ${userEmail} and server ${serverId}`);
  return await cacheGetOrAdd(
    { type: "server_access" /* SERVER_ACCESS */, ids: [serverId, userEmail] },
    async () => {
      const server = await cacheGetOrAdd(
        { type: "server" /* SERVER */, ids: [serverId] },
        async () => {
          return await db.mcpServer.findFirst({
            where: {
              id: serverId
            }
          });
        }
      );
      if (!server) {
        return {
          error: {
            code: APP_INVALID_SERVER,
            message: `Server not found: ${serverId}`
          }
        };
      }
      if (!server.enabled) {
        return {
          error: {
            code: APP_INVALID_SERVER,
            message: `Server is not enabled: ${serverId}`
          }
        };
      }
      logger2.debug(`Looking for user with email: ${userEmail} and tenantId: ${server.tenantId}`);
      const user = await db.endUser.findFirst({
        where: {
          email: userEmail,
          tenantId: server.tenantId
        },
        select: {
          id: true,
          enabled: true
        }
      });
      if (!user) {
        return { userNotFound: true };
      }
      if (!user.enabled) {
        return {
          error: {
            code: APP_INSUFFICIENT_PERMISSIONS,
            message: `User ${userEmail} does not have access to server: ${serverId}`
          }
        };
      }
      return {};
    }
  );
}

// src/services/strategies/base-auth.strategy.ts
var BaseAuthStrategy = class {
  async authenticate(req, config2) {
    try {
      if (!isAppRequest(req)) {
        return {
          success: false,
          error: "Invalid request context for authentication"
        };
      }
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return {
          success: false,
          error: "No authorization header provided for BASE authentication"
        };
      }
      const token = authHeader.split(" ")[1];
      const { verifyEndUserToken: verifyEndUserToken2 } = await Promise.resolve().then(() => (init_jwt_service(), jwt_service_exports));
      const decoded = await verifyEndUserToken2(token);
      if (!decoded) {
        return {
          success: false,
          error: "Invalid or expired user token"
        };
      }
      const userEmail = decoded.email;
      if (!userEmail) {
        return {
          success: false,
          error: "No user email found in token"
        };
      }
      const accessResult = await validateServerAccess(req.db, req.logger, config2.serverId, userEmail);
      if (accessResult.error) {
        return {
          success: false,
          error: accessResult.error.message
        };
      }
      if (accessResult.userNotFound) {
        return {
          success: false,
          error: `User ${userEmail} not found or does not have access to server`
        };
      }
      const user = await req.db.endUser.findFirst({
        where: {
          email: userEmail
        },
        select: {
          id: true,
          tenantId: true
        }
      });
      return {
        success: true,
        userContext: {
          userId: user?.id,
          tenantId: user?.tenantId,
          authType: "BASE" /* BASE */
        },
        metadata: {
          validatedAt: /* @__PURE__ */ new Date()
        }
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: `Base authentication failed: ${errorMessage}`
      };
    }
  }
  async validateConfiguration(config2) {
    return {
      valid: true
    };
  }
  /**
   * Get providers for BASE auth (returns empty array as BASE auth doesn't use providers)
   */
  async getProviders(serverId) {
    return [];
  }
  /**
   * Create provider for BASE auth (not applicable)
   */
  async createProvider(serverId, providerData) {
    throw new Error("BASE authentication does not support providers");
  }
  /**
   * Update provider for BASE auth (not applicable)
   */
  async updateProvider(serverId, providerId, providerData) {
    throw new Error("BASE authentication does not support providers");
  }
  /**
   * Delete provider for BASE auth (not applicable)
   */
  async deleteProvider(serverId, providerId) {
    throw new Error("BASE authentication does not support providers");
  }
  /**
   * Handle BASE configuration update (no special config needed)
   */
  async handleConfigUpdate(serverId, config2) {
    return null;
  }
};

// src/services/strategies/jwt-auth.strategy.ts
var JwtAuthStrategy = class {
  constructor(jwtService, db, logger2) {
    this.jwtService = jwtService;
    this.db = db;
    this.logger = logger2;
  }
  async authenticate(req, config2) {
    try {
      if (!config2.jwtProvider) {
        return {
          success: false,
          error: "JWT provider not configured for this server"
        };
      }
      if (!config2.jwtProvider.enabled) {
        return {
          success: false,
          error: "JWT provider is disabled"
        };
      }
      const token = this.extractJwtToken(req);
      if (!token) {
        return {
          success: false,
          error: "No JWT token found in request. Expected Authorization header with Bearer token."
        };
      }
      const validationResult = await this.jwtService.validateJwtSignature(token, config2.jwtProvider.jwksUrl);
      if (!validationResult.valid) {
        return {
          success: false,
          error: validationResult.error || "JWT signature validation failed"
        };
      }
      let userId;
      let tenantId;
      if (validationResult.payload && typeof validationResult.payload === "object") {
        const payload = validationResult.payload;
        userId = payload.id || payload.sub;
        tenantId = payload.tenantId;
        this.logger?.debug("JWT authentication extracted user context", {
          userId,
          tenantId,
          providerId: config2.jwtProvider.id
        });
      }
      return {
        success: true,
        userContext: {
          userId,
          tenantId,
          authType: "JWT" /* JWT */,
          originalToken: token
        },
        metadata: {
          providerId: config2.jwtProvider.id,
          validatedAt: /* @__PURE__ */ new Date()
        }
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("JWT authentication failed", { error: errorMessage });
      return {
        success: false,
        error: `JWT authentication failed: ${errorMessage}`
      };
    }
  }
  async validateConfiguration(config2) {
    const errors = [];
    if (!config2.jwtProvider) {
      errors.push("JWT provider is required for JWT authentication");
    } else {
      if (!config2.jwtProvider.jwksUrl) {
        errors.push("JWKS URL is required");
      } else {
        try {
          new URL(config2.jwtProvider.jwksUrl);
        } catch {
          errors.push("Invalid JWKS URL format");
        }
      }
      if (!config2.jwtProvider.enabled) {
        errors.push("JWT provider is disabled");
      }
      if (config2.jwtProvider.jwksUrl && config2.jwtProvider.enabled) {
        try {
          await this.jwtService.fetchJwksKeys(config2.jwtProvider.jwksUrl);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          errors.push(`JWKS endpoint test failed: ${errorMessage}`);
        }
      }
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Get JWT providers for a server
   */
  async getProviders(serverId) {
    try {
      const providers = await this.db.serverJwtProvider.findMany({
        where: { serverId },
        orderBy: { createdAt: "desc" }
      });
      return providers;
    } catch (error) {
      this.logger?.error("Failed to get JWT providers", { serverId, error });
      throw error;
    }
  }
  /**
   * Create JWT provider for a server
   */
  async createProvider(serverId, providerData) {
    const { name, jwksUrl, enabled = true } = providerData;
    try {
      const server = await this.db.mcpServer.findUnique({
        where: { id: serverId },
        select: { tenantId: true }
      });
      if (!server) {
        throw new Error(`Server ${serverId} not found`);
      }
      const provider = await this.db.serverJwtProvider.create({
        data: {
          serverId,
          tenantId: server.tenantId,
          name,
          jwksUrl,
          enabled
        }
      });
      return provider;
    } catch (error) {
      this.logger?.error("Failed to create JWT provider", { serverId, error });
      throw error;
    }
  }
  /**
   * Update JWT provider for a server
   */
  async updateProvider(serverId, providerId, providerData) {
    const { name, jwksUrl, enabled } = providerData;
    try {
      const provider = await this.db.serverJwtProvider.update({
        where: {
          id: providerId,
          serverId
          // Ensure provider belongs to the server
        },
        data: {
          ...name !== void 0 && { name },
          ...jwksUrl !== void 0 && { jwksUrl },
          ...enabled !== void 0 && { enabled }
        }
      });
      return provider;
    } catch (error) {
      this.logger?.error("Failed to update JWT provider", { serverId, providerId, error });
      throw error;
    }
  }
  /**
   * Delete JWT provider for a server
   */
  async deleteProvider(serverId, providerId) {
    try {
      await this.db.serverJwtProvider.delete({
        where: {
          id: providerId,
          serverId
          // Ensure provider belongs to the server
        }
      });
    } catch (error) {
      this.logger?.error("Failed to delete JWT provider", { serverId, providerId, error });
      throw error;
    }
  }
  /**
   * Handle JWT configuration update
   */
  async handleConfigUpdate(serverId, config2) {
    if (!config2.jwtProviderId) {
      return null;
    }
    try {
      const existingAuthConfig = await this.db.serverAuthConfig.findUnique({
        where: { serverId }
      });
      if (existingAuthConfig) {
        await this.db.serverAuthConfig.update({
          where: { id: existingAuthConfig.id },
          data: {
            authType: config2.authType,
            jwtProviderId: config2.jwtProviderId
          }
        });
        return existingAuthConfig.id;
      } else {
        const newAuthConfig = await this.db.serverAuthConfig.create({
          data: {
            serverId,
            authType: config2.authType,
            jwtProviderId: config2.jwtProviderId
          }
        });
        return newAuthConfig.id;
      }
    } catch (error) {
      this.logger?.error("Failed to handle JWT config update", { serverId, error });
      throw error;
    }
  }
  /**
   * Extract JWT token from various request locations
   * Supports: Authorization header (Bearer), query parameter, custom headers
   */
  extractJwtToken(req) {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith("Bearer ")) {
      return authHeader.substring(7);
    }
    const queryToken = req.query.token;
    if (typeof queryToken === "string") {
      return queryToken;
    }
    const customHeader = req.headers["x-auth-token"];
    if (typeof customHeader === "string") {
      return customHeader;
    }
    const bodyToken = req.body?.token;
    if (typeof bodyToken === "string") {
      return bodyToken;
    }
    return null;
  }
};

// src/services/factories/auth-strategy.factory.ts
var AuthStrategyFactory = class {
  constructor(db, logger2) {
    this.strategies = /* @__PURE__ */ new Map();
    this.strategies.set("BASE" /* BASE */, new BaseAuthStrategy());
    this.strategies.set("JWT" /* JWT */, new JwtAuthStrategy(new JwtAuthService(logger2), db, logger2));
  }
  /**
   * Get authentication strategy for the given auth type
   * @throws Error if auth type is not supported
   */
  getStrategy(authType) {
    const strategy = this.strategies.get(authType);
    if (!strategy) {
      throw new Error(`Unsupported authentication strategy: ${authType}`);
    }
    return strategy;
  }
  /**
   * Check if an auth type is supported
   */
  isSupported(authType) {
    return this.strategies.has(authType);
  }
  /**
   * Get all supported auth types
   */
  getSupportedAuthTypes() {
    return Array.from(this.strategies.keys());
  }
};

// src/services/server-auth.service.ts
var ServerAuthService = class {
  constructor(db, logger2) {
    this.db = db;
    this.logger = logger2;
    this.strategyFactory = new AuthStrategyFactory(db, logger2);
  }
  /**
   * Authenticate a server request using the configured authentication strategy
   * This method uses the Strategy Pattern to avoid hardcoded authentication logic
   */
  async authenticateServerRequest(req, serverId) {
    try {
      this.logger?.debug("Authenticating server request", { serverId });
      const config2 = await this.getServerAuthConfig(serverId);
      if (!config2) {
        return {
          success: false,
          error: `No authentication configuration found for server: ${serverId}`
        };
      }
      const strategy = this.strategyFactory.getStrategy(config2.authType);
      const result = await strategy.authenticate(req, config2);
      this.logger?.debug("Authentication result", {
        serverId,
        authType: config2.authType,
        success: result.success
      });
      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to authenticate server request", {
        serverId,
        error: errorMessage
      });
      return {
        success: false,
        error: `Authentication failed: ${errorMessage}`
      };
    }
  }
  /**
   * Get server authentication configuration
   */
  async getServerAuthConfig(serverId) {
    try {
      this.logger?.debug("Getting server auth config", { serverId });
      const server = await this.db.mcpServer.findFirst({
        where: { id: serverId },
        include: {
          authConfig: {
            include: {
              jwtProvider: true
            }
          }
        }
      });
      if (!server) {
        throw new Error(`Server not found: ${serverId}`);
      }
      if (!server.authConfig) {
        return {
          id: `default-${serverId}`,
          serverId: server.id,
          authType: server.authType || "BASE" /* BASE */
        };
      }
      return {
        id: server.authConfig.id,
        serverId: server.id,
        authType: server.authConfig.authType,
        jwtProviderId: server.authConfig.jwtProviderId || void 0,
        jwtProvider: server.authConfig.jwtProvider || void 0
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to get server auth config", {
        serverId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Update server authentication configuration
   */
  async updateServerAuthConfig(serverId, config2) {
    try {
      this.logger?.debug("Updating server auth config", { serverId, config: config2 });
      if (!this.strategyFactory.isSupported(config2.authType)) {
        throw new Error(`Unsupported authentication type: ${config2.authType}`);
      }
      const strategy = this.strategyFactory.getStrategy(config2.authType);
      const authConfigId = await strategy.handleConfigUpdate(serverId, {
        authType: config2.authType,
        jwtProviderId: config2.jwtProviderId || void 0
      });
      const server = await this.db.mcpServer.update({
        where: { id: serverId },
        data: {
          authType: config2.authType,
          authConfigId
        },
        include: {
          authConfig: {
            include: {
              jwtProvider: true
            }
          }
        }
      });
      if (config2.authType === "JWT" /* JWT */) {
        try {
          await this.addJwtHeadersToAllTools(serverId);
          this.logger?.info("Automatically added JWT headers to all tools after setting JWT auth type", { serverId });
        } catch (error) {
          this.logger?.warn("Failed to automatically add JWT headers to tools", { serverId, error });
        }
      }
      return {
        serverId: server.id,
        authType: server.authType,
        authConfig: server.authConfig ? {
          id: server.authConfig.id,
          authType: server.authConfig.authType,
          jwtProvider: server.authConfig.jwtProvider ? {
            id: server.authConfig.jwtProvider.id,
            name: server.authConfig.jwtProvider.name,
            jwksUrl: server.authConfig.jwtProvider.jwksUrl,
            enabled: server.authConfig.jwtProvider.enabled
          } : void 0
        } : void 0
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to update server auth config", {
        serverId,
        config: config2,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Get supported authentication types
   * Returns all authentication types supported by the current strategy factory
   */
  getSupportedAuthTypes() {
    return this.strategyFactory.getSupportedAuthTypes();
  }
  /**
   * Get auth providers for a server (strategy-based)
   */
  async getAuthProviders(serverId) {
    try {
      const config2 = await this.getServerAuthConfig(serverId);
      if (!config2) {
        return [];
      }
      const strategy = this.strategyFactory.getStrategy(config2.authType);
      return await strategy.getProviders(serverId);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to get auth providers", {
        serverId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Create auth provider for a server (strategy-based)
   */
  async createAuthProvider(serverId, providerData) {
    try {
      const config2 = await this.getServerAuthConfig(serverId);
      if (!config2) {
        throw new Error("No authentication configuration found");
      }
      const strategy = this.strategyFactory.getStrategy(config2.authType);
      return await strategy.createProvider(serverId, providerData);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to create auth provider", {
        serverId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Update auth provider for a server (strategy-based)
   */
  async updateAuthProvider(serverId, providerId, providerData) {
    try {
      const config2 = await this.getServerAuthConfig(serverId);
      if (!config2) {
        throw new Error("No authentication configuration found");
      }
      const strategy = this.strategyFactory.getStrategy(config2.authType);
      return await strategy.updateProvider(serverId, providerId, providerData);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to update auth provider", {
        serverId,
        providerId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Delete auth provider for a server (strategy-based)
   */
  async deleteAuthProvider(serverId, providerId) {
    try {
      const config2 = await this.getServerAuthConfig(serverId);
      if (!config2) {
        throw new Error("No authentication configuration found");
      }
      const strategy = this.strategyFactory.getStrategy(config2.authType);
      await strategy.deleteProvider(serverId, providerId);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to delete auth provider", {
        serverId,
        providerId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Get JWT providers for a server
   */
  async getJwtProviders(serverId) {
    try {
      this.logger?.debug("Getting JWT providers", { serverId });
      return await this.db.serverJwtProvider.findMany({
        where: { serverId },
        orderBy: { createdAt: "desc" }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to get JWT providers", {
        serverId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Create a new JWT provider for a server
   */
  async createJwtProvider(serverId, data) {
    try {
      this.logger?.debug("Creating JWT provider", { serverId, data });
      const server = await this.db.mcpServer.findUnique({
        where: { id: serverId },
        select: { tenantId: true }
      });
      if (!server) {
        throw new Error(`Server not found: ${serverId}`);
      }
      return await this.db.serverJwtProvider.create({
        data: {
          serverId,
          tenantId: server.tenantId,
          name: data.name,
          jwksUrl: data.jwksUrl,
          enabled: data.enabled ?? true
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to create JWT provider", {
        serverId,
        data,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Update a JWT provider
   */
  async updateJwtProvider(serverId, providerId, data) {
    try {
      this.logger?.debug("Updating JWT provider", { serverId, providerId, data });
      return await this.db.serverJwtProvider.update({
        where: {
          id: providerId,
          serverId
          // Ensure the provider belongs to the specified server
        },
        data: {
          ...data.name && { name: data.name },
          ...data.jwksUrl && { jwksUrl: data.jwksUrl },
          ...data.enabled !== void 0 && { enabled: data.enabled }
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to update JWT provider", {
        serverId,
        providerId,
        data,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Delete a JWT provider
   */
  async deleteJwtProvider(serverId, providerId) {
    try {
      this.logger?.debug("Deleting JWT provider", { serverId, providerId });
      await this.db.serverJwtProvider.delete({
        where: {
          id: providerId,
          serverId
          // Ensure the provider belongs to the specified server
        }
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to delete JWT provider", {
        serverId,
        providerId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Add JWT headers to all tools for a server
   * This updates the requestParameterOverrides of all tools to include Authorization header with JWT token
   */
  async addJwtHeadersToAllTools(serverId) {
    try {
      this.logger?.debug("Adding JWT headers to all tools for server", { serverId });
      const server = await this.db.mcpServer.findUnique({
        where: { id: serverId },
        include: {
          authConfig: {
            include: {
              jwtProvider: true
            }
          }
        }
      });
      if (!server) {
        throw new Error(`Server not found: ${serverId}`);
      }
      if (server.authType !== "JWT" /* JWT */) {
        throw new Error(`Server ${serverId} does not use JWT authentication. Current auth type: ${server.authType}`);
      }
      const tools = await this.db.tool.findMany({
        where: { serverId },
        select: { id: true, requestParameterOverrides: true }
      });
      if (tools.length === 0) {
        this.logger?.info("No tools found for server", { serverId });
        return { updatedToolsCount: 0 };
      }
      const updatePromises = tools.map(async (tool2) => {
        const existingOverrides = tool2.requestParameterOverrides ? JSON.parse(JSON.stringify(tool2.requestParameterOverrides)) : {};
        const updatedOverrides = {
          ...existingOverrides,
          Authorization: {
            value: "Bearer {{auth.jwt}}",
            location: "header" /* HEADER */
          }
        };
        return this.db.tool.update({
          where: { id: tool2.id },
          data: {
            requestParameterOverrides: updatedOverrides
          }
        });
      });
      await Promise.all(updatePromises);
      this.logger?.info("Successfully added JWT headers to all tools", {
        serverId,
        updatedToolsCount: tools.length
      });
      return { updatedToolsCount: tools.length };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to add JWT headers to all tools", {
        serverId,
        error: errorMessage
      });
      throw error;
    }
  }
  /**
   * Validate a JWKS URL by fetching and parsing it
   */
  async validateJwksUrl(jwksUrl) {
    try {
      this.logger?.debug("Validating JWKS URL", { jwksUrl });
      try {
        new URL(jwksUrl);
      } catch {
        return {
          valid: false,
          error: "Invalid URL format"
        };
      }
      this.logger?.debug("Fetching JWKS from URL", { jwksUrl });
      const response = await fetch(jwksUrl, {
        method: "GET",
        headers: {
          Accept: "application/json"
        },
        // Add timeout to prevent hanging requests
        signal: AbortSignal.timeout(1e4)
        // 10 second timeout
      });
      this.logger?.debug("JWKS fetch response", {
        jwksUrl,
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries())
      });
      if (!response.ok) {
        this.logger?.warn("JWKS URL fetch failed", {
          jwksUrl,
          status: response.status,
          statusText: response.statusText
        });
        return {
          valid: false,
          error: `Failed to fetch JWKS: ${response.status} ${response.statusText}`
        };
      }
      let jwks;
      try {
        jwks = await response.json();
      } catch {
        return {
          valid: false,
          error: "Response is not valid JSON"
        };
      }
      if (!jwks || typeof jwks !== "object") {
        return {
          valid: false,
          error: "JWKS response is not a valid object"
        };
      }
      if (!Array.isArray(jwks.keys)) {
        return {
          valid: false,
          error: "JWKS does not contain a 'keys' array"
        };
      }
      if (jwks.keys.length === 0) {
        return {
          valid: false,
          error: "JWKS contains no keys"
        };
      }
      for (let i = 0; i < jwks.keys.length; i++) {
        const key = jwks.keys[i];
        if (!key.kty) {
          return {
            valid: false,
            error: `Key at index ${i} is missing required 'kty' property`
          };
        }
      }
      return {
        valid: true,
        keyCount: jwks.keys.length
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error("Failed to validate JWKS URL", {
        jwksUrl,
        error: errorMessage
      });
      if (error instanceof TypeError && error.message.includes("fetch")) {
        return {
          valid: false,
          error: "Network error: Unable to fetch JWKS URL"
        };
      }
      if (error instanceof Error && error.name === "TimeoutError") {
        return {
          valid: false,
          error: "Timeout: JWKS URL did not respond within 10 seconds"
        };
      }
      return {
        valid: false,
        error: `Validation failed: ${errorMessage}`
      };
    }
  }
};

// src/routes/mcp.routes.ts
var router6 = (0, import_express6.Router)();
var serverAuthMiddleware;
var enhancedServerAuth = async (req, res, next) => {
  const appReq = req;
  if (!serverAuthMiddleware) {
    try {
      const serverAuthService = new ServerAuthService(appReq.db, appReq.logger);
      serverAuthMiddleware = createServerAuthMiddleware(serverAuthService, appReq.logger);
      appReq.logger?.info("Server authentication middleware lazy-initialized");
    } catch (error) {
      appReq.logger?.error("Failed to initialize server auth middleware:", error);
      return res.status(503).json({
        error: "Server authentication not configured",
        details: "Failed to initialize server authentication middleware"
      });
    }
  }
  return serverAuthMiddleware(appReq, res, next);
};
router6.post("/api/mcp", serverIdMiddleware, enhancedServerAuth, handleStreamablePost);
router6.get("/api/mcp", serverIdMiddleware, enhancedServerAuth, handleSSE);
router6.post("/api/mcp/messages", serverIdMiddleware, enhancedServerAuth, handleSSEMessage);
router6.delete("/api/mcp", handleNotAllowed);
var mcp_routes_default = router6;

// src/routes/mirror.routes.ts
var import_express7 = __toESM(require("express"), 1);

// src/controllers/mirror.controller.ts
var import_axios3 = __toESM(require("axios"), 1);
var import_http_status_codes8 = require("http-status-codes");
var import_url = require("url");
async function mirrorRequest(req, res, next) {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const url = req.query.url;
    if (!url) {
      res.status(import_http_status_codes8.StatusCodes.BAD_REQUEST).json({ error: "Invalid URL provided", url });
      return;
    }
    try {
      new import_url.URL(url);
    } catch {
      res.status(import_http_status_codes8.StatusCodes.BAD_REQUEST).json({ error: "Invalid URL provided", url });
      return;
    }
    const response = await import_axios3.default.get(url, {
      headers: {
        Accept: "application/yaml,application/json"
      }
    });
    res.set("Content-Type", response.headers["content-type"] || "application/yaml");
    res.status(200).send(response.data);
  } catch (error) {
    req.logger.debug(error);
    next(error);
  }
}

// src/routes/mirror.routes.ts
var router7 = import_express7.default.Router();
router7.get("/", adminSessionMiddleware, mirrorRequest);
var mirror_routes_default = router7;

// src/routes/oauth.routes.ts
var import_express8 = require("express");

// src/controllers/oauth.controller.ts
var import_axios4 = __toESM(require("axios"), 1);
var crypto5 = __toESM(require("crypto"), 1);
var import_http_status_codes9 = require("http-status-codes");
init_cache_service();

// src/services/enduser.service.ts
var getServerById2 = async (db, serverId) => await db.mcpServer.findUnique({
  where: {
    id: serverId
  }
});
async function createEndUserIfNotExists(db, tenantId, email) {
  return db.endUser.upsert({
    where: {
      email_tenantId: {
        email: email.toLowerCase(),
        tenantId
      }
    },
    update: {},
    create: {
      email: email.toLowerCase(),
      tenantId,
      enabled: true
    }
  });
}
async function setEndUserOwnIdData(db, serverId, email, ownIdData) {
  const server = await getServerById2(db, serverId);
  if (!server) {
    return { status: "NOT_FOUND", error: "Server not found" };
  }
  await db.endUser.upsert({
    where: {
      email_tenantId: {
        email: email.toLowerCase(),
        tenantId: server.tenantId
      }
    },
    update: {
      ownidData: ownIdData
    },
    create: {
      email: email.toLowerCase(),
      tenantId: server.tenantId,
      ownidData: ownIdData,
      enabled: true
    }
  });
  return { status: "NO_CONTENT" };
}
async function getEndUserOwnIdData(db, serverId, email) {
  const server = await getServerById2(db, serverId);
  if (!server) {
    return { status: "NOT_FOUND", error: "Server not found" };
  }
  const user = await db.endUser.findUnique({
    where: {
      email_tenantId: {
        email: email.toLowerCase(),
        tenantId: server.tenantId
      }
    }
  });
  if (!user) {
    return { status: "NO_CONTENT" };
  }
  if (!user.enabled) {
    return { status: "LOCKED", error: "User not enabled" };
  }
  if (user.ownidData) {
    return { status: "OK", data: { ownIdData: user.ownidData } };
  }
  return { status: "NO_CONTENT" };
}
async function createEndUserSession(db, serverId, email, createToken) {
  const server = await getServerById2(db, serverId);
  if (!server) {
    return { status: "NOT_FOUND", error: "Server not found" };
  }
  await db.endUser.upsert({
    where: {
      email_tenantId: {
        email: email.toLowerCase(),
        tenantId: server.tenantId
      }
    },
    update: {},
    create: {
      email: email.toLowerCase(),
      emailVerified: true,
      tenantId: server.tenantId,
      enabled: true
    }
  });
  return { status: "OK", data: { token: await createToken() } };
}
var getEndUserByEmailAndServerId = async (db, email, serverId) => {
  const server = await getServerById2(db, serverId);
  if (!server) {
    return null;
  }
  return await db.endUser.findUnique({
    where: {
      email_tenantId: {
        email: email.toLowerCase(),
        tenantId: server.tenantId
      }
    }
  });
};

// src/controllers/oauth.controller.ts
init_jwt_service();

// src/services/ownid.secret.service.ts
var crypto4 = __toESM(require("crypto"), 1);
init_secrets_service();
var SIGNATURE_EXPIRATION_MSEC = 60 * 1e3;
var adminSharedSecret = async () => process.env.OWNID_ADMIN_SHARED_SECRET || (await getAppSecrets()).ownidAdminSharedSecret;
var enduserSharedSecret = async () => process.env.OWNID_ENDUSER_SHARED_SECRET || (await getAppSecrets()).ownidEnduserSharedSecret;
var signData = (sharedSecret, data) => {
  const hmac = crypto4.createHmac("sha256", Buffer.from(sharedSecret, "base64"));
  hmac.update(data);
  return hmac.digest("base64");
};

// src/controllers/oauth.controller.ts
var CONSOLE_URL = process.env.CONSOLE_URL || "http://localhost:4200";
var CONSOLE_AUTH_PATH = "/login";
var CONSOLE_SUCCESS_PATH = "/oauth/success";
var CONSOLE_FAILURE_PATH = "/oauth/callback";
var STUDIO_REDIRECT_ORIGINS = ["agentpass.ai", "agentpass.studio"];
var ALLOWED_REDIRECT_ORIGINS = ["https://claude.ai", "http://localhost", "http://127.0.0.1", "cursor://"];
var isRedirectUriAllowed = (req, uris) => uris.every(
  (uri) => [...ALLOWED_REDIRECT_ORIGINS, getHostUrl(req, true), getHostUrl(req, false)].some(
    (allowed) => uri.toLowerCase().startsWith(allowed.toLowerCase())
  ) || STUDIO_REDIRECT_ORIGINS.some((url) => new URL(uri).hostname.endsWith(url))
);
var getOAuthServerInfo = async (req, res) => {
  const baseUrl3 = getHostUrl(req, true);
  const issuer = new URL(baseUrl3).origin;
  res.json({
    issuer,
    authorization_endpoint: `${issuer}/api/oauth/authorize`,
    token_endpoint: `${issuer}/api/oauth/token`,
    registration_endpoint: `${issuer}/api/oauth/register`,
    scopes_supported: ["profile", "email", "openid"],
    response_types_supported: ["code"],
    grant_types_supported: ["authorization_code", "refresh_token"],
    token_endpoint_auth_methods_supported: ["client_secret_post"],
    code_challenge_methods_supported: ["S256"]
  });
};
var authorize = async (req, res) => {
  if (!isWithServerIdRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { serverId } = req;
    const { redirect_uri, state: clientState, response_type, client_id, provider_id, admin_auth } = req.query;
    req.logger.debug("OAuth authorization request received", {
      serverId,
      redirect_uri,
      clientState,
      response_type,
      client_id,
      provider_id,
      scope: req.query.scope
    });
    const scope = req.query.scope === TOOL_SCOPE ? TOOL_SCOPE : ENDUSER_SCOPE;
    if (!serverId) {
      req.logger.warn("Server ID not provided in the request");
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error: "Server ID is required" });
    }
    const server = await req.db.mcpServer.findUnique({
      where: {
        id: serverId
      }
    });
    if (!server) {
      return res.status(import_http_status_codes9.StatusCodes.NOT_FOUND).json({ error: `Server '${serverId}' not found` });
    }
    if (!redirect_uri) {
      req.logger.warn("Missing redirect_uri in authorization request");
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error: "redirect_uri is required" });
    }
    if (!isRedirectUriAllowed(req, [redirect_uri])) {
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({
        error: "invalid_redirect_uri",
        error_description: "Redirect URI must be one of the allowed origins"
      });
    }
    let userId = null;
    if (admin_auth) {
      const adminClaims = await verifyAdminToken(admin_auth);
      if (!adminClaims) {
        req.logger.warn("Invalid admin token provided");
        return res.status(import_http_status_codes9.StatusCodes.UNAUTHORIZED).json({ error: "Invalid admin token" });
      }
      userId = (await createEndUserIfNotExists(req.db, server.tenantId, adminClaims.email)).id;
    }
    if (provider_id) {
      const provider = await req.db.oAuthProvider.findFirstOrThrow({
        where: {
          id: provider_id
        }
      });
      const authUrl = getAuthorizeUrl(
        req,
        provider,
        clientState || "",
        serverId,
        userId,
        scope,
        req.ip || null,
        redirect_uri,
        client_id,
        response_type
      );
      req.logger.debug("Redirecting to OAuth provider", {
        provider: provider.name,
        redirectUri: authUrl.toString(),
        originalRedirectUri: redirect_uri,
        clientId: client_id
      });
      return res.redirect(authUrl.toString());
    }
    const stateData = {
      redirectUri: redirect_uri,
      clientState: clientState || "",
      clientId: client_id,
      serverId,
      scope,
      providerId: null,
      originAddress: req.ip || null,
      userId
    };
    const stateParam = encodeData(stateData);
    const consoleUrl = new URL(`${CONSOLE_URL}${CONSOLE_AUTH_PATH}`);
    consoleUrl.searchParams.append("scope", ENDUSER_SCOPE);
    consoleUrl.searchParams.append("state", stateParam);
    consoleUrl.searchParams.append("redirect_uri", callbackUrl(req));
    consoleUrl.searchParams.append("server_id", serverId || "");
    consoleUrl.searchParams.append("server_name", server.name);
    req.logger.debug("Redirecting to console to choose provider", {
      redirectUri: consoleUrl.toString(),
      originalRedirectUri: redirect_uri,
      clientId: client_id
    });
    return res.redirect(consoleUrl.toString());
  } catch (error) {
    req.logger.error("Error in OAuth authorize endpoint", error);
    const message = error instanceof OAuthError ? error.message : "Failed to process authorization request";
    return res.redirect(`${CONSOLE_URL}${CONSOLE_FAILURE_PATH}?error=${encodeURIComponent(message)}`);
  }
};
var handleCallback = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { code, state, error } = req.query;
    if (error) {
      req.logger.error("OAuth callback received with error", error);
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error });
    }
    if (!code) {
      req.logger.error("OAuth callback received without code");
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error: "No code received from OAuth provider" });
    }
    if (!state) {
      req.logger.error("OAuth callback received without state");
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error: "No state received from OAuth provider" });
    }
    let stateData;
    try {
      stateData = decodeData(state);
    } catch (e) {
      req.logger.error("Failed to parse state parameter", e);
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error: "Invalid state parameter" });
    }
    const { redirectUri, clientState, clientId, serverId, scope, providerId } = stateData;
    if (stateData.scope === TOOL_SCOPE && providerId) {
      req.logger.debug("Exchanging code for token with provider for tool scope");
      const provider = await req.db.oAuthProvider.findFirstOrThrow({
        where: {
          id: providerId
        }
      });
      const tokenData = await exchangeCodeForToken(req.logger, provider, code, callbackUrl(req));
      const userId = stateData.userId;
      await persistToken(req.db, req.logger, userId, providerId, tokenData, stateData.originAddress);
      if (stateData.redirectUri) {
        const redirectUrl2 = new URL(stateData.redirectUri);
        redirectUrl2.searchParams.append("state", stateData.clientState);
        return res.redirect(redirectUrl2.toString());
      }
      return res.redirect(`${CONSOLE_URL}${CONSOLE_SUCCESS_PATH}`);
    }
    if (!redirectUri) {
      req.logger.error("State parameter missing redirectUri");
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error: "Invalid state parameter structure" });
    }
    const redirectUrl = new URL(redirectUri);
    redirectUrl.searchParams.append("postAuthRedirectUri", `${CONSOLE_URL}${CONSOLE_SUCCESS_PATH}`);
    if (scope === ENDUSER_SCOPE) {
      const shortSession = decodeData(code);
      const sharedSecret = await enduserSharedSecret();
      if (Math.abs(Date.now() - shortSession.timestamp) > SIGNATURE_EXPIRATION_MSEC || signData(sharedSecret, `${shortSession.email}.${shortSession.timestamp}`) !== shortSession.signature) {
        return res.status(import_http_status_codes9.StatusCodes.UNAUTHORIZED).json({ error: "Invalid or expired short session signature" });
      }
      const jti = crypto5.randomUUID();
      const user = await getEndUserByEmailAndServerId(req.db, shortSession.email, stateData.serverId);
      if (!user) {
        return res.status(import_http_status_codes9.StatusCodes.NOT_FOUND).json({ error: "User not found" });
      }
      const token = await generateEndUserToken(user, jti);
      await persistToken(
        req.db,
        req.logger,
        user.id,
        null,
        {
          accessToken: token,
          scope: ENDUSER_SCOPE,
          expiresIn: null
        },
        stateData.originAddress,
        jti
      );
      clearCacheByPartialKey("enduser_token" /* ENDUSER_TOKEN */, user.email);
      const responseData = {
        access_token: token,
        original_redirect_uri: stateData.redirectUri,
        token_type: "Bearer"
      };
      const tokenAsCode = encodeData(responseData);
      redirectUrl.searchParams.append("code", tokenAsCode);
    } else {
      if (!serverId) {
        req.logger.error("State parameter missing serverId");
        return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({ error: "Invalid state parameter structure" });
      }
      req.logger.debug("OAuth callback received", {
        redirectUri,
        clientState,
        clientId,
        serverId,
        codeReceived: !!code
      });
      redirectUrl.searchParams.append("code", code);
    }
    if (clientState) {
      redirectUrl.searchParams.append("state", clientState);
    }
    if (clientId) {
      redirectUrl.searchParams.append("client_id", clientId);
    }
    return res.redirect(redirectUrl.toString());
  } catch (error) {
    req.logger.error("Error in OAuth callback handling", error);
    const message = error instanceof OAuthError ? error.message : "Failed to process OAuth callback";
    return res.redirect(`${CONSOLE_URL}${CONSOLE_FAILURE_PATH}?error=${encodeURIComponent(message)}`);
  }
};
var exchangeToken = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { code } = req.body;
    if (!code) {
      throw new OAuthError("Missing code", import_http_status_codes9.StatusCodes.BAD_REQUEST, "invalid_request");
    }
    const decodedResponse = decodeData(code);
    return res.json(decodedResponse);
  } catch (error) {
    req.logger.error("Error in token exchange", error);
    if (import_axios4.default.isAxiosError(error) && error.response) {
      return res.status(error.response.status).json(error.response.data);
    }
    return res.status(import_http_status_codes9.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to exchange token" });
  }
};
var dynamicClientRegister = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    req.logger.debug("OAuth client registration request received", {
      body: req.body
    });
    const {
      client_id,
      client_name = "Dynamically Registered Client",
      redirect_uris = [],
      grant_types = ["authorization_code"],
      response_types = ["code"],
      token_endpoint_auth_method = "none",
      software_id
    } = req.body;
    if (!redirect_uris.length) {
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({
        error: "invalid_redirect_uri",
        error_description: "At least one redirect_uri must be provided"
      });
    }
    if (!isRedirectUriAllowed(req, redirect_uris)) {
      return res.status(import_http_status_codes9.StatusCodes.BAD_REQUEST).json({
        error: "invalid_redirect_uri",
        error_description: "Redirect URI must be one of the allowed origins"
      });
    }
    const registrationTime = Date.now();
    const clientId = client_id || crypto5.randomBytes(16).toString("hex");
    const client3 = {
      client_id: clientId,
      client_secret: "",
      // No client secret for public clients
      client_name,
      redirect_uris: Array.isArray(redirect_uris) ? redirect_uris : [redirect_uris],
      grant_types: Array.isArray(grant_types) ? grant_types : [grant_types],
      response_types: Array.isArray(response_types) ? response_types : [response_types],
      token_endpoint_auth_method,
      registration_time: registrationTime
    };
    const response = {
      ...client3,
      client_id_issued_at: Math.floor(registrationTime / 1e3)
    };
    req.logger.debug("New OAuth client registered", {
      clientId,
      clientName: client_name,
      softwareId: software_id
    });
    return res.status(import_http_status_codes9.StatusCodes.CREATED).json(response);
  } catch (error) {
    req.logger.error("Error in registration endpoint", error);
    return res.status(import_http_status_codes9.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to process registration request" });
  }
};

// src/routes/oauth.routes.ts
var router8 = (0, import_express8.Router)();
router8.get("/.well-known/oauth-authorization-server", getOAuthServerInfo);
router8.get("/api/oauth/authorize", serverIdMiddleware, authorize);
router8.post("/api/oauth/token", exchangeToken);
router8.get("/api/oauth/callback", handleCallback);
router8.post("/api/oauth/register", dynamicClientRegister);
var oauth_routes_default = router8;

// src/routes/ownid.routes.ts
var import_express9 = __toESM(require("express"), 1);

// src/controllers/ownid.controller.ts
var import_http_status_codes10 = require("http-status-codes");
var config = (req, res) => {
  const serverId = req.query.server_id;
  const config2 = serverId ? {
    appId: process.env.OWNID_ENDUSER_APP_ID,
    env: process.env.OWNID_ENDUSER_ENV
  } : {
    appId: process.env.OWNID_ADMIN_APP_ID,
    env: process.env.OWNID_ADMIN_ENV
  };
  res.status(import_http_status_codes10.StatusCodes.OK).json(config2);
};
var getServerId = (req) => {
  return req.headers["x-ownid-scope"];
};
var setData = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  const email = req.body.loginId.toLowerCase();
  const ownIdData = req.body.ownIdData;
  const serverId = getServerId(req);
  req.logger.debug("Setting ownid data", {
    email,
    ownIdData,
    serverId
  });
  const result = serverId ? await setEndUserOwnIdData(req.db, serverId, email, ownIdData) : await setAdminOwnIdData(req.db, email, ownIdData);
  if (result.status === "NOT_FOUND") {
    return res.status(import_http_status_codes10.StatusCodes.NOT_FOUND).json({ error: result.error });
  }
  return res.sendStatus(import_http_status_codes10.StatusCodes.NO_CONTENT);
};
var getData = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  const email = req.body.loginId.toLowerCase();
  const serverId = getServerId(req);
  req.logger.debug("Getting ownid data", {
    email,
    serverId
  });
  const result = serverId ? await getEndUserOwnIdData(req.db, serverId, email) : await getAdminOwnIdData(req.db, req.logger, email);
  switch (result.status) {
    case "NOT_FOUND":
      return res.status(import_http_status_codes10.StatusCodes.NOT_FOUND).json({ error: result.error });
    case "LOCKED":
      return res.status(import_http_status_codes10.StatusCodes.LOCKED).json({ error: result.error });
    case "OK":
      return res.status(import_http_status_codes10.StatusCodes.OK).json(result.data);
    case "NO_CONTENT":
      return res.status(import_http_status_codes10.StatusCodes.NO_CONTENT).send();
    default:
      throw new Error(`Unexpected status: ${result.status}`);
  }
};
var createEndUserSessionSignature = async (email) => {
  const sharedSecret = await enduserSharedSecret();
  const timestamp = Date.now();
  const data = {
    timestamp,
    email,
    signature: signData(sharedSecret, `${email}.${timestamp}`)
  };
  return encodeData(data);
};
var createSession = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  const email = req.body.loginId.toLowerCase();
  const serverId = getServerId(req);
  req.logger.debug("Creating session", {
    email,
    serverId
  });
  const result = serverId ? await createEndUserSession(req.db, serverId, email, () => createEndUserSessionSignature(email)) : await createAdminSession(req.db, req.logger, email);
  if (result.status === "NOT_FOUND") {
    return res.status(import_http_status_codes10.StatusCodes.NOT_FOUND).json({ error: result.error });
  }
  return res.json(result.data);
};

// src/middlewares/ownid.middleware.ts
var import_http_status_codes11 = require("http-status-codes");
var ownidMiddleware = (req, res, next, sharedSecret) => {
  const body = JSON.stringify(req.body);
  const ownIdSignature = req.headers["ownid-signature"];
  const ownIdTimestamp = req.headers["ownid-timestamp"];
  if (!ownIdSignature || !ownIdTimestamp) {
    res.status(import_http_status_codes11.StatusCodes.BAD_REQUEST).json({ error: "Missing OwnID signature or timestamp" });
    return;
  }
  const dataToSign = `${body}.${ownIdTimestamp}`;
  const currentTime = Date.now();
  const ownIdTimestampMs = parseInt(ownIdTimestamp);
  if (Math.abs(currentTime - ownIdTimestampMs) > SIGNATURE_EXPIRATION_MSEC) {
    res.status(import_http_status_codes11.StatusCodes.BAD_REQUEST).json({ error: "Signature has expired" });
    return;
  }
  const actualSignature = signData(sharedSecret, dataToSign);
  if (actualSignature !== ownIdSignature) {
    res.status(import_http_status_codes11.StatusCodes.BAD_REQUEST).json({ error: "Invalid signature" });
    return;
  }
  next();
};
var ownidAdminMiddleware = async (req, res, next) => {
  const sharedSecret = await adminSharedSecret();
  return ownidMiddleware(req, res, next, sharedSecret);
};
var ownidEndUserMiddleware = async (req, res, next) => {
  const sharedSecret = await enduserSharedSecret();
  return ownidMiddleware(req, res, next, sharedSecret);
};

// src/routes/ownid.routes.ts
var router9 = import_express9.default.Router();
router9.get("/config", config);
router9.post("/admin/setOwnIDDataByLoginId", ownidAdminMiddleware, setData);
router9.post("/admin/getOwnIDDataByLoginId", ownidAdminMiddleware, getData);
router9.post("/admin/getSessionByLoginId", ownidAdminMiddleware, createSession);
router9.post("/enduser/setOwnIDDataByLoginId", ownidEndUserMiddleware, setData);
router9.post("/enduser/getOwnIDDataByLoginId", ownidEndUserMiddleware, getData);
router9.post("/enduser/getSessionByLoginId", ownidEndUserMiddleware, createSession);
var ownid_routes_default = router9;

// src/routes/providers.routes.ts
var import_express10 = require("express");

// src/controllers/oauth-providers.controller.ts
var import_http_status_codes12 = require("http-status-codes");
var import_omit3 = __toESM(require("lodash/omit.js"), 1);
init_config();
var mapProvider = (provider) => ({
  ...(0, import_omit3.default)(provider, ["clientSecret"]),
  contentType: provider.contentType || void 0,
  refreshUrl: provider.refreshUrl || void 0,
  createdAt: provider.createdAt.toISOString(),
  updatedAt: provider.updatedAt.toISOString()
});
var getProviders = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  const page = req.query.page ? parseInt(req.query.page) : 1;
  const limit = req.query.limit ? parseInt(req.query.limit) : DEFAULT_PAGE_SIZE;
  req.logger.debug("Getting all providers", { query: req.query, tenantId: req.admin.tenantId });
  try {
    const providers = (await req.db.oAuthProvider.findMany({
      skip: (page - 1) * limit,
      take: limit,
      where: {
        tenantId: req.admin.tenantId
      }
    })).map(mapProvider);
    res.json({ data: providers });
  } catch (error) {
    req.logger.error("Failed to get providers", error);
    res.status(import_http_status_codes12.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to get providers" });
  }
};
var createProvider = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Creating new provider", { body: req.body });
  try {
    if (!req.admin.tenantId) {
      return res.status(import_http_status_codes12.StatusCodes.UNAUTHORIZED).json({
        error: "unauthorized",
        errorDescription: "Tenant ID is required"
      });
    }
    const provider = mapProvider(
      await req.db.oAuthProvider.create({
        data: {
          ...req.body,
          clientSecret: req.body.clientSecret || "",
          tenant: { connect: { id: req.admin.tenantId } }
        }
      })
    );
    res.status(import_http_status_codes12.StatusCodes.CREATED).json(provider);
  } catch (error) {
    req.logger.error("Failed to create provider", error);
    res.status(import_http_status_codes12.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to create provider" });
  }
};
var getProvider = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting provider", { providerId: req.params.providerId, tenantId: req.admin.tenantId });
  try {
    const dbProvider = await req.db.oAuthProvider.findUnique({
      where: { id: req.params.providerId, tenantId: req.admin.tenantId }
    });
    const provider = dbProvider ? mapProvider(dbProvider) : null;
    res.json(provider);
  } catch (error) {
    req.logger.error("Failed to get provider", error);
    res.status(import_http_status_codes12.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to get provider" });
  }
};
var updateProvider = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Updating provider", {
    providerId: req.params.providerId,
    body: req.body,
    tenantId: req.admin.tenantId
  });
  try {
    const provider = mapProvider(
      await req.db.oAuthProvider.update({
        where: { id: req.params.providerId, tenantId: req.admin.tenantId },
        data: req.body
      })
    );
    res.json(provider);
  } catch (error) {
    req.logger.error("Failed to update provider", error);
    res.status(import_http_status_codes12.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to update provider" });
  }
};
var deleteProvider = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Deleting provider", { providerId: req.params.providerId, tenantId: req.admin.tenantId });
  try {
    const connectedToolsCount = await req.db.tool.count({
      where: { oAuthProviderId: req.params.providerId }
    });
    if (connectedToolsCount > 0) {
      return res.status(import_http_status_codes12.StatusCodes.BAD_REQUEST).json({
        error: "Cannot delete provider that is connected to tools"
      });
    }
    await req.db.oAuthProvider.delete({
      where: { id: req.params.providerId, tenantId: req.admin.tenantId }
    });
    res.status(import_http_status_codes12.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    req.logger.error("Failed to delete provider", error);
    res.status(import_http_status_codes12.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to delete provider" });
  }
};

// src/routes/providers.routes.ts
var router10 = (0, import_express10.Router)();
router10.get("/", getProviders);
router10.post("/", createProvider);
router10.get("/:providerId", getProvider);
router10.put("/:providerId", updateProvider);
router10.delete("/:providerId", deleteProvider);
var providers_routes_default = router10;

// src/routes/server-auth.routes.ts
var import_express11 = require("express");

// src/controllers/server-auth.controller.ts
var import_http_status_codes13 = require("http-status-codes");
var getServerAuthConfig = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { serverId } = req.params;
    const serverAuthService = new ServerAuthService(req.db, req.logger);
    const config2 = await serverAuthService.getServerAuthConfig(serverId);
    res.json(config2);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    req.logger.error("Failed to get server auth config", { error: errorMessage });
    res.status(import_http_status_codes13.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Internal server error" });
  }
};
var updateServerAuthConfig = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { serverId } = req.params;
    const updateRequest = req.body;
    const serverAuthService = new ServerAuthService(req.db, req.logger);
    const config2 = await serverAuthService.updateServerAuthConfig(serverId, updateRequest);
    res.json(config2);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    req.logger.error("Failed to update server auth config", { error: errorMessage });
    res.status(import_http_status_codes13.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Internal server error" });
  }
};
var getAuthProviders = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { serverId } = req.params;
    const serverAuthService = new ServerAuthService(req.db, req.logger);
    const providers = await serverAuthService.getAuthProviders(serverId);
    res.json(providers);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    req.logger.error("Failed to get auth providers", { error: errorMessage });
    res.status(import_http_status_codes13.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Internal server error" });
  }
};
var createAuthProvider = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { serverId } = req.params;
    const providerData = req.body;
    const serverAuthService = new ServerAuthService(req.db, req.logger);
    const provider = await serverAuthService.createAuthProvider(serverId, providerData);
    res.status(import_http_status_codes13.StatusCodes.CREATED).json(provider);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    req.logger.error("Failed to create auth provider", { error: errorMessage });
    res.status(import_http_status_codes13.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Internal server error" });
  }
};
var updateAuthProvider = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { serverId, providerId } = req.params;
    const providerData = req.body;
    const serverAuthService = new ServerAuthService(req.db, req.logger);
    const provider = await serverAuthService.updateAuthProvider(serverId, providerId, providerData);
    res.json(provider);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    req.logger.error("Failed to update auth provider", { error: errorMessage });
    res.status(import_http_status_codes13.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Internal server error" });
  }
};
var deleteAuthProvider = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { serverId, providerId } = req.params;
    const serverAuthService = new ServerAuthService(req.db, req.logger);
    await serverAuthService.deleteAuthProvider(serverId, providerId);
    res.status(import_http_status_codes13.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    req.logger.error("Failed to delete auth provider", { error: errorMessage });
    res.status(import_http_status_codes13.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Internal server error" });
  }
};
var validateJwksUrl = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    const { jwksUrl } = req.body;
    if (!jwksUrl || typeof jwksUrl !== "string") {
      res.status(import_http_status_codes13.StatusCodes.BAD_REQUEST).json({
        valid: false,
        error: "JWKS URL is required"
      });
      return;
    }
    const serverAuthService = new ServerAuthService(req.db, req.logger);
    const result = await serverAuthService.validateJwksUrl(jwksUrl);
    res.json(result);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    req.logger.error("Failed to validate JWKS URL", { error: errorMessage });
    res.status(import_http_status_codes13.StatusCodes.INTERNAL_SERVER_ERROR).json({
      valid: false,
      error: "Internal server error"
    });
  }
};

// src/routes/server-auth.routes.ts
var router11 = (0, import_express11.Router)();
router11.get("/:serverId/auth", getServerAuthConfig);
router11.put("/:serverId/auth", updateServerAuthConfig);
router11.get("/:serverId/auth-providers", getAuthProviders);
router11.post("/:serverId/auth-providers", createAuthProvider);
router11.put("/:serverId/auth-providers/:providerId", updateAuthProvider);
router11.delete("/:serverId/auth-providers/:providerId", deleteAuthProvider);
router11.post("/validate-jwks", validateJwksUrl);
var server_auth_routes_default = router11;

// src/routes/servers.routes.ts
var import_express12 = require("express");

// src/controllers/servers.controller.ts
var import_http_status_codes14 = require("http-status-codes");
var import_js_yaml = __toESM(require("js-yaml"), 1);
init_servers_service();
init_openapi();
var getServers = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting all servers for tenant", { tenantId: req.admin.tenantId });
  try {
    const servers = await getServersForTenant(req.db, req.admin.tenantId);
    res.json(servers);
  } catch (error) {
    req.logger.error("Failed to get servers", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "server_list_failed",
      errorDescription: "Failed to get servers"
    });
  }
};
var createServer2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    req.logger.info("Creating new server", { body: req.body });
    const server = await createServer(req.db, req.admin.tenantId, {
      name: req.body.name,
      description: req.body.description,
      enabled: req.body.enabled ?? true,
      baseUrl: req.body.baseUrl
    });
    res.status(import_http_status_codes14.StatusCodes.CREATED).json(server);
  } catch (error) {
    req.logger.error("Failed to create server", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to create server"
    });
  }
};
var getServer = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  try {
    req.logger.debug("Getting server", { serverId: req.params.serverId });
    const server = await getServerById(req.db, req.admin.tenantId, req.params.serverId);
    if (!server) {
      return res.status(import_http_status_codes14.StatusCodes.NOT_FOUND).json({
        error: "server_not_found",
        errorDescription: `Server not found: ${req.params.serverId}`
      });
    }
    res.json(server);
  } catch (error) {
    req.logger.error("Failed to get server", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to get server"
    });
  }
};
var updateServer = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Updating server", { serverId: req.params.serverId, body: req.body });
  try {
    const server = await updateServerById(req.db, req.admin.tenantId, req.params.serverId, req.body);
    const { clearCache: clearCache2, clearCacheByPartialKey: clearCacheByPartialKey2 } = await Promise.resolve().then(() => (init_cache_service(), cache_service_exports));
    clearCache2({ type: "server" /* SERVER */, ids: [server.id] });
    clearCacheByPartialKey2("server_access" /* SERVER_ACCESS */, server.id);
    res.json(server);
  } catch (error) {
    req.logger.error("Failed to update server", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to update server"
    });
  }
};
var deleteServer = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Deleting server", { serverId: req.params.serverId });
  const server = await getServerSlim(req.db, req.admin.tenantId, req.params.serverId);
  if (server) {
    await deleteServerById(req.db, req.admin.tenantId, req.params.serverId);
    const { clearCache: clearCache2, clearCacheByPartialKey: clearCacheByPartialKey2 } = await Promise.resolve().then(() => (init_cache_service(), cache_service_exports));
    clearCache2({ type: "server" /* SERVER */, ids: [server.id] });
    clearCacheByPartialKey2("server_access" /* SERVER_ACCESS */, server.id);
    req.logger.debug("Server deleted and caches cleared", { serverId: req.params.serverId });
  }
  res.status(import_http_status_codes14.StatusCodes.NO_CONTENT).send();
};
var createServerFromOpenApi = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Creating server from OpenAPI specification");
  try {
    const fileContent = req.body;
    if (!fileContent || !Buffer.isBuffer(fileContent)) {
      req.logger.warn("OpenAPI specification file is required and must be sent as octet-stream");
      return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json({
        error: "invalid_request",
        errorDescription: "OpenAPI specification file is required and must be sent as octet-stream"
      });
    }
    let openApiContent;
    try {
      const yamlContent = fileContent.toString("utf8");
      if (!yamlContent.trim()) {
        req.logger.warn("OpenAPI content is empty");
        return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json({
          error: "invalid_openapi",
          errorDescription: "OpenAPI content is empty"
        });
      }
      openApiContent = import_js_yaml.default.load(yamlContent);
      if (!("openapi" in openApiContent) || !openApiContent.openapi.startsWith("3")) {
        throw new Error("OpenAPI version is not supported");
      }
    } catch (error) {
      req.logger.error("Failed to parse OpenAPI content", error);
      return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json({
        error: "invalid_openapi",
        errorDescription: "Invalid OpenAPI format"
      });
    }
    const validationError = await validateOpenApiContent(openApiContent);
    if (validationError) {
      req.logger.warn(validationError.errorDescription);
      return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json(validationError);
    }
    req.logger.debug("Parsed OpenAPI content:", openApiContent);
    const tenantId = req.admin.tenantId;
    const selectedTools = req.query.selectedTools ? Array.isArray(req.query.selectedTools) ? req.query.selectedTools : [req.query.selectedTools] : void 0;
    const result = await createServerFromOpenApiSpec(
      req.db,
      tenantId,
      req.query.name,
      req.query.description,
      openApiContent,
      selectedTools
    );
    return res.status(import_http_status_codes14.StatusCodes.CREATED).json(result);
  } catch (error) {
    req.logger.error("Failed to create server from OpenAPI", error);
    return res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "server_creation_failed",
      errorDescription: error instanceof Error ? error.message : "Failed to create server from OpenAPI"
    });
  }
};
var createToolsFromOpenApi = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Creating tools from OpenAPI specification", { serverId: req.params.serverId });
  try {
    const fileContent = req.body;
    if (!fileContent || !Buffer.isBuffer(fileContent)) {
      req.logger.warn("OpenAPI specification file is required and must be sent as octet-stream");
      return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json({
        error: "invalid_request",
        errorDescription: "OpenAPI specification file is required and must be sent as octet-stream"
      });
    }
    let openApiContent;
    try {
      const yamlContent = fileContent.toString("utf8");
      if (!yamlContent.trim()) {
        req.logger.warn("OpenAPI content is empty");
        return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json({
          error: "invalid_openapi",
          errorDescription: "OpenAPI content is empty"
        });
      }
      openApiContent = import_js_yaml.default.load(yamlContent);
      if (!("openapi" in openApiContent) || !openApiContent.openapi.startsWith("3")) {
        throw new Error("OpenAPI version is not supported");
      }
    } catch (error) {
      req.logger.error("Failed to parse OpenAPI content", error);
      return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json({
        error: "invalid_openapi",
        errorDescription: "Invalid OpenAPI format"
      });
    }
    const validationError = await validateOpenApiContent(openApiContent);
    if (validationError) {
      req.logger.warn(validationError.errorDescription);
      return res.status(import_http_status_codes14.StatusCodes.BAD_REQUEST).json(validationError);
    }
    req.logger.debug("Parsed OpenAPI content:", openApiContent);
    const tenantId = req.admin.tenantId;
    const serverId = req.params.serverId;
    const selectedTools = req.query.selectedTools ? Array.isArray(req.query.selectedTools) ? req.query.selectedTools : [req.query.selectedTools] : void 0;
    const result = await createToolsFromOpenApiSpec(
      req.db,
      tenantId,
      serverId,
      openApiContent,
      selectedTools
    );
    return res.status(import_http_status_codes14.StatusCodes.CREATED).json(result);
  } catch (error) {
    req.logger.error("Failed to create tools from OpenAPI", error);
    return res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "tools_creation_failed",
      errorDescription: error instanceof Error ? error.message : "Failed to create tools from OpenAPI"
    });
  }
};
var listTools = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Listing tools", { serverId: req.params.serverId });
  try {
    const tools = await getToolsForServer(
      req.db,
      req.admin.tenantId,
      req.params.serverId,
      req.admin.email
    );
    res.json({ data: tools });
  } catch (error) {
    req.logger.error("Failed to list tools", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to list tools"
    });
  }
};
var createTool2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Creating tool", { serverId: req.params.serverId, body: req.body });
  try {
    const tool2 = await createTool(req.db, req.params.serverId, req.admin.tenantId, req.body);
    res.status(import_http_status_codes14.StatusCodes.CREATED).json(tool2);
  } catch (error) {
    req.logger.error("Error creating tool", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to create tool"
    });
  }
};
var getTool = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting tool", { serverId: req.params.serverId, toolId: req.params.toolId });
  try {
    const tool2 = await getToolById(req.db, req.admin.tenantId, req.params.toolId, req.admin.email);
    res.json(tool2);
  } catch (error) {
    req.logger.error("Failed to get tool", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to get tool"
    });
  }
};
var updateTool = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Updating tool", { serverId: req.params.serverId, toolId: req.params.toolId, body: req.body });
  try {
    const tool2 = await updateToolById(req.db, req.admin.tenantId, req.params.toolId, req.body);
    res.json(tool2);
  } catch (error) {
    req.logger.error("Failed to update tool", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to update tool"
    });
  }
};
var deleteTool = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Deleting tool", { serverId: req.params.serverId, toolId: req.params.toolId });
  try {
    await deleteToolById(req.db, req.admin.tenantId, req.params.toolId);
    res.status(import_http_status_codes14.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    req.logger.error("Failed to delete tool", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to delete tool"
    });
  }
};
var runTool = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  const { serverId, toolId } = req.params;
  const { parameters, authorization } = req.body;
  req.logger.info("Running tool in playground", {
    serverId,
    toolId,
    hasParameters: !!parameters,
    hasAuth: !!authorization
  });
  try {
    const startTime = Date.now();
    const tool2 = await req.db.tool.findUnique({
      where: {
        id: toolId,
        tenantId: req.admin.tenantId,
        serverId
      },
      include: {
        oAuthProvider: true,
        server: {
          select: {
            baseUrl: true
          }
        }
      }
    });
    if (!tool2) {
      return res.status(import_http_status_codes14.StatusCodes.NOT_FOUND).json({
        error: "tool_not_found",
        errorDescription: `Tool not found: ${toolId}`
      });
    }
    const specParameters = tool2.parameters ? JSON.parse(JSON.stringify(tool2.parameters)) : {};
    const callParameters = { ...parameters };
    if (tool2.oAuthProvider) {
      const endUser = await req.db.endUser.findUnique({
        where: {
          email_tenantId: {
            email: req.admin.email,
            tenantId: req.admin.tenantId
          }
        }
      });
      if (!endUser) {
        return res.status(import_http_status_codes14.StatusCodes.UNAUTHORIZED).json({
          error: "unauthorized",
          errorDescription: `No sufficient authorization to run tool: ${toolId}`
        });
      }
      const tokens = await getUserUseableTokens(req.db, endUser.id, tool2.oAuthProvider.id);
      const validTokens = tokens.filter((t) => !t.expiresAt || t.expiresAt > /* @__PURE__ */ new Date());
      if (validTokens.length > 0) {
        callParameters["Authorization"] = `Bearer ${validTokens[0].accessToken}`;
      }
      if (validTokens.length === 0) {
        const tokensWithRefresh = tokens.filter((t) => !!t.refreshToken);
        if (tokensWithRefresh.length > 0) {
          try {
            const tokenData = await refreshAndPersistAccessToken(
              req.db,
              req.logger,
              endUser.id,
              tool2.oAuthProvider,
              tokensWithRefresh[0].refreshToken,
              req.ip || null
            );
            callParameters["Authorization"] = `Bearer ${tokenData.accessToken}`;
          } catch (error) {
            req.logger.warn(`Failed to refresh token for provider ${tool2.oAuthProvider.name}`, error);
            return res.status(import_http_status_codes14.StatusCodes.UNAUTHORIZED).json({
              error: "oauth_authentication_required",
              errorDescription: `OAuth authentication required for ${tool2.name}. Please authenticate via the MCP client.`
            });
          }
        } else {
          return res.status(import_http_status_codes14.StatusCodes.UNAUTHORIZED).json({
            error: "oauth_authentication_required",
            errorDescription: `OAuth authentication required for ${tool2.name}. Please authenticate via the MCP client.`
          });
        }
      }
    }
    const result = await executeApiRequest(
      tool2,
      tool2.server.baseUrl,
      specParameters,
      callParameters,
      req.logger,
      true,
      {}
    );
    const runtimeMs = Date.now() - startTime;
    return res.status(import_http_status_codes14.StatusCodes.OK).json({
      isError: result.isError,
      runtimeMs,
      content: result.content?.filter((res2) => res2.type === "text").map((res2) => res2.text).join("\n") || "<empty>"
    });
  } catch (error) {
    req.logger.error("Failed to run tool", error);
    return res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      isError: true,
      runtimeMs: 0,
      content: "Failed to run tool: " + (error instanceof Error ? error.message : "Unknown error")
    });
  }
};
var createExampleServer = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Creating example todos server", { tenantId: req.admin.tenantId });
  try {
    const result = await createExampleTodosServer(req.db, req.admin.tenantId);
    return res.status(import_http_status_codes14.StatusCodes.CREATED).json(result);
  } catch (error) {
    req.logger.error("Failed to create example server", error);
    return res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "server_creation_failed",
      errorDescription: error instanceof Error ? error.message : "Failed to create example server"
    });
  }
};
var enableTool = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Enabling tool", { serverId: req.params.serverId, toolId: req.params.toolId });
  try {
    const tool2 = await updateToolById(req.db, req.admin.tenantId, req.params.toolId, { enabled: true });
    res.json(tool2);
  } catch (error) {
    req.logger.error("Failed to enable tool", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to enable tool"
    });
  }
};
var disableTool = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Disabling tool", { serverId: req.params.serverId, toolId: req.params.toolId });
  try {
    const tool2 = await updateToolById(req.db, req.admin.tenantId, req.params.toolId, { enabled: false });
    res.json(tool2);
  } catch (error) {
    req.logger.error("Failed to disable tool", error);
    res.status(import_http_status_codes14.StatusCodes.INTERNAL_SERVER_ERROR).json({
      error: "internal_server_error",
      errorDescription: "Failed to disable tool"
    });
  }
};

// src/routes/servers.routes.ts
var router12 = (0, import_express12.Router)();
router12.get("/", getServers);
router12.post("/", createServer2);
router12.get("/:serverId", getServer);
router12.put("/:serverId", updateServer);
router12.delete("/:serverId", deleteServer);
router12.get("/:serverId/tools", listTools);
router12.post("/:serverId/tools", createTool2);
router12.post("/:serverId/tools/import/openapi", createToolsFromOpenApi);
router12.get("/:serverId/tools/:toolId", getTool);
router12.put("/:serverId/tools/:toolId", updateTool);
router12.delete("/:serverId/tools/:toolId", deleteTool);
router12.post("/:serverId/tools/:toolId/run", runTool);
router12.put("/:serverId/tools/:toolId/enable", enableTool);
router12.put("/:serverId/tools/:toolId/disable", disableTool);
router12.post("/import/openapi", createServerFromOpenApi);
router12.post("/example", createExampleServer);
var servers_routes_default = router12;

// src/routes/tenant.routes.ts
var import_express13 = require("express");

// src/controllers/tenant.controller.ts
var import_http_status_codes15 = require("http-status-codes");

// src/services/tenant.service.ts
var import_client4 = require("@prisma/client");
var import_crypto2 = require("crypto");
var import_date_fns = require("date-fns");
var baseUrl2 = process.env.CONSOLE_URL || "http://localhost:4200";
async function getTenantUsers(db, tenantId, currentUserId) {
  const admins = await db.admin.findMany({
    where: { tenantId },
    select: {
      id: true,
      email: true,
      name: true,
      givenName: true,
      familyName: true,
      role: true,
      createdAt: true,
      updatedAt: true
    },
    orderBy: { createdAt: "asc" }
  });
  const users = admins.map((admin) => ({
    id: admin.id,
    email: admin.email,
    name: admin.name || `${admin.givenName || ""} ${admin.familyName || ""}`.trim() || void 0,
    role: admin.role,
    createdAt: admin.createdAt.toISOString(),
    updatedAt: admin.updatedAt.toISOString()
  }));
  if (currentUserId) {
    return users.filter((user) => user.id !== currentUserId);
  }
  return users;
}
async function getTenantInvitations(db, tenantId) {
  const invitations = await db.tenantInvitation.findMany({
    where: { tenantId },
    include: {
      invitedBy: {
        select: {
          id: true,
          email: true,
          name: true
        }
      },
      acceptedBy: {
        select: {
          id: true,
          email: true,
          name: true
        }
      }
    },
    orderBy: { createdAt: "desc" }
  });
  return invitations.map((inv) => ({
    id: inv.id,
    email: inv.email,
    role: inv.role,
    status: inv.status,
    invitedBy: {
      id: inv.invitedBy.id,
      email: inv.invitedBy.email,
      name: inv.invitedBy.name || void 0
    },
    acceptedBy: inv.acceptedBy ? {
      id: inv.acceptedBy.id,
      email: inv.acceptedBy.email,
      name: inv.acceptedBy.name || void 0
    } : void 0,
    expiresAt: inv.expiresAt.toISOString(),
    createdAt: inv.createdAt.toISOString()
  }));
}
async function createInvitation(db, tenantId, email, role, invitedById, logger2) {
  const existingUser = await db.admin.findFirst({
    where: { email, tenantId }
  });
  if (existingUser) {
    throw new Error("User is already a member of this tenant");
  }
  const existingPendingInvitation = await db.tenantInvitation.findFirst({
    where: { email, tenantId, status: import_client4.InvitationStatus.pending }
  });
  if (existingPendingInvitation) {
    throw new Error("User already has a pending invitation");
  }
  const existingCancelledInvitation = await db.tenantInvitation.findFirst({
    where: { email, tenantId, status: import_client4.InvitationStatus.cancelled }
  });
  const inviter = await db.admin.findUnique({
    where: { id: invitedById }
  });
  if (!inviter) {
    throw new Error("Invalid inviter ID");
  }
  const token = (0, import_crypto2.randomBytes)(32).toString("hex");
  const expiresAt = (0, import_date_fns.addDays)(/* @__PURE__ */ new Date(), 7);
  let invitation;
  if (existingCancelledInvitation) {
    invitation = await db.tenantInvitation.update({
      where: { id: existingCancelledInvitation.id },
      data: {
        role,
        invitedById,
        token,
        expiresAt,
        status: import_client4.InvitationStatus.pending,
        acceptedById: null
        // Clear any previous acceptance
      },
      include: {
        invitedBy: {
          select: {
            id: true,
            email: true,
            name: true
          }
        }
      }
    });
  } else {
    invitation = await db.tenantInvitation.create({
      data: {
        tenantId,
        email,
        role,
        invitedById,
        token,
        expiresAt
      },
      include: {
        invitedBy: {
          select: {
            id: true,
            email: true,
            name: true
          }
        }
      }
    });
  }
  const tenant = await db.tenant.findUnique({ where: { id: tenantId } });
  const invitationLink = `${baseUrl2}/invite/${invitation.token}`;
  try {
    await sendTenantInvitationEmail(
      logger2,
      invitation.email,
      inviter?.name || inviter?.email || "Someone",
      tenant?.name || "Tenant",
      invitationLink,
      invitation.role,
      invitation.expiresAt
    );
  } catch (err) {
    logger2.debug("Failed to send tenant invitation email", err);
  }
  return {
    id: invitation.id,
    email: invitation.email,
    role: invitation.role,
    status: invitation.status,
    invitedBy: {
      id: invitation.invitedBy.id,
      email: invitation.invitedBy.email,
      name: invitation.invitedBy.name || void 0
    },
    tenantName: tenant?.name || "Tenant",
    token: invitation.token,
    expiresAt: invitation.expiresAt.toISOString(),
    createdAt: invitation.createdAt.toISOString()
  };
}
async function acceptInvitation(db, token) {
  const invitation = await db.tenantInvitation.findUnique({
    where: { token },
    include: { tenant: true }
  });
  if (!invitation) {
    throw new Error("Invalid invitation token");
  }
  if (invitation.status !== import_client4.InvitationStatus.pending) {
    throw new Error("Invitation is no longer valid");
  }
  if (invitation.expiresAt < /* @__PURE__ */ new Date()) {
    throw new Error("Invitation has expired");
  }
  const existingUser = await db.admin.findFirst({
    where: { email: invitation.email, tenantId: invitation.tenantId }
  });
  if (existingUser) {
    throw new Error("User is already a member of this tenant");
  }
  const userId = crypto.randomUUID();
  const adminRole = invitation.role;
  await db.admin.create({
    data: {
      id: userId,
      tenantId: invitation.tenantId,
      email: invitation.email,
      role: adminRole,
      enabled: true,
      // Auto-enable the user
      emailVerified: true
      // Mark as verified since they came through invitation
    }
  });
  await db.tenantInvitation.update({
    where: { id: invitation.id },
    data: {
      status: import_client4.InvitationStatus.accepted,
      acceptedById: userId
    }
  });
  return {
    tenantId: invitation.tenantId,
    tenantName: invitation.tenant.name,
    role: invitation.role,
    userId
  };
}
async function updateUserRole(db, tenantId, userId, role) {
  const admin = await db.admin.findFirst({
    where: { id: userId, tenantId }
  });
  if (!admin) {
    throw new Error("User is not a member of this tenant");
  }
  const updatedAdmin = await db.admin.update({
    where: { id: userId },
    data: { role }
  });
  return {
    id: updatedAdmin.id,
    email: updatedAdmin.email,
    name: updatedAdmin.name || `${updatedAdmin.givenName || ""} ${updatedAdmin.familyName || ""}`.trim() || void 0,
    role: updatedAdmin.role,
    createdAt: updatedAdmin.createdAt.toISOString(),
    updatedAt: updatedAdmin.updatedAt.toISOString()
  };
}
async function removeUserFromTenant(db, tenantId, userId) {
  const admin = await db.admin.findFirst({
    where: { id: userId, tenantId }
  });
  if (!admin) {
    throw new Error("User is not a member of this tenant");
  }
  await db.admin.delete({ where: { id: userId } });
}
async function cancelInvitation(db, tenantId, invitationId) {
  const invitation = await db.tenantInvitation.findFirst({
    where: { id: invitationId, tenantId }
  });
  if (!invitation) {
    throw new Error("Invitation not found");
  }
  if (invitation.status !== import_client4.InvitationStatus.pending) {
    throw new Error("Cannot cancel non-pending invitation");
  }
  return db.tenantInvitation.update({
    where: { id: invitationId },
    data: { status: import_client4.InvitationStatus.cancelled }
  });
}
async function getUserTenants(db, userId) {
  const adminTenants = await db.admin.findMany({
    where: { id: userId },
    include: {
      tenant: {
        select: {
          id: true,
          name: true,
          description: true
        }
      }
    },
    orderBy: { createdAt: "asc" }
  });
  return adminTenants.map((admin) => ({
    id: admin.tenant.id,
    name: admin.tenant.name,
    description: admin.tenant.description || void 0,
    role: admin.role,
    joinedAt: admin.createdAt.toISOString()
  }));
}
async function getInvitationByToken(db, token) {
  const invitation = await db.tenantInvitation.findUnique({
    where: { token },
    include: {
      tenant: {
        select: {
          id: true,
          name: true
        }
      },
      invitedBy: {
        select: {
          id: true,
          email: true,
          name: true
        }
      }
    }
  });
  if (!invitation) {
    throw new Error("Invalid invitation token");
  }
  if (invitation.status !== import_client4.InvitationStatus.pending) {
    throw new Error("Invitation is no longer valid");
  }
  if (invitation.expiresAt < /* @__PURE__ */ new Date()) {
    throw new Error("Invitation has expired");
  }
  return {
    id: invitation.id,
    email: invitation.email,
    role: invitation.role,
    status: invitation.status,
    tenantName: invitation.tenant.name,
    invitedBy: {
      id: invitation.invitedBy.id,
      email: invitation.invitedBy.email,
      name: invitation.invitedBy.name || void 0
    },
    expiresAt: invitation.expiresAt.toISOString(),
    createdAt: invitation.createdAt.toISOString()
  };
}
async function canManageRoles(db, tenantId, userId) {
  const admin = await db.admin.findFirst({
    where: { id: userId, tenantId }
  });
  if (!admin) {
    return false;
  }
  return admin.role === import_client4.AdminRole.admin || admin.role === import_client4.AdminRole.superadmin;
}
async function canRemoveUsers(db, tenantId, userId) {
  const admin = await db.admin.findFirst({
    where: { id: userId, tenantId }
  });
  if (!admin) {
    return false;
  }
  return admin.role === import_client4.AdminRole.admin || admin.role === import_client4.AdminRole.superadmin;
}
async function canInviteUsers(db, tenantId, userId) {
  const admin = await db.admin.findFirst({
    where: { id: userId, tenantId }
  });
  if (!admin) {
    return false;
  }
  return admin.role === import_client4.AdminRole.admin || admin.role === import_client4.AdminRole.superadmin;
}

// src/controllers/tenant.controller.ts
var getTenantUsers2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting tenant users");
  try {
    const tenantId = req.admin.tenantId;
    const currentUserId = req.admin.id;
    const users = await getTenantUsers(req.db, tenantId, currentUserId);
    res.json(users);
  } catch (error) {
    req.logger.error("Failed to get tenant users", error);
    res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to get tenant users" });
  }
};
var getTenantInvitations2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting tenant invitations");
  try {
    const tenantId = req.admin.tenantId;
    const currentUserId = req.admin.id;
    const canInvite = await canInviteUsers(req.db, tenantId, currentUserId);
    if (!canInvite) {
      return res.status(import_http_status_codes15.StatusCodes.FORBIDDEN).json({
        error: "insufficient_permissions",
        errorDescription: "You don't have permission to view invitations"
      });
    }
    const invitations = await getTenantInvitations(req.db, tenantId);
    res.json(invitations);
  } catch (error) {
    req.logger.error("Failed to get tenant invitations", error);
    res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to get tenant invitations" });
  }
};
var createInvitation2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Creating invitation", { email: req.body.email, role: req.body.role });
  try {
    const tenantId = req.admin.tenantId;
    const currentUserId = req.admin.id;
    const { email, role } = req.body;
    if (!email || !role) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: "Email and role are required" });
      return;
    }
    if (!["admin", "member"].includes(role)) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: "Invalid role" });
      return;
    }
    const canInvite = await canInviteUsers(req.db, tenantId, currentUserId);
    if (!canInvite) {
      return res.status(import_http_status_codes15.StatusCodes.FORBIDDEN).json({
        error: "insufficient_permissions",
        errorDescription: "You don't have permission to invite users"
      });
    }
    const invitation = await createInvitation(req.db, tenantId, email, role, req.admin.id, req.logger);
    res.status(import_http_status_codes15.StatusCodes.CREATED).json(invitation);
  } catch (error) {
    req.logger.error("Failed to create invitation", error);
    if (error instanceof Error) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: error.message });
    } else {
      res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to create invitation" });
    }
  }
};
var getInvitationByToken2 = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting invitation by token");
  try {
    const { token } = req.params;
    if (!token) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: "Token is required" });
      return;
    }
    const invitation = await getInvitationByToken(req.db, token);
    res.json(invitation);
  } catch (error) {
    req.logger.error("Failed to get invitation by token", error);
    if (error instanceof Error) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: error.message });
    } else {
      res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to get invitation" });
    }
  }
};
var acceptInvitation2 = async (req, res) => {
  if (!isAppRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Accepting invitation");
  try {
    const { token } = req.body;
    if (!token) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: "Token is required" });
      return;
    }
    const result = await acceptInvitation(req.db, token);
    res.json(result);
  } catch (error) {
    req.logger.error("Failed to accept invitation", error);
    if (error instanceof Error) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: error.message });
    } else {
      res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to accept invitation" });
    }
  }
};
var updateUserRole2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Updating user role", { userId: req.params.userId, role: req.body.role });
  try {
    const tenantId = req.admin.tenantId;
    const currentUserId = req.admin.id;
    const { userId } = req.params;
    const { role } = req.body;
    if (!role || !["admin", "member", "superadmin"].includes(role)) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: "Valid role is required" });
      return;
    }
    const canManageRoles2 = await canManageRoles(req.db, tenantId, currentUserId);
    if (!canManageRoles2) {
      return res.status(import_http_status_codes15.StatusCodes.FORBIDDEN).json({
        error: "insufficient_permissions",
        errorDescription: "You don't have permission to manage user roles"
      });
    }
    if (currentUserId === userId) {
      return res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({
        error: "invalid_operation",
        errorDescription: "You cannot change your own role"
      });
    }
    const updatedUser = await updateUserRole(req.db, tenantId, userId, role);
    res.json(updatedUser);
  } catch (error) {
    req.logger.error("Failed to update user role", error);
    if (error instanceof Error) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: error.message });
    } else {
      res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to update user role" });
    }
  }
};
var removeUserFromTenant2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Removing user from tenant", { userId: req.params.userId });
  try {
    const tenantId = req.admin.tenantId;
    const currentUserId = req.admin.id;
    const { userId } = req.params;
    const canRemoveUsers2 = await canRemoveUsers(req.db, tenantId, currentUserId);
    if (!canRemoveUsers2) {
      return res.status(import_http_status_codes15.StatusCodes.FORBIDDEN).json({
        error: "insufficient_permissions",
        errorDescription: "You don't have permission to remove users"
      });
    }
    if (currentUserId === userId) {
      return res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({
        error: "invalid_operation",
        errorDescription: "You cannot remove yourself from the tenant"
      });
    }
    await removeUserFromTenant(req.db, tenantId, userId);
    res.status(import_http_status_codes15.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    req.logger.error("Failed to remove user from tenant", error);
    if (error instanceof Error) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: error.message });
    } else {
      res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to remove user from tenant" });
    }
  }
};
var cancelInvitation2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Cancelling invitation", { invitationId: req.params.invitationId });
  try {
    const tenantId = req.admin.tenantId;
    const currentUserId = req.admin.id;
    const { invitationId } = req.params;
    const canInvite = await canInviteUsers(req.db, tenantId, currentUserId);
    if (!canInvite) {
      return res.status(import_http_status_codes15.StatusCodes.FORBIDDEN).json({
        error: "insufficient_permissions",
        errorDescription: "You don't have permission to cancel invitations"
      });
    }
    await cancelInvitation(req.db, tenantId, invitationId);
    res.status(import_http_status_codes15.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    req.logger.error("Failed to cancel invitation", error);
    if (error instanceof Error) {
      res.status(import_http_status_codes15.StatusCodes.BAD_REQUEST).json({ error: error.message });
    } else {
      res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to cancel invitation" });
    }
  }
};
var getUserTenants2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting user tenants");
  try {
    const tenants = await getUserTenants(req.db, req.admin.id);
    res.json(tenants);
  } catch (error) {
    req.logger.error("Failed to get user tenants", error);
    res.status(import_http_status_codes15.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to get user tenants" });
  }
};

// src/middlewares/role.middleware.ts
var import_client5 = require("@prisma/client");
var import_http_status_codes16 = require("http-status-codes");
var requireRole = (requiredRoles) => {
  return (req, res, next) => {
    if (!isAdminRequest(req)) {
      throw new TypeGuardError();
    }
    const userRole = req.admin.role;
    if (!requiredRoles.includes(userRole)) {
      req.logger.warn("Insufficient permissions", {
        userRole,
        requiredRoles,
        userId: req.admin.id,
        path: req.path
      });
      return res.status(import_http_status_codes16.StatusCodes.FORBIDDEN).json({
        error: "insufficient_permissions",
        errorDescription: "You don't have permission to perform this action"
      });
    }
    next();
  };
};
var requireAdmin = requireRole([import_client5.AdminRole.admin, import_client5.AdminRole.superadmin]);
var requireSuperAdmin = requireRole([import_client5.AdminRole.superadmin]);
var requireMember = requireRole([import_client5.AdminRole.admin, import_client5.AdminRole.superadmin]);

// src/routes/tenant.routes.ts
var router13 = (0, import_express13.Router)();
router13.get("/users", adminSessionMiddleware, getTenantUsers2);
router13.get("/invitations", adminSessionMiddleware, requireAdmin, getTenantInvitations2);
router13.post("/invitations", adminSessionMiddleware, requireAdmin, createInvitation2);
router13.put("/users/:userId/role", adminSessionMiddleware, requireAdmin, updateUserRole2);
router13.delete("/users/:userId", adminSessionMiddleware, requireAdmin, removeUserFromTenant2);
router13.delete("/invitations/:invitationId", adminSessionMiddleware, requireAdmin, cancelInvitation2);
router13.get("/invitations/:token", getInvitationByToken2);
router13.post("/invitations/accept", acceptInvitation2);
router13.get("/user/tenants", getUserTenants2);
var tenant_routes_default = router13;

// src/routes/users.routes.ts
var import_express14 = require("express");

// src/controllers/tokens.controller.ts
var import_http_status_codes17 = require("http-status-codes");

// src/services/tokens.service.ts
init_cache_service();
var mapToken = (token) => ({
  id: token.id,
  providerId: token.provider.id,
  providerName: token.provider.name,
  scopes: token.scopes,
  issuedAt: token.issuedAt.toISOString(),
  expiresAt: token.expiresAt ? token.expiresAt.toISOString() : void 0
});
async function listUserTokens(db, userId, tenantId, options) {
  const now = /* @__PURE__ */ new Date();
  const tokens = await db.providerToken.findMany({
    where: {
      userId,
      user: {
        tenantId
      },
      ...options.includeExpired !== true ? { OR: [{ expiresAt: { gte: now } }, { expiresAt: null }] } : {},
      ...options.providerName ? { provider: { name: options.providerName } } : {},
      ...options.scope ? { scopes: { has: options.scope } } : {}
    },
    orderBy: [
      {
        provider: {
          name: "asc"
        }
      },
      {
        id: "asc"
      }
    ],
    include: {
      provider: {
        select: {
          id: true,
          name: true
        }
      }
    }
  });
  return tokens.filter(
    (token) => Boolean(token.provider)
  ).map(mapToken);
}
async function verifyUserExists(db, userId, tenantId) {
  const user = await db.endUser.findUnique({
    where: {
      id: userId,
      tenantId
    }
  });
  return !!user;
}
async function getUserByIdSlim(db, userId, tenantId) {
  return await db.endUser.findUnique({
    where: {
      id: userId,
      tenantId
    },
    select: {
      id: true,
      email: true
    }
  });
}
async function revokeToken(db, tokenId, userId) {
  await db.providerToken.delete({
    where: {
      id: tokenId,
      userId
    }
  });
}
async function deleteUserTokens(db, userId) {
  await db.providerToken.deleteMany({
    where: {
      userId
    }
  });
  return null;
}
async function clearUserTokenCache(email) {
  clearCacheByPartialKey("enduser_token" /* ENDUSER_TOKEN */, email);
}

// src/controllers/tokens.controller.ts
var listUserTokens2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  if (!req.params.userId) {
    res.status(import_http_status_codes17.StatusCodes.BAD_REQUEST).json({ error: "User ID is required" });
    return;
  }
  req.logger.debug("Listing user tokens", {
    userId: req.params.userId,
    query: req.query
  });
  try {
    const tokens = await listUserTokens(req.db, req.params.userId, req.admin.tenantId, {
      includeExpired: req.query.includeExpired === "true",
      providerName: req.query.provider,
      scope: req.query.scope
    });
    res.json(tokens);
  } catch (error) {
    req.logger.error("Failed to list user tokens", error);
    res.status(import_http_status_codes17.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to list user tokens" });
  }
};
var revokeProviderToken = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Revoking provider token", {
    userId: req.params.userId,
    tokenId: req.params.tokenId
  });
  try {
    const userExists = await verifyUserExists(req.db, req.params.userId, req.admin.tenantId);
    if (!userExists) {
      res.status(import_http_status_codes17.StatusCodes.NOT_FOUND).json({ error: "User not found" });
      return;
    }
    await revokeToken(req.db, req.params.tokenId, req.params.userId);
    res.status(import_http_status_codes17.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    req.logger.error("Failed to revoke provider token", error);
    res.status(import_http_status_codes17.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to revoke provider token" });
  }
};
var deleteUserTokens2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Deleting user tokens", { userId: req.params.userId });
  try {
    const user = await getUserByIdSlim(req.db, req.params.userId, req.admin.tenantId);
    if (!user) {
      res.status(import_http_status_codes17.StatusCodes.NOT_FOUND).json({ error: "User not found" });
      return;
    }
    await deleteUserTokens(req.db, req.params.userId);
    clearUserTokenCache(user.email);
    res.status(import_http_status_codes17.StatusCodes.NO_CONTENT).send();
  } catch (error) {
    req.logger.error("Failed to delete user tokens", error);
    res.status(import_http_status_codes17.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to delete user tokens" });
  }
};

// src/controllers/users.controller.ts
var import_http_status_codes18 = require("http-status-codes");
init_cache_service();

// src/services/users.service.ts
init_config();
var mapUser = (user) => ({
  ...user,
  picture: user.picture || void 0,
  createdAt: user.createdAt.toISOString()
});
async function listUsers(db, tenantId, search, page = 1, limit = DEFAULT_PAGE_SIZE) {
  const users = await db.endUser.findMany({
    where: {
      tenantId,
      ...search ? { email: { contains: search, mode: "insensitive" } } : {}
    },
    orderBy: [
      {
        name: "asc"
      },
      {
        id: "asc"
      }
    ],
    take: limit,
    skip: (page - 1) * limit
  });
  const totalUsers = await db.endUser.count({
    where: {
      tenantId,
      ...search ? { email: { contains: search, mode: "insensitive" } } : {}
    }
  });
  const totalPages = Math.ceil(totalUsers / limit);
  return {
    data: users.map(mapUser),
    pagination: {
      totalItems: totalUsers,
      totalPages,
      currentPage: page,
      itemsPerPage: limit
    }
  };
}
async function getUser(db, userId, tenantId) {
  const user = await db.endUser.findUnique({
    where: {
      id: userId,
      tenantId
    }
  });
  return user ? mapUser(user) : null;
}
async function blockUserServerAccess(db, userId, tenantId, blocked) {
  return db.endUser.updateMany({
    where: { id: userId, tenantId },
    data: { enabled: !blocked }
  });
}

// src/utils/qsParsers.ts
var queryToBoolean = (query) => {
  if (query === void 0) {
    return void 0;
  }
  if (typeof query === "boolean") {
    return query;
  }
  if (typeof query === "string") {
    return query.toLowerCase() === "true";
  }
  return void 0;
};

// src/controllers/users.controller.ts
var listUsers2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Listing users", { query: req.query });
  try {
    const tenantId = req.admin.tenantId;
    const page = req.query.page ? parseInt(req.query.page) : 1;
    const limit = req.query.limit ? parseInt(req.query.limit) : 20;
    const result = await listUsers(req.db, tenantId, req.query.search, page, limit);
    res.json(result);
  } catch (error) {
    req.logger.error("Failed to list users", error);
    res.status(import_http_status_codes18.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to list users" });
  }
};
var getUser2 = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.debug("Getting user", { userId: req.params.userId });
  try {
    const tenantId = req.admin.tenantId;
    const user = await getUser(req.db, req.params.userId, tenantId);
    if (!user) {
      res.status(import_http_status_codes18.StatusCodes.NOT_FOUND).json({ error: "User not found" });
      return;
    }
    res.json(user);
  } catch (error) {
    req.logger.error("Failed to get user", error);
    res.status(import_http_status_codes18.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to get user" });
  }
};
var blockUser = async (req, res) => {
  if (!isAdminRequest(req)) {
    throw new TypeGuardError();
  }
  req.logger.info("Blocking user server access", { userId: req.params.userId, block: req.query.block });
  try {
    const tenantId = req.admin.tenantId;
    const blocked = queryToBoolean(req.query.block);
    if (blocked === void 0) {
      res.status(import_http_status_codes18.StatusCodes.BAD_REQUEST).json({ error: "Invalid 'block' parameter. Expected 'true' or 'false'." });
      return;
    }
    await blockUserServerAccess(req.db, req.params.userId, tenantId, blocked);
    clearCacheByType("server_access" /* SERVER_ACCESS */);
    res.status(import_http_status_codes18.StatusCodes.OK).json({ blocked });
  } catch (error) {
    req.logger.error("Failed to block user server access", error);
    res.status(import_http_status_codes18.StatusCodes.INTERNAL_SERVER_ERROR).json({ error: "Failed to block user server access" });
  }
};

// src/routes/users.routes.ts
var router14 = (0, import_express14.Router)();
router14.get("/", listUsers2);
router14.get("/:userId", getUser2);
router14.post("/:userId", blockUser);
router14.get("/:userId/tokens", adminSessionMiddleware, listUserTokens2);
router14.delete("/:userId/tokens", adminSessionMiddleware, deleteUserTokens2);
router14.delete("/:userId/tokens/:tokenId", adminSessionMiddleware, revokeProviderToken);
var users_routes_default = router14;

// src/main.ts
init_logger();
var app = (0, import_express15.default)();
var port = process.env.PORT || 3333;
process.on("SIGINT", async () => {
  await disconnectDatabase();
  process.exit(0);
});
process.on("SIGTERM", async () => {
  await disconnectDatabase();
  process.exit(0);
});
process.on("uncaughtException", async (error) => {
  console.error("server uncaught exception", error);
  await disconnectDatabase();
  process.exit(1);
});
process.on("unhandledRejection", async (reason) => {
  console.error("server unhandled rejection:", reason);
  await disconnectDatabase();
  process.exit(1);
});
app.set("trust proxy", true);
app.use((0, import_cors.default)());
app.use(loggerMiddleware);
app.use(dbMiddleware);
app.use(import_express15.default.json());
app.use(import_express15.default.text());
app.use(import_express15.default.urlencoded({ extended: false }));
app.use(import_express15.default.raw({ type: "application/octet-stream", limit: "50mb" }));
app.use("/api/providers", adminSessionMiddleware, providers_routes_default);
app.use("/api/servers", adminSessionMiddleware, servers_routes_default);
app.use("/api/servers", adminSessionMiddleware, server_auth_routes_default);
app.use("/api/servers", adminSessionMiddleware, analytics_routes_default);
app.use("/api/servers", adminSessionMiddleware, folders_routes_default);
app.use("/api/users", adminSessionMiddleware, users_routes_default);
app.use("/api/tenant", adminSessionMiddleware, tenant_routes_default);
app.use("/api/admins", admins_routes_default);
app.use("/api/ai", ai_routes_default);
app.use(mcp_routes_default);
app.use(oauth_routes_default);
app.use("/api/health", health_routes_default);
app.use("/api/mirror", mirror_routes_default);
app.use("/api/ownid", ownid_routes_default);
app.use((req, res) => {
  if (isAppRequest(req)) {
    req.logger.debug(`404 Not Found: ${req.method} ${req.path}`);
  }
  res.status(import_http_status_codes19.StatusCodes.NOT_FOUND).json({
    error: "Not Found"
  });
});
app.use(errorHandler);
try {
  const server = app.listen(port, () => {
    logger_default.info(`Server is running on port ${port}`);
  });
  server.on("error", (err) => {
    if (err.code === "EADDRINUSE") {
      logger_default.error(`Port ${port} is already in use`);
    } else {
      logger_default.error("Failed to start server:", err);
    }
    process.exit(1);
  });
} catch (e) {
  logger_default.error("Unexpected error during server startup:", e);
  disconnectDatabase().finally(() => process.exit(1));
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vc3JjL3V0aWxzL2NvbmZpZy50cyIsICIuLi8uLi8uLi9zcmMvbG9nZ2VyLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9zZWNyZXRzLnNlcnZpY2UudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL2NhY2hlLnNlcnZpY2UudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL2p3dC5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy91dGlscy9nZW5lcmF0ZVJlcXVlc3RPdmVycmlkZXMudHMiLCAiLi4vLi4vLi4vc3JjL3V0aWxzL2ljb25zLnRzIiwgIi4uLy4uLy4uL3NyYy91dGlscy9vcGVuYXBpLnRzIiwgIi4uLy4uLy4uL3NyYy91dGlscy90b29scy50cyIsICIuLi8uLi8uLi9zcmMvc2VydmljZXMvc2VydmVycy5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy9tYWluLnRzIiwgIi4uLy4uLy4uL3NyYy91dGlscy9jb25uZWN0aW9uLnRzIiwgIi4uLy4uLy4uL3NyYy91dGlscy9sb2dnZXItY2xzLnRzIiwgIi4uLy4uLy4uL3NyYy9taWRkbGV3YXJlcy9kYi5taWRkbGV3YXJlLnRzIiwgIi4uLy4uLy4uL3NyYy9taWRkbGV3YXJlcy9lcnJvci5taWRkbGV3YXJlLnRzIiwgIi4uLy4uLy4uL3NyYy91dGlscy9yZXEtZ3VhcmRzLnRzIiwgIi4uLy4uLy4uL3NyYy9taWRkbGV3YXJlcy9sb2dnZXIubWlkZGxld2FyZS50cyIsICIuLi8uLi8uLi9zcmMvbWlkZGxld2FyZXMvc2Vzc2lvbi5taWRkbGV3YXJlLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9vYXV0aC5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy90eXBlcy9lcnJvci50eXBlcy50cyIsICIuLi8uLi8uLi9zcmMvdXRpbHMvaGFzaC50cyIsICIuLi8uLi8uLi9zcmMvcm91dGVzL2FkbWlucy5yb3V0ZXMudHMiLCAiLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXJzL2FkbWlucy5jb250cm9sbGVyLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9hZG1pbnMuc2VydmljZS50cyIsICIuLi8uLi8uLi8uLi8uLi9saWJzL2FnZW50YnJpZGdlLXV0aWxzL3NyYy9saWIvb3BlbmFwaS9wYXJzZS50cyIsICIuLi8uLi8uLi8uLi8uLi9saWJzL2FnZW50YnJpZGdlLXV0aWxzL3NyYy9hbmFseXRpY3MtZXZlbnRzLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9hbmFseXRpY3Muc2VydmljZS50cyIsICIuLi8uLi8uLi9zcmMvc2VydmljZXMvZW1haWwuc2VydmljZS50cyIsICIuLi8uLi8uLi9zcmMvc2VydmljZXMvZW1haWwuc2VydmljZS50ZW1wbGF0ZXMudHMiLCAiLi4vLi4vLi4vc3JjL3JvdXRlcy9haS5yb3V0ZXMudHMiLCAiLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXJzL2FpLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL2FpLnNlcnZpY2UudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL3Byb21wdHMuc2VydmljZS50cyIsICIuLi8uLi8uLi9zcmMvbWlkZGxld2FyZXMvcmF0ZS1saW1pdC5taWRkbGV3YXJlLnRzIiwgIi4uLy4uLy4uL3NyYy9yb3V0ZXMvYW5hbHl0aWNzLnJvdXRlcy50cyIsICIuLi8uLi8uLi9zcmMvc2VydmljZXMvZGF0YWRvZy5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9hbmFseXRpY3MuY29udHJvbGxlci50cyIsICIuLi8uLi8uLi9zcmMvcm91dGVzL2ZvbGRlcnMucm91dGVzLnRzIiwgIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9mb2xkZXJzLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL2ZvbGRlcnMuc2VydmljZS50cyIsICIuLi8uLi8uLi9zcmMvcm91dGVzL2hlYWx0aC5yb3V0ZXMudHMiLCAiLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXJzL2hlYWx0aC5jb250cm9sbGVyLnRzIiwgIi4uLy4uLy4uL3NyYy9yb3V0ZXMvbWNwLnJvdXRlcy50cyIsICIuLi8uLi8uLi9zcmMvY29udHJvbGxlcnMvbWNwLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL21jcC5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy9jb25zdGFudHMvdG9vbC1wYXJhbWV0ZXJzLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9hcGktZXhlYy9hcGktdG9vbC1leGVjdXRvci50cyIsICIuLi8uLi8uLi9zcmMvdXRpbHMvanNvbi50cyIsICIuLi8uLi8uLi9zcmMvc2VydmljZXMvYXBpLWV4ZWMvcGFyYW1ldGVyLXNjaGVtYS50cyIsICIuLi8uLi8uLi9zcmMvbWlkZGxld2FyZS9zZXJ2ZXItYXV0aC5taWRkbGV3YXJlLnRzIiwgIi4uLy4uLy4uL3NyYy9taWRkbGV3YXJlcy9zZXJ2ZXJJZC5taWRkbGV3YXJlLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9qd3QtYXV0aC5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9tY3AtYWNjZXNzLnNlcnZpY2UudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL3N0cmF0ZWdpZXMvYmFzZS1hdXRoLnN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9zdHJhdGVnaWVzL2p3dC1hdXRoLnN0cmF0ZWd5LnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9mYWN0b3JpZXMvYXV0aC1zdHJhdGVneS5mYWN0b3J5LnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9zZXJ2ZXItYXV0aC5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy9yb3V0ZXMvbWlycm9yLnJvdXRlcy50cyIsICIuLi8uLi8uLi9zcmMvY29udHJvbGxlcnMvbWlycm9yLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL3JvdXRlcy9vYXV0aC5yb3V0ZXMudHMiLCAiLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXJzL29hdXRoLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL2VuZHVzZXIuc2VydmljZS50cyIsICIuLi8uLi8uLi9zcmMvc2VydmljZXMvb3duaWQuc2VjcmV0LnNlcnZpY2UudHMiLCAiLi4vLi4vLi4vc3JjL3JvdXRlcy9vd25pZC5yb3V0ZXMudHMiLCAiLi4vLi4vLi4vc3JjL2NvbnRyb2xsZXJzL293bmlkLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL21pZGRsZXdhcmVzL293bmlkLm1pZGRsZXdhcmUudHMiLCAiLi4vLi4vLi4vc3JjL3JvdXRlcy9wcm92aWRlcnMucm91dGVzLnRzIiwgIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9vYXV0aC1wcm92aWRlcnMuY29udHJvbGxlci50cyIsICIuLi8uLi8uLi9zcmMvcm91dGVzL3NlcnZlci1hdXRoLnJvdXRlcy50cyIsICIuLi8uLi8uLi9zcmMvY29udHJvbGxlcnMvc2VydmVyLWF1dGguY29udHJvbGxlci50cyIsICIuLi8uLi8uLi9zcmMvcm91dGVzL3NlcnZlcnMucm91dGVzLnRzIiwgIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy9zZXJ2ZXJzLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL3JvdXRlcy90ZW5hbnQucm91dGVzLnRzIiwgIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy90ZW5hbnQuY29udHJvbGxlci50cyIsICIuLi8uLi8uLi9zcmMvc2VydmljZXMvdGVuYW50LnNlcnZpY2UudHMiLCAiLi4vLi4vLi4vc3JjL21pZGRsZXdhcmVzL3JvbGUubWlkZGxld2FyZS50cyIsICIuLi8uLi8uLi9zcmMvcm91dGVzL3VzZXJzLnJvdXRlcy50cyIsICIuLi8uLi8uLi9zcmMvY29udHJvbGxlcnMvdG9rZW5zLmNvbnRyb2xsZXIudHMiLCAiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL3Rva2Vucy5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy9jb250cm9sbGVycy91c2Vycy5jb250cm9sbGVyLnRzIiwgIi4uLy4uLy4uL3NyYy9zZXJ2aWNlcy91c2Vycy5zZXJ2aWNlLnRzIiwgIi4uLy4uLy4uL3NyYy91dGlscy9xc1BhcnNlcnMudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCBjb25zdCBpc0xvY2FsUnVuID0gcHJvY2Vzcy5lbnYuSVNfTE9DQUwgPT09IFwidHJ1ZVwiO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9QQUdFX1NJWkUgPSAyMDtcbiIsICJpbXBvcnQgdHJhY2VyIGZyb20gXCJkZC10cmFjZVwiO1xuaW1wb3J0IHdpbnN0b24gZnJvbSBcIndpbnN0b25cIjtcbmltcG9ydCB7IGlzTG9jYWxSdW4gfSBmcm9tIFwiLi91dGlscy9jb25maWcuanNcIjtcblxudHJhY2VyLmluaXQoe1xuICBsb2dJbmplY3Rpb246IHRydWUsXG59KTtcblxuY29uc3QgbG9nZ2VyID0gd2luc3Rvbi5jcmVhdGVMb2dnZXIoe1xuICBsZXZlbDogcHJvY2Vzcy5lbnYuTE9HX0xFVkVMIHx8IFwiaW5mb1wiLFxuICBmb3JtYXQ6IHdpbnN0b24uZm9ybWF0LmNvbWJpbmUoXG4gICAgd2luc3Rvbi5mb3JtYXQudGltZXN0YW1wKCksXG4gICAgd2luc3Rvbi5mb3JtYXQuanNvbigpLFxuICAgIHdpbnN0b24uZm9ybWF0LmVycm9ycyh7IHN0YWNrOiB0cnVlIH0pLFxuICApLFxuICB0cmFuc3BvcnRzOiBbXG4gICAgbmV3IHdpbnN0b24udHJhbnNwb3J0cy5Db25zb2xlKHtcbiAgICAgIGZvcm1hdDogaXNMb2NhbFJ1biA/IHdpbnN0b24uZm9ybWF0LmNvbWJpbmUod2luc3Rvbi5mb3JtYXQuY29sb3JpemUoKSwgd2luc3Rvbi5mb3JtYXQuc2ltcGxlKCkpIDogdW5kZWZpbmVkLFxuICAgIH0pLFxuICBdLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2dlcjtcbiIsICJpbXBvcnQge1xuICBHZXRTZWNyZXRWYWx1ZUNvbW1hbmQsXG4gIEdldFNlY3JldFZhbHVlQ29tbWFuZElucHV0LFxuICBTZWNyZXRzTWFuYWdlckNsaWVudCxcbn0gZnJvbSBcIkBhd3Mtc2RrL2NsaWVudC1zZWNyZXRzLW1hbmFnZXJcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWltcG9ydHNcbmltcG9ydCBsb2dnZXIgZnJvbSBcIi4uL2xvZ2dlci5qc1wiO1xuXG5jb25zdCBlbnZpcm9ubWVudCA9IHByb2Nlc3MuZW52LkVOViB8fCBcImRldlwiO1xuY29uc3Qgc2VjcmV0TmFtZSA9IGBhZ2VudGJyaWRnZS0ke2Vudmlyb25tZW50fS1zZWNyZXRzYDtcblxuY29uc3QgY2xpZW50ID0gbmV3IFNlY3JldHNNYW5hZ2VyQ2xpZW50KHtcbiAgcmVnaW9uOiBwcm9jZXNzLmVudi5BV1NfU0VDUkVUU19SRUdJT04gfHwgXCJ1cy1lYXN0LTJcIixcbn0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFwcFNlY3JldHMge1xuICBqd3RTZWNyZXQ6IHN0cmluZztcbiAgZGJFbmNyeXB0aW9uS2V5OiBzdHJpbmc7XG4gIGRhdGFkb2dBcGlLZXk6IHN0cmluZztcbiAgZGF0YWRvZ0FwcEtleTogc3RyaW5nO1xuICBzbXRwSG9zdDogc3RyaW5nO1xuICBzbXRwUG9ydDogc3RyaW5nO1xuICBzbXRwVXNlcm5hbWU6IHN0cmluZztcbiAgc210cFBhc3N3b3JkOiBzdHJpbmc7XG4gIG93bmlkQWRtaW5TaGFyZWRTZWNyZXQ6IHN0cmluZztcbiAgb3duaWRFbmR1c2VyU2hhcmVkU2VjcmV0OiBzdHJpbmc7XG4gIGFudGhyb3BpY0FwaUtleTogc3RyaW5nO1xuICBvcGVuYWlBcGlLZXk6IHN0cmluZztcbn1cblxuY29uc3QgYXBwU2VjcmV0czogUHJvbWlzZTxBcHBTZWNyZXRzPiA9IChhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgaW5wdXQ6IEdldFNlY3JldFZhbHVlQ29tbWFuZElucHV0ID0ge1xuICAgICAgU2VjcmV0SWQ6IHNlY3JldE5hbWUsXG4gICAgfTtcblxuICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgR2V0U2VjcmV0VmFsdWVDb21tYW5kKGlucHV0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kKGNvbW1hbmQpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5TZWNyZXRTdHJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VjcmV0ICR7c2VjcmV0TmFtZX0gdmFsdWUgaXMgZW1wdHlgKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IEpTT04ucGFyc2UocmVzcG9uc2UuU2VjcmV0U3RyaW5nKSBhcyBBcHBTZWNyZXRzO1xuICAgIGxvZ2dlci5kZWJ1ZyhgU3VjY2Vzc2Z1bGx5IGxvYWRlZCBzZWNyZXRzIGZyb20gQVdTIFNlY3JldHMgTWFuYWdlciBmb3IgZW52aXJvbm1lbnQ6ICR7ZW52aXJvbm1lbnR9YCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHJldHJpZXZlIHNlY3JldHMgZnJvbSBBV1MgU2VjcmV0cyBNYW5hZ2VyYCwgZXJyb3IpO1xuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfVxufSkoKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFwcFNlY3JldHMoKTogUHJvbWlzZTxBcHBTZWNyZXRzPiB7XG4gIHJldHVybiBhd2FpdCBhcHBTZWNyZXRzO1xufVxuIiwgImltcG9ydCBOb2RlQ2FjaGUgZnJvbSBcIm5vZGUtY2FjaGVcIjtcblxuZXhwb3J0IGVudW0gQ2FjaGVJdGVtVHlwZSB7XG4gIFNFUlZFUl9BQ0NFU1MgPSBcInNlcnZlcl9hY2Nlc3NcIixcbiAgU0VSVkVSID0gXCJzZXJ2ZXJcIixcbiAgRU5EVVNFUl9UT0tFTiA9IFwiZW5kdXNlcl90b2tlblwiLFxufVxuXG5pbnRlcmZhY2UgQ2FjaGVJdGVtPFQ+IHtcbiAgdmFsdWU6IFQ7XG4gIHR5cGU6IENhY2hlSXRlbVR5cGU7XG59XG5cbmludGVyZmFjZSBDYWNoZVRUTENvbmZpZyB7XG4gIFtrZXk6IHN0cmluZ106IG51bWJlcjtcbn1cblxuY29uc3QgVFRMX0NPTkZJRzogQ2FjaGVUVExDb25maWcgPSB7XG4gIFtDYWNoZUl0ZW1UeXBlLlNFUlZFUl9BQ0NFU1NdOiAzMDAsIC8vIDUgbWludXRlc1xuICBbQ2FjaGVJdGVtVHlwZS5TRVJWRVJdOiAxMjAsIC8vIDIgbWludXRlc1xuICBbQ2FjaGVJdGVtVHlwZS5FTkRVU0VSX1RPS0VOXTogMzAwLCAvLyA1IG1pbnV0ZXNcbn07XG5cbmV4cG9ydCBjb25zdCBjYWNoZSA9IG5ldyBOb2RlQ2FjaGUoe1xuICBjaGVja3BlcmlvZDogMzAsXG59KTtcblxudHlwZSBDYWNoZUtleSA9IHtcbiAgdHlwZTogQ2FjaGVJdGVtVHlwZTtcbiAgaWRzOiBzdHJpbmdbXTtcbn07XG5cbmNvbnN0IGtleVRvU3RyaW5nID0gKGtleTogQ2FjaGVLZXkpOiBzdHJpbmcgPT4gYCR7a2V5LnR5cGV9Ojoke2tleS5pZHMuam9pbihcIjpcIil9YDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhY2hlR2V0T3JBZGQ8VD4oa2V5OiBDYWNoZUtleSwgZmV0Y2hGbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICBjb25zdCBrZXlTdHJpbmcgPSBrZXlUb1N0cmluZyhrZXkpO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQ8Q2FjaGVJdGVtPFQ+PihrZXlTdHJpbmcpO1xuXG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkLnZhbHVlO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBmZXRjaEZuKCk7XG4gIGNvbnN0IHR0bCA9IFRUTF9DT05GSUdba2V5LnR5cGVdO1xuXG4gIGNhY2hlLnNldChrZXlTdHJpbmcsIHsgdmFsdWUgfSwgdHRsKTtcblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhY2hlKGtleTogQ2FjaGVLZXkpOiBib29sZWFuIHtcbiAgY29uc3Qga2V5U3RyaW5nID0ga2V5VG9TdHJpbmcoa2V5KTtcbiAgcmV0dXJuIGNhY2hlLmRlbChrZXlTdHJpbmcpID4gMDtcbn1cblxuY29uc3QgY2xlYXJDYWNoZUJ5S2V5UHJlZml4ID0gKGtleVN0cmluZzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGtleXMgPSBjYWNoZS5rZXlzKCk7XG4gIGNvbnN0IG1hdGNoaW5nS2V5cyA9IGtleXMuZmlsdGVyKChrZXkpID0+IGtleS5zdGFydHNXaXRoKGtleVN0cmluZykpO1xuXG4gIGlmIChtYXRjaGluZ0tleXMubGVuZ3RoID4gMCkge1xuICAgIGNhY2hlLmRlbChtYXRjaGluZ0tleXMpO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYWNoZUJ5VHlwZSh0eXBlOiBDYWNoZUl0ZW1UeXBlKTogdm9pZCB7XG4gIGNsZWFyQ2FjaGVCeUtleVByZWZpeChgJHt0eXBlfTo6YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhY2hlQnlQYXJ0aWFsS2V5KHR5cGU6IENhY2hlSXRlbVR5cGUsIGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgY2xlYXJDYWNoZUJ5S2V5UHJlZml4KGtleVRvU3RyaW5nKHsgdHlwZSwgaWRzOiBbaWRdIH0pKTtcbn1cbiIsICJpbXBvcnQgeyBBZG1pbiwgQWRtaW5Sb2xlLCBFbmRVc2VyIH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgand0LCB7IEp3dFBheWxvYWQsIFNlY3JldCwgU2lnbk9wdGlvbnMgfSBmcm9tIFwianNvbndlYnRva2VuXCI7XG5pbXBvcnQgeyBBZG1pblZlcmlmaWNhdGlvblBheWxvYWQgfSBmcm9tIFwiLi4vdHlwZXMvYWRtaW4udHlwZXMuanNcIjtcbmltcG9ydCB7IGdldEFwcFNlY3JldHMgfSBmcm9tIFwiLi9zZWNyZXRzLnNlcnZpY2UuanNcIjtcblxuY29uc3QgSldUX1NFQ1JFVDogUHJvbWlzZTxTZWNyZXQ+ID0gKGFzeW5jICgpID0+IChhd2FpdCBnZXRBcHBTZWNyZXRzKCkpLmp3dFNlY3JldCkoKTtcbmNvbnN0IEpXVF9FWFBJUkVTX0lOID0gcHJvY2Vzcy5lbnYuSldUX0VYUElSRVNfSU4gfHwgXCIyZFwiO1xuY29uc3QgVkVSSUZJQ0FUSU9OX1RPS0VOX0VYUElSRVNfSU4gPSBwcm9jZXNzLmVudi5KV1RfRVhQSVJFU19JTiB8fCBcIjE0ZFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFkbWluQ2xhaW1zIGV4dGVuZHMgSnd0UGF5bG9hZCB7XG4gIGlkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHRlbmFudElkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gIGFkbWluOiB0cnVlO1xuICBwaWN0dXJlOiBzdHJpbmcgfCBudWxsO1xuICByb2xlOiBBZG1pblJvbGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW5kVXNlckNsYWltcyBleHRlbmRzIEp3dFBheWxvYWQge1xuICBpZDogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICB0ZW5hbnRJZDogc3RyaW5nO1xuICBlbmRVc2VyOiB0cnVlO1xufVxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVBZG1pblRva2VuID0gYXN5bmMgKGFkbWluOiBBZG1pbik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IHBheWxvYWQ6IEFkbWluQ2xhaW1zID0ge1xuICAgIGlkOiBhZG1pbi5pZCxcbiAgICBlbWFpbDogYWRtaW4uZW1haWwsXG4gICAgdGVuYW50SWQ6IGFkbWluLnRlbmFudElkLFxuICAgIHBpY3R1cmU6IGFkbWluLnBpY3R1cmUsXG4gICAgbmFtZTogYWRtaW4ubmFtZSxcbiAgICBhZG1pbjogdHJ1ZSxcbiAgICByb2xlOiBhZG1pbi5yb2xlLFxuICB9O1xuXG4gIGNvbnN0IG9wdGlvbnM6IFNpZ25PcHRpb25zID0ge1xuICAgIGV4cGlyZXNJbjogSldUX0VYUElSRVNfSU4gYXMgU2lnbk9wdGlvbnNbXCJleHBpcmVzSW5cIl0sXG4gICAgc3ViamVjdDogYWRtaW4uZW1haWwsXG4gIH07XG5cbiAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIGF3YWl0IEpXVF9TRUNSRVQsIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlRW5kVXNlclRva2VuID0gYXN5bmMgKHVzZXI6IEVuZFVzZXIsIGp0aTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgcGF5bG9hZDogRW5kVXNlckNsYWltcyA9IHtcbiAgICBpZDogdXNlci5pZCxcbiAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICB0ZW5hbnRJZDogdXNlci50ZW5hbnRJZCxcbiAgICBlbmRVc2VyOiB0cnVlLFxuICAgIGp0aSxcbiAgfTtcblxuICBjb25zdCBvcHRpb25zOiBTaWduT3B0aW9ucyA9IHtcbiAgICBzdWJqZWN0OiB1c2VyLmVtYWlsLFxuICB9O1xuXG4gIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhd2FpdCBKV1RfU0VDUkVULCBvcHRpb25zKTtcbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlBZG1pblRva2VuID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPEFkbWluQ2xhaW1zIHwgbnVsbD4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBqd3QudmVyaWZ5KHRva2VuLCBhd2FpdCBKV1RfU0VDUkVUKSBhcyBBZG1pbkNsYWltcztcbiAgICBpZiAoIWRlY29kZWQuYWRtaW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlFbmRVc2VyVG9rZW4gPSBhc3luYyAodG9rZW46IHN0cmluZyk6IFByb21pc2U8RW5kVXNlckNsYWltcyB8IG51bGw+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gand0LnZlcmlmeSh0b2tlbiwgYXdhaXQgSldUX1NFQ1JFVCwgeyBpZ25vcmVFeHBpcmF0aW9uOiB0cnVlIH0pIGFzIEVuZFVzZXJDbGFpbXM7XG4gICAgaWYgKCFkZWNvZGVkLmVuZFVzZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUFkbWluVmVyaWZpY2F0aW9uVG9rZW4oaWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHBheWxvYWQ6IEFkbWluVmVyaWZpY2F0aW9uUGF5bG9hZCA9IHtcbiAgICBpZCxcbiAgICBhY3Rpb246IFwidmVyaWZ5XCIsXG4gIH07XG5cbiAgY29uc3Qgb3B0aW9uczogU2lnbk9wdGlvbnMgPSB7XG4gICAgZXhwaXJlc0luOiBWRVJJRklDQVRJT05fVE9LRU5fRVhQSVJFU19JTiBhcyBTaWduT3B0aW9uc1tcImV4cGlyZXNJblwiXSxcbiAgICBhdWRpZW5jZTogaWQsXG4gIH07XG5cbiAgcmV0dXJuIGp3dC5zaWduKHBheWxvYWQsIGF3YWl0IEpXVF9TRUNSRVQsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QWRtaW5WZXJpZmljYXRpb25Ub2tlbih0b2tlbjogc3RyaW5nKTogUHJvbWlzZTx7IGlkOiBzdHJpbmcgfSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gand0LnZlcmlmeSh0b2tlbiwgYXdhaXQgSldUX1NFQ1JFVCkgYXMgQWRtaW5WZXJpZmljYXRpb25QYXlsb2FkO1xuICAgIGlmIChkZWNvZGVkLmFjdGlvbiAhPT0gXCJ2ZXJpZnlcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IGlkOiBkZWNvZGVkLmlkIH07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgUGFyYW1ldGVyIH0gZnJvbSBcIkBhZ2VudGJyaWRnZS9hcGlcIjtcbmltcG9ydCB7IE9wZW5BUElWMyB9IGZyb20gXCJvcGVuYXBpLXR5cGVzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSHR0cFJlcXVlc3RPdmVycmlkZXMge1xuICBxdWVyeT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBwYXRoPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgYm9keT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgc3RyaW5nO1xuICBib2R5Rm9ybWF0Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBIVFRQIHJlcXVlc3Qgb3ZlcnJpZGVzIGZyb20gT3BlbkFQSSBvcGVyYXRpb24gYW5kIHBhdGggaXRlbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSZXF1ZXN0T3ZlcnJpZGVzRnJvbU9wZXJhdGlvbihcbiAgb3BlcmF0aW9uOiBPcGVuQVBJVjMuT3BlcmF0aW9uT2JqZWN0LFxuICBwYXRoSXRlbTogT3BlbkFQSVYzLlBhdGhJdGVtT2JqZWN0LFxuKTogSHR0cFJlcXVlc3RPdmVycmlkZXMge1xuICBjb25zdCBvdmVycmlkZXM6IEh0dHBSZXF1ZXN0T3ZlcnJpZGVzID0ge307XG4gIGNvbnN0IHF1ZXJ5UGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGNvbnN0IGhlYWRlclBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBjb25zdCBwYXRoUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgLy8gQ29tYmluZSBwYXRoLWxldmVsIGFuZCBvcGVyYXRpb24tbGV2ZWwgcGFyYW1ldGVyc1xuICBjb25zdCBhbGxQYXJhbWV0ZXJzID0gWy4uLihwYXRoSXRlbS5wYXJhbWV0ZXJzIHx8IFtdKSwgLi4uKG9wZXJhdGlvbi5wYXJhbWV0ZXJzIHx8IFtdKV07XG5cbiAgLy8gUHJvY2VzcyBwYXJhbWV0ZXJzXG4gIGFsbFBhcmFtZXRlcnMuZm9yRWFjaCgocGFyYW0pID0+IHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcIm9iamVjdFwiICYmIFwibmFtZVwiIGluIHBhcmFtKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXIgPSBwYXJhbSBhcyBPcGVuQVBJVjMuUGFyYW1ldGVyT2JqZWN0O1xuICAgICAgY29uc3QgdGVtcGxhdGUgPSBge3t0b29sUGFyYW1zLiR7cGFyYW1ldGVyLm5hbWV9fX1gO1xuXG4gICAgICBzd2l0Y2ggKHBhcmFtZXRlci5pbikge1xuICAgICAgICBjYXNlIFwicXVlcnlcIjpcbiAgICAgICAgICBxdWVyeVBhcmFtc1twYXJhbWV0ZXIubmFtZV0gPSB0ZW1wbGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhlYWRlclwiOlxuICAgICAgICAgIGhlYWRlclBhcmFtc1twYXJhbWV0ZXIubmFtZV0gPSB0ZW1wbGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgICBwYXRoUGFyYW1zW3BhcmFtZXRlci5uYW1lXSA9IHRlbXBsYXRlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gUHJvY2VzcyByZXF1ZXN0IGJvZHlcbiAgaWYgKG9wZXJhdGlvbi5yZXF1ZXN0Qm9keSAmJiB0eXBlb2Ygb3BlcmF0aW9uLnJlcXVlc3RCb2R5ID09PSBcIm9iamVjdFwiICYmIFwiY29udGVudFwiIGluIG9wZXJhdGlvbi5yZXF1ZXN0Qm9keSkge1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gb3BlcmF0aW9uLnJlcXVlc3RCb2R5IGFzIE9wZW5BUElWMy5SZXF1ZXN0Qm9keU9iamVjdDtcbiAgICBjb25zdCBqc29uQ29udGVudCA9IHJlcXVlc3RCb2R5LmNvbnRlbnQ/LltcImFwcGxpY2F0aW9uL2pzb25cIl07XG5cbiAgICBpZiAoanNvbkNvbnRlbnQ/LnNjaGVtYSkge1xuICAgICAgY29uc3Qgc2NoZW1hID0ganNvbkNvbnRlbnQuc2NoZW1hIGFzIE9wZW5BUElWMy5TY2hlbWFPYmplY3Q7XG5cbiAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICBjb25zdCBib2R5U3RydWN0dXJlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5mb3JFYWNoKChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgIGJvZHlTdHJ1Y3R1cmVbcHJvcE5hbWVdID0gYHt7dG9vbFBhcmFtcy5ib2R5LiR7cHJvcE5hbWV9fX1gO1xuICAgICAgICB9KTtcbiAgICAgICAgb3ZlcnJpZGVzLmJvZHkgPSBib2R5U3RydWN0dXJlO1xuICAgICAgICBvdmVycmlkZXMuYm9keUZvcm1hdCA9IFwianNvblwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2ltcGxlIGJvZHkgd2l0aG91dCBwcm9wZXJ0aWVzXG4gICAgICAgIG92ZXJyaWRlcy5ib2R5ID0gXCJ7e3Rvb2xQYXJhbXMuYm9keX19XCI7XG4gICAgICAgIG92ZXJyaWRlcy5ib2R5Rm9ybWF0ID0gXCJqc29uXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBhZGQgc2VjdGlvbnMgdGhhdCBoYXZlIHBhcmFtZXRlcnNcbiAgaWYgKE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgb3ZlcnJpZGVzLnF1ZXJ5ID0gcXVlcnlQYXJhbXM7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoaGVhZGVyUGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgb3ZlcnJpZGVzLmhlYWRlcnMgPSBoZWFkZXJQYXJhbXM7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocGF0aFBhcmFtcykubGVuZ3RoID4gMCkge1xuICAgIG92ZXJyaWRlcy5wYXRoID0gcGF0aFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiBvdmVycmlkZXM7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIEhUVFAgcmVxdWVzdCBvdmVycmlkZXMgZnJvbSB0b29sIHBhcmFtZXRlcnMgKGZvciBjb25zaXN0ZW5jeSB3aXRoIGZyb250ZW5kKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSZXF1ZXN0T3ZlcnJpZGVzKHBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIFBhcmFtZXRlcj4pOiBIdHRwUmVxdWVzdE92ZXJyaWRlcyB7XG4gIGNvbnN0IG92ZXJyaWRlczogSHR0cFJlcXVlc3RPdmVycmlkZXMgPSB7fTtcbiAgY29uc3QgcXVlcnlQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgY29uc3QgaGVhZGVyUGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGNvbnN0IHBhdGhQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgbGV0IGhhc0JvZHlQYXJhbSA9IGZhbHNlO1xuICBjb25zdCBib2R5U3RydWN0dXJlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgcGFyYW1dIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtZXRlcnMpKSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBge3t0b29sUGFyYW1zLiR7bmFtZX19fWA7XG5cbiAgICBzd2l0Y2ggKHBhcmFtLmluKSB7XG4gICAgICBjYXNlIFwicXVlcnlcIjpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOiAvLyBEZWZhdWx0IHRvIHF1ZXJ5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgIHF1ZXJ5UGFyYW1zW25hbWVdID0gdGVtcGxhdGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiaGVhZGVyXCI6XG4gICAgICAgIGhlYWRlclBhcmFtc1tuYW1lXSA9IHRlbXBsYXRlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInBhdGhcIjpcbiAgICAgICAgcGF0aFBhcmFtc1tuYW1lXSA9IHRlbXBsYXRlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgaGFzQm9keVBhcmFtID0gdHJ1ZTtcbiAgICAgICAgaWYgKHBhcmFtLnNjaGVtYT8ucHJvcGVydGllcykge1xuICAgICAgICAgIC8vIEdlbmVyYXRlIGJvZHkgc3RydWN0dXJlIGZyb20gc2NoZW1hXG4gICAgICAgICAgT2JqZWN0LmtleXMocGFyYW0uc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goKHByb3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBib2R5U3RydWN0dXJlW3Byb3BOYW1lXSA9IGB7e3Rvb2xQYXJhbXMuJHtuYW1lfS4ke3Byb3BOYW1lfX19YDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW1wbGUgYm9keSBwYXJhbWV0ZXIgLSBjcmVhdGUgcHJvcGVyIEpTT04gb2JqZWN0IHN0cnVjdHVyZVxuICAgICAgICAgIGJvZHlTdHJ1Y3R1cmVbbmFtZV0gPSBge3t0b29sUGFyYW1zLiR7bmFtZX19fWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBhZGQgc2VjdGlvbnMgdGhhdCBoYXZlIHBhcmFtZXRlcnNcbiAgaWYgKE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgb3ZlcnJpZGVzLnF1ZXJ5ID0gcXVlcnlQYXJhbXM7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoaGVhZGVyUGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgb3ZlcnJpZGVzLmhlYWRlcnMgPSBoZWFkZXJQYXJhbXM7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocGF0aFBhcmFtcykubGVuZ3RoID4gMCkge1xuICAgIG92ZXJyaWRlcy5wYXRoID0gcGF0aFBhcmFtcztcbiAgfVxuXG4gIGlmIChoYXNCb2R5UGFyYW0pIHtcbiAgICBvdmVycmlkZXMuYm9keSA9IGJvZHlTdHJ1Y3R1cmU7XG4gICAgb3ZlcnJpZGVzLmJvZHlGb3JtYXQgPSBcImpzb25cIjtcbiAgfVxuXG4gIHJldHVybiBvdmVycmlkZXM7XG59XG4iLCAidHlwZSBJY29uTmFtZSA9IFwiZ29vZ2xlXCIgfCBcIm9hdXRoR2VuZXJpY1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0SWNvbiA9IChuYW1lOiBJY29uTmFtZSkgPT4ge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFwiZ29vZ2xlXCI6XG4gICAgICByZXR1cm4gYDxzdmcgdmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDQ4IDQ4XCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIj48cGF0aCBmaWxsPVwiI0VBNDMzNVwiIGQ9XCJNMjQgOS41YzMuNTQgMCA2LjcxIDEuMjIgOS4yMSAzLjZsNi44NS02Ljg1QzM1LjkgMi4zOCAzMC40NyAwIDI0IDAgMTQuNjIgMCA2LjUxIDUuMzggMi41NiAxMy4yMmw3Ljk4IDYuMTlDMTIuNDMgMTMuNzIgMTcuNzQgOS41IDI0IDkuNXpcIj48L3BhdGg+PHBhdGggZmlsbD1cIiM0Mjg1RjRcIiBkPVwiTTQ2Ljk4IDI0LjU1YzAtMS41Ny0uMTUtMy4wOS0uMzgtNC41NUgyNHY5LjAyaDEyLjk0Yy0uNTggMi45Ni0yLjI2IDUuNDgtNC43OCA3LjE4bDcuNzMgNmM0LjUxLTQuMTggNy4wOS0xMC4zNiA3LjA5LTE3LjY1elwiPjwvcGF0aD48cGF0aCBmaWxsPVwiI0ZCQkMwNVwiIGQ9XCJNMTAuNTMgMjguNTljLS40OC0xLjQ1LS43Ni0yLjk5LS43Ni00LjU5cy4yNy0zLjE0Ljc2LTQuNTlsLTcuOTgtNi4xOUMuOTIgMTYuNDYgMCAyMC4xMiAwIDI0YzAgMy44OC45MiA3LjU0IDIuNTYgMTAuNzhsNy45Ny02LjE5elwiPjwvcGF0aD48cGF0aCBmaWxsPVwiIzM0QTg1M1wiIGQ9XCJNMjQgNDhjNi40OCAwIDExLjkzLTIuMTMgMTUuODktNS44MWwtNy43My02Yy0yLjE1IDEuNDUtNC45MiAyLjMtOC4xNiAyLjMtNi4yNiAwLTExLjU3LTQuMjItMTMuNDctOS45MWwtNy45OCA2LjE5QzYuNTEgNDIuNjIgMTQuNjIgNDggMjQgNDh6XCI+PC9wYXRoPjxwYXRoIGZpbGw9XCJub25lXCIgZD1cIk0wIDBoNDh2NDhIMHpcIj48L3BhdGg+PC9zdmc+YDtcbiAgICBjYXNlIFwib2F1dGhHZW5lcmljXCI6XG4gICAgICByZXR1cm4gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHdpZHRoPVwiODAwcHhcIiBoZWlnaHQ9XCI4MDBweFwiIHZpZXdCb3g9XCIwIDAgMjU2IDI1NlwiIHZlcnNpb249XCIxLjFcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWRcIj5cblx0PGc+XG5cdFx0PHBhdGggZD1cIk0xMTguOTIyNjI0LDAuMzcxNDA3NzEgQzE3NS40ODM2OTEsLTMuNTUwNTEyMyAyMTIuOTg2ODM3LDI0LjEyODIwNzggMjM0LjQzMDI1MSw1Ny44NTE1MTU3IEMyNDUuMTgyMjUxLDc0Ljc2MDMxNTcgMjU1LjczMTU4NCwxMDAuNDQxMzgyIDI1NS43ODAyMjQsMTI2LjgyNzcyOSBDMjU1LjgzMjI3NywxNTUuNDk3MTY5IDI0Ni41NDQ1OTcsMTgwLjMyNDQ3NiAyMzQuNDMwMjUxLDE5OC41NDEwMDkgQzIyMS45NzkyNjQsMjE3LjI2NDQyMiAyMDUuODc1MTU3LDIzMi43Mjg5NTYgMTg1LjcwOTE4NCwyNDIuODgzMTk2IEMxNTEuOTk5OTU3LDI1OS44NTcyNzYgMTA0Ljg4OTk4NCwyNjAuMzIxNDg5IDc0LjAzMzAyNCwyNDMuOTc4MDIyIEMzOS42Njg0MzYxLDIyNS43NzcyNzYgMTMuMjQ2Njc2MSwxOTkuNzk4ODIyIDMuNDE0NTY5MjYsMTU0Ljc0NjY2MiBDLTAuNTIwMTUwNzQxLDEzNi43MTc0MzYgLTAuOTcyNDE3NDA4LDExMy40MjE4NjIgNC41MDkzOTU5Myw5My40MzQ2NjI0IEM1Ljc5NTc5NjA1LDg4Ljc0NjAyMjQgOC4xMzM1MDI3Miw4My44MTE2MjI0IDkuOTgzOTU2MDUsNzkuMjAxNDg5MSBDMTguODc2NTQyNyw1Ny4wNDcyNDkxIDM0LjAxMjU0MjcsMzcuNzgyMzk0NSA1Mi42ODM0NzczLDI0LjQ1ODAyMTEgQzYwLjE4NTk4NCwxOS4xMDQyMDc4IDY5LjI4NzYzNzMsMTMuNzc5NDA3OCA3Ny4zMTc5MzA3LDEwLjIyNDg0NzggQzg3LjMwOTYxMDcsNS44MDI0NDc3OSAxMDQuMTMyMjI0LDEuMzk2Njg3NyAxMTguOTIyNjI0LDAuMzcxNDA3NzEgTDExOC45MjI2MjQsMC4zNzE0MDc3MSBaXCIgZmlsbD1cIiNGRkZGRkZcIj5cbjwvcGF0aD5cblx0XHQ8cGF0aCBkPVwiTTIyNi4yMTE3OTcsMTMwLjAxNTc4MiBDMjI2LjIxMTc5NywxODMuNDcxOTk2IDE4Mi44NzY5NzEsMjI2LjgwMzgzNiAxMjkuNDIxNjExLDIyNi44MDM4MzYgQzc1Ljk2NjI1MDcsMjI2LjgwMzgzNiAzMi42MzIyNzYxLDE4My40NzE5OTYgMzIuNjMyMjc2MSwxMzAuMDE1NzgyIEMzMi42MzIyNzYxLDc2LjU2MDg0OTEgNzUuOTY2MjUwNywzMy4yMjU1OTQ1IDEyOS40MjE2MTEsMzMuMjI1NTk0NSBDMTgyLjg3NjU0NCwzMy4yMjU1OTQ1IDIyNi4yMTE3OTcsNzYuNTYwODQ5MSAyMjYuMjExNzk3LDEzMC4wMTU3ODIgTDIyNi4yMTE3OTcsMTMwLjAxNTc4MiBaXCIgZmlsbD1cIiMwMDAwMDBcIj5cbjwvcGF0aD5cblx0XHQ8cGF0aCBkPVwiTTExOC45MjI2MjQsMC4zNzE0MDc3MSBDMTc1LjQ4MzY5MSwtMy41NTA1MTIzIDIxMi45ODY4MzcsMjQuMTI4MjA3OCAyMzQuNDMwMjUxLDU3Ljg1MTUxNTcgQzI0NS4xODIyNTEsNzQuNzYwMzE1NyAyNTUuNzMxNTg0LDEwMC40NDEzODIgMjU1Ljc4MDIyNCwxMjYuODI3NzI5IEMyNTUuODMyMjc3LDE1NS40OTcxNjkgMjQ2LjU0NDU5NywxODAuMzI0NDc2IDIzNC40MzAyNTEsMTk4LjU0MTAwOSBDMjIxLjk3OTI2NCwyMTcuMjY0NDIyIDIwNS44NzUxNTcsMjMyLjcyODk1NiAxODUuNzA5MTg0LDI0Mi44ODMxOTYgQzE1MS45OTk5NTcsMjU5Ljg1NzI3NiAxMDQuODg5OTg0LDI2MC4zMjE0ODkgNzQuMDMzMDI0LDI0My45NzgwMjIgQzM5LjY2ODQzNjEsMjI1Ljc3NzI3NiAxMy4yNDY2NzYxLDE5OS43OTg4MjIgMy40MTQ1NjkyNiwxNTQuNzQ2NjYyIEMtMC41MjAxNTA3NDEsMTM2LjcxNzQzNiAtMC45NzI0MTc0MDgsMTEzLjQyMTg2MiA0LjUwOTM5NTkzLDkzLjQzNDY2MjQgQzUuNzk1Nzk2MDUsODguNzQ2MDIyNCA4LjEzMzUwMjcyLDgzLjgxMTYyMjQgOS45ODM5NTYwNSw3OS4yMDE0ODkxIEMxOC44NzY1NDI3LDU3LjA0NzI0OTEgMzQuMDEyNTQyNywzNy43ODIzOTQ1IDUyLjY4MzQ3NzMsMjQuNDU4MDIxMSBDNjAuMTg1OTg0LDE5LjEwNDIwNzggNjkuMjg3NjM3MywxMy43Nzk0MDc4IDc3LjMxNzkzMDcsMTAuMjI0ODQ3OCBDODcuMzA5NjEwNyw1LjgwMjQ0Nzc5IDEwNC4xMzIyMjQsMS4zOTY2ODc3IDExOC45MjI2MjQsMC4zNzE0MDc3MSBMMTE4LjkyMjYyNCwwLjM3MTQwNzcxIFogTTk5Ljc2MjMwNCw5LjY3Nzg2MTEyIEM3OC43NTM2NjQsMTUuMTI0Njg3OCA2My4zNDk3MTczLDI0Ljg4Mjk4MTEgNDkuOTQ2NDEwNywzNS40MDcxNDExIEMzMC42MTg4MzYxLDUwLjU4MjgyMjQgMTguMjk3NTU2MSw3MS43NjA0MjI0IDExLjA3ODc4MjcsOTcuMjY2NTU1NyBDMy4wNDc2MzU5MywxMjUuNjQzMzAyIDguMjA2NDYyNzIsMTU5Ljk4MjI4OSAxOS4yOTA0MDk0LDE4MS41NzA3NjkgQzMwLjc4NDM4MjcsMjAzLjk1ODgyMiA0Ni4yMTczNDQsMjIxLjMzNzM4MiA2OC4wMTE0NzczLDIzMy41NzY3NDIgQzg5LjIxNDY3NzMsMjQ1LjQ4NDE1NiAxMTkuMDM2OTcxLDI1My4xMzAwMjIgMTUwLjEyNjQ2NCwyNDcuMjYyNTAyIEMxNzcuNzQ4ODY0LDI0Mi4wNDk0ODkgMTk4LjcyNzYzNywyMzAuMDE2MjA5IDIxNS44MTgxOTcsMjEyLjIyNjc2OSBDMjM4LjY4NDExNywxODguNDI1MTY5IDI1Ny4wNjE5MzEsMTQ0LjU4NTU5NiAyNDQuODMyMzg0LDk4LjM2MTM4MjQgQzI0MS41NjMyNjQsODYuMDA3MjQ5MSAyMzcuMjg5MzQ0LDczLjEzMTMwMjQgMjMwLjU5ODc4NCw2Mi4yMzA4MjI0IEMyMjYuOTg0MDY0LDU2LjM0MTk2OTEgMjIxLjY3OTc0NCw1MC41NDg2ODkxIDIxNi4zNjU2MTEsNDQuNzEzMTY5MSBDMTk2LjMwOTcxNywyMi42ODgyMDc4IDE2My44OTQ1NzEsMy43MDg3OTQzNyAxMjIuMjA3MTA0LDYuMzkyOTU0NDUgQzExNC4yNzM2NjQsNi45MDM2NzQ0NSAxMDcuMzAxNTA0LDcuNzIyODc0NDUgOTkuNzYyMzA0LDkuNjc3ODYxMTIgTDk5Ljc2MjMwNCw5LjY3Nzg2MTEyIFpcIiBmaWxsPVwiIzAwMDAwMFwiPlxuPC9wYXRoPlxuXHRcdDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg3LjY4MDAwMCwgOS4zODY2NjcpXCIgZmlsbD1cIiNGRkZGRkZcIj5cblx0XHRcdDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwLjAwMDAwMCwgMi45ODY2NjcpXCI+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMTI3Ljg5NjM2MiwyMzQuMDI1NDM2IEwyMzkuNzQxOTA5LDEyMi4xODI0NDkgTDIzOS4xMzg1MTgsMTIxLjU3OTA0NCBMMTI3LjI5Mjk3MSwyMzMuNDIyMDMxIEwxMjcuODk2MzYyLDIzNC4wMjU0MzYgTDEyNy44OTYzNjIsMjM0LjAyNTQzNiBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMTE4LjExODg2OSwyMjUuMTY3ODM1IEwyMzAuNDUyMDk2LDExMi44MzY3NDIgTDIyOS44NDg3MDQsMTEyLjIzMzMzOCBMMTE3LjUxNTQ3NywyMjQuNTY0NDMyIEwxMTguMTE4ODY5LDIyNS4xNjc4MzUgTDExOC4xMTg4NjksMjI1LjE2NzgzNSBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMTA4LjM0MDk1LDIxNi4zMTE1MTUgTDIyMS4xNjI3MSwxMDMuNDkxNDYxIEwyMjAuNTU5MzE3LDEwMi44ODgwNTkgTDEwNy43Mzc1NTcsMjE1LjcwODExMiBMMTA4LjM0MDk1LDIxNi4zMTE1MTUgTDEwOC4zNDA5NSwyMTYuMzExNTE1IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk05OC41NjMwMjk0LDIwNy40NTM5MTUgTDIxMS44NzI4OTYsOTQuMTQ2MTgxNyBMMjExLjI2OTUwNCw5My41NDI3NzgzIEw5Ny45NTk2MzczLDIwNi44NTA1MTIgTDk4LjU2MzAyOTQsMjA3LjQ1MzkxNSBMOTguNTYzMDI5NCwyMDcuNDUzOTE1IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk04OC43ODU1MzY2LDE5OC41OTY3NDEgTDIwMi41ODM1MSw4NC44MDA0NzQ1IEwyMDEuOTgwMTE3LDg0LjE5NzA3MjIgTDg4LjE4MjE0MzQsMTk3Ljk5MzMzOSBMODguNzg1NTM2NiwxOTguNTk2NzQxIEw4OC43ODU1MzY2LDE5OC41OTY3NDEgWlwiPlxuPC9wYXRoPlxuXHRcdFx0XHQ8cGF0aCBkPVwiTTc5LjAwNzYyLDE4OS43NDE2OTggTDE5My4yOTMyNzMsNzUuNDU1MTkxMSBMMTkyLjY4OTg3Myw3NC44NTE3OTU2IEw3OC40MDQyMiwxODkuMTM4MzAyIEw3OS4wMDc2MiwxODkuNzQxNjk4IEw3OS4wMDc2MiwxODkuNzQxNjk4IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk02OS4yMjk2OTY3LDE4MC44ODIzOTQgTDE4NC4wMDM4ODMsNjYuMTA5OTE0NSBMMTgzLjQwMDQ5LDY1LjUwNjUxMjIgTDY4LjYyNjMwMzMsMTgwLjI3ODk5MiBMNjkuMjI5Njk2NywxODAuODgyMzk0IEw2OS4yMjk2OTY3LDE4MC44ODIzOTQgWlwiPlxuPC9wYXRoPlxuXHRcdFx0XHQ8cGF0aCBkPVwiTTU5LjQ1MTc3NzgsMTcyLjAyNTIyIEwxNzQuNzEzNjQ0LDU2Ljc2NDIwNjcgTDE3NC4xMTAyNDksNTYuMTYwODA2NyBMNTguODQ4MzgyMiwxNzEuNDIxODIgTDU5LjQ1MTc3NzgsMTcyLjAyNTIyIEw1OS40NTE3Nzc4LDE3Mi4wMjUyMiBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNNDkuNjczODYwNiwxNjMuMTY4MDQ0IEwxNjUuNDIxNzAxLDQ3LjQxODkyMzkgTDE2NC44MTgyOTksNDYuODE1NTI5NCBMNDkuMDcwNDU5NCwxNjIuNTY0NjQ5IEw0OS42NzM4NjA2LDE2My4xNjgwNDQgTDQ5LjY3Mzg2MDYsMTYzLjE2ODA0NCBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMzkuODk2MzYzOSwxNTQuMzEwNDQ3IEwxNTYuMTM0NDQ0LDM4LjA3MzY0NzIgTDE1NS41MzEwNDksMzcuNDcwMjQ2MSBMMzkuMjkyOTY5NCwxNTMuNzA3MDQ2IEwzOS44OTYzNjM5LDE1NC4zMTA0NDcgTDM5Ljg5NjM2MzksMTU0LjMxMDQ0NyBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMzAuMTE4NDQ0NSwxNDUuNDUzNyBMMTQ2Ljg0NDYzMSwyOC43MjgzNjY3IEwxNDYuMjQxMjM2LDI4LjEyNDk2NjcgTDI5LjUxNTA0ODksMTQ0Ljg1MDMgTDMwLjExODQ0NDUsMTQ1LjQ1MzcgTDMwLjExODQ0NDUsMTQ1LjQ1MzcgWlwiPlxuPC9wYXRoPlxuXHRcdFx0XHQ8cGF0aCBkPVwiTTIwLjM0MDUyNDUsMTM2LjU5NjUyNyBMMTM3LjU1NTI0NCwxOS4zODI2NiBMMTM2Ljk1MTg0OSwxOC43NzkyNiBMMTkuNzM3MTI4OSwxMzUuOTkzMTI3IEwyMC4zNDA1MjQ1LDEzNi41OTY1MjcgTDIwLjM0MDUyNDUsMTM2LjU5NjUyNyBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMTAuNTYyNjAzOSwxMjcuNzM4OTI3IEwxMjguMjY1NDMxLDEwLjAzNzM4MDUgTDEyNy42NjIwMzYsOS40MzM5Nzk0NyBMOS45NTkyMDk0MSwxMjcuMTM1NTI2IEwxMC41NjI2MDM5LDEyNy43Mzg5MjcgTDEwLjU2MjYwMzksMTI3LjczODkyNyBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMC43ODQ2ODM5MjYsMTE4Ljg4MTc1NCBMMTE4Ljk3NTYxNywwLjY5MjEwMDUyNyBMMTE4LjM3MjIyMywwLjA4ODY5OTQ3MyBMMC4xODEyODk0MDcsMTE4LjI3ODM1MyBMMC43ODQ2ODM5MjYsMTE4Ljg4MTc1NCBMMC43ODQ2ODM5MjYsMTE4Ljg4MTc1NCBaXCI+XG48L3BhdGg+XG5cdFx0XHQ8L2c+XG5cdFx0XHQ8Zz5cblx0XHRcdFx0PHBhdGggZD1cIk0wLjE0MzMwNzY3LDEyMi45OTkwNzkgTDExNC4yMjM3MzQsMjM3LjA4NDYyNSBMMTE0LjgyNzE0NiwyMzYuNDgxMjQxIEwwLjc0NjcxODk5NywxMjIuMzk1Njk1IEwwLjE0MzMwNzY3LDEyMi45OTkwNzkgTDAuMTQzMzA3NjcsMTIyLjk5OTA3OSBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNOS4zOTQ3MjA0NSwxMTMuNjE1Mzk4IEwxMjMuNjk3MDE0LDIyNy45MjMyMzggTDEyNC4zMDA0MjYsMjI3LjMxOTg1NSBMOS45OTgxMzI4OCwxMTMuMDEyMDE1IEw5LjM5NDcyMDQ1LDExMy42MTUzOTggTDkuMzk0NzIwNDUsMTEzLjYxNTM5OCBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMTguNjQ2MTM0NCwxMDQuMjMxNzE5IEwxMzMuMTcwMjk0LDIxOC43NjA5OTkgTDEzMy43NzM3MDYsMjE4LjE1NzYxNSBMMTkuMjQ5NTQ1NiwxMDMuNjI4MzM1IEwxOC42NDYxMzQ0LDEwNC4yMzE3MTkgTDE4LjY0NjEzNDQsMTA0LjIzMTcxOSBaXCI+XG48L3BhdGg+XG5cdFx0XHRcdDxwYXRoIGQ9XCJNMjcuODk3NTQ3Nyw5NC44NDgwMzg4IEwxNDIuNjQ0MDAxLDIwOS41OTk2MTIgTDE0My4yNDc0MTIsMjA4Ljk5NjIyOCBMMjguNTAwOTU5LDk0LjI0NDY1NDUgTDI3Ljg5NzU0NzcsOTQuODQ4MDM4OCBMMjcuODk3NTQ3Nyw5NC44NDgwMzg4IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk0zNy4xNDg1MzQ5LDg1LjQ2NDM1OTQgTDE1Mi4xMTY4NTUsMjAwLjQzNzM3MyBMMTUyLjcyMDI2NSwxOTkuODMzOTg3IEwzNy43NTE5NDUxLDg0Ljg2MDk3MzkgTDM3LjE0ODUzNDksODUuNDY0MzU5NCBMMzcuMTQ4NTM0OSw4NS40NjQzNTk0IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk00Ni4zOTk5NDk0LDc2LjA4MDY4MDUgTDE2MS41OTA5ODksMTkxLjI3NTU2MSBMMTYyLjE5NDM5NywxOTAuNjcyMTczIEw0Ny4wMDMzNTczLDc1LjQ3NzI5MjggTDQ2LjM5OTk0OTQsNzYuMDgwNjgwNSBMNDYuMzk5OTQ5NCw3Ni4wODA2ODA1IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk01NS42NTEzNjI4LDY2LjY5NzAwMDUgTDE3MS4wNjQyNjksMTgyLjExMzc0NyBMMTcxLjY2NzY3NywxODEuNTEwMzU5IEw1Ni4yNTQ3NzA2LDY2LjA5MzYxMjggTDU1LjY1MTM2MjgsNjYuNjk3MDAwNSBMNTUuNjUxMzYyOCw2Ni42OTcwMDA1IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk02NC45MDIzNTA1LDU3LjMxMzMyMTcgTDE4MC41Mzc1NTEsMTcyLjk1MTUwOCBMMTgxLjE0MDk1NiwxNzIuMzQ4MTE4IEw2NS41MDU3NTYxLDU2LjcwOTkzMTcgTDY0LjkwMjM1MDUsNTcuMzEzMzIxNyBMNjQuOTAyMzUwNSw1Ny4zMTMzMjE3IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk03NC4xNTM3NjQ0LDQ3LjkyOTY0MjIgTDE5MC4wMTEyNTgsMTYzLjc4OTY5NiBMMTkwLjYxNDY2MiwxNjMuMTg2MzA0IEw3NC43NTcxNjg5LDQ3LjMyNjI1MTEgTDc0LjE1Mzc2NDQsNDcuOTI5NjQyMiBMNzQuMTUzNzY0NCw0Ny45Mjk2NDIyIFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk04My40MDUxNzgzLDM4LjU0NTk2MjggTDE5OS40ODQxMTIsMTU0LjYyNzAyOSBMMjAwLjA4NzUxNSwxNTQuMDIzNjM3IEw4NC4wMDg1ODE3LDM3Ljk0MjU3MDUgTDgzLjQwNTE3ODMsMzguNTQ1OTYyOCBMODMuNDA1MTc4MywzOC41NDU5NjI4IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk05Mi42NTY1OTExLDI5LjE2MjI4MjIgTDIwOC45NTc4MTgsMTQ1LjQ2NjA2OSBMMjA5LjU2MTIyMiwxNDQuODYyNjc4IEw5My4yNTk5OTU1LDI4LjU1ODg5MTEgTDkyLjY1NjU5MTEsMjkuMTYyMjgyMiBMOTIuNjU2NTkxMSwyOS4xNjIyODIyIFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk0xMDEuOTA3NTc5LDE5Ljc3ODYwMzQgTDIxOC40MzEwOTksMTM2LjMwMzgzIEwyMTkuMDM0NTAxLDEzNS43MDA0MzcgTDEwMi41MTA5ODEsMTkuMTc1MjEgTDEwMS45MDc1NzksMTkuNzc4NjAzNCBMMTAxLjkwNzU3OSwxOS43Nzg2MDM0IFpcIj5cbjwvcGF0aD5cblx0XHRcdFx0PHBhdGggZD1cIk0xMTEuMTU4OTkyLDEwLjM5NTM1IEwyMjcuOTA0Mzc5LDEyNy4xNDI0NDMgTDIyOC41MDc3ODEsMTI2LjUzOTA1IEwxMTEuNzYyMzk0LDkuNzkxOTU2NjUgTDExMS4xNTg5OTIsMTAuMzk1MzUgTDExMS4xNTg5OTIsMTAuMzk1MzUgWlwiPlxuPC9wYXRoPlxuXHRcdFx0XHQ8cGF0aCBkPVwiTTEyMC40MTA4MzMsMS4wMTE2NzA1OCBMMjM3LjM3ODA4NiwxMTcuOTgwMjA0IEwyMzcuOTgxNDg3LDExNy4zNzY4MDkgTDEyMS4wMTQyMzQsMC40MDgyNzYwOTEgTDEyMC40MTA4MzMsMS4wMTE2NzA1OCBMMTIwLjQxMDgzMywxLjAxMTY3MDU4IFpcIj5cbjwvcGF0aD5cblx0XHRcdDwvZz5cblx0XHQ8L2c+XG5cdFx0PHBhdGggZD1cIk0yMDkuNzk2MjI0LDQ1LjI2MDU4MjQgQzE5OS43Mjk4NzcsMzUuMTk0MjM0NSAxODcuMzUzOTg0LDI2LjEyMzMwMTEgMTcyLjU3MDgzNywyMC42MjYxMjc4IEMxNTcuMjQ3NTMxLDE0LjkyNzk5NDUgMTM5LjkxMzc3MSwxMC4xMjUwMDc4IDExOS40NzAwMzcsMTEuODY3MDg3OCBDODYuOTA0Mjc3MywxNC42NDI5ODExIDY0LjAzOTIxMDcsMjkuMjU0MTgxMSA0Ni42NjE1MDQsNDYuMzU1NDA5MSBDMzQuNDg5NTU2MSw1OC4zMzMyMjI0IDI1LjMzMzcxNjEsNzMuMDEwOTgyNCAxOS4yODk5ODI3LDkwLjE0OTc1NTcgQzEwLjQxNjE2OTQsMTE1LjMxNDk4MiAxMC45NTQ2MjI3LDE0NS4wMTgyMzYgMjAuOTMyMjIyNywxNzAuNjIyMDc2IEMyOS40NDI5NDI3LDE5Mi40NjE4NjIgNDMuMzcyNzU3MywyMTAuMDc3MjIyIDYzLjA4NDMzMDcsMjIzLjcyMjg3NiBDODEuNjE0ODkwNywyMzYuNTUxNDYyIDEwOC4yMTA3MzEsMjQ2LjUwMDkwMiAxMzguMDgyMDkxLDI0My45NzgwMjIgQzE3NC40NjQ4MTEsMjQwLjkwNTE2OSAyMDEuMDg1Mzk3LDIyMi4yMzkzNTYgMjE4LjU1NDQxMSwyMDAuNzMxMDg5IEMyMjMuMDI0MTcxLDE5NS4yMjg3OTYgMjI3LjQ2ODMzMSwxODkuMDA5Mjc2IDIzMC4wNTAwOTEsMTgxLjU3MTE5NiBDMjMyLjU3OTc5NywxNzYuMjExODM2IDIzMy44MTc5ODQsMTcyLjU2ODUyOSAyMzQuOTc3MjM3LDE3MC42MjI1MDIgQzIzOS44MjkyOTEsMTU5Ljc1MDE4MiAyNDIuMzk5OTU3LDE0OC4yNzg4MjIgMjQzLjE4ODQzNywxMzUuNTg3MTk2IEMyNDUuNjE0MDM3LDk2LjU1MDYwOTEgMjMwLjU5NDUxNyw2Ni4wNTkzMDI0IDIwOS43OTYyMjQsNDUuMjYwNTgyNCBMMjA5Ljc5NjIyNCw0NS4yNjA1ODI0IFogTTE5OS4wNzM2NjQsMTY0LjE5MzA2MiBDMTk5LjAwNDExNywxNjQuMzQxNTQyIDE5OC45NDE4MjQsMTY0LjQ3OTc4MiAxOTguODY5MjkxLDE2NC42MzI5NTYgQzE5Ny4wNjQ0OTEsMTY5Ljc5Nzc1NiAxOTMuOTU1MzcxLDE3NC4xMTY0NzYgMTkwLjgzMDQ2NCwxNzcuOTM3NzAyIEMxNzguNjEzMjkxLDE5Mi44NzI3NDIgMTU5Ljk5ODI1MSwyMDUuODM0MDIyIDEzNC41NTUyNjQsMjA3Ljk2ODIwOSBDMTEzLjY2NTIzNywyMDkuNzE5MjQ5IDk1LjA2NjQxMDcsMjAyLjgxMTA4OSA4Mi4xMDgxMTczLDE5My45MDMxNDIgQzcwLjg0NzUzMDcsMTg2LjE2MjEyOSA2Mi4yODc3NDQsMTc2LjU4MDA0OSA1Ni4yODUzOTczLDE2NS4wNjQzMTYgQzU1LjkxOTMxNzMsMTY0LjM3MTQwOSA1Mi40MzM0NTA3LDE1Ni4zNDAyNjIgNTIuNDIzMjEwNywxNTUuOTg2OTgyIEM0Ny42NjgwMTA3LDE0MS4yMzc1NDIgNDcuMjU1NDI0LDExNy41MjA4NDkgNTIuMTM2MDY0LDEwMy4yODg1MjkgQzU1LjM5MzIzNzMsOTMuNzg5NjQ5MSA2MC44MjE3MTczLDgzLjUxMjEwMjQgNjguMDExNDc3Myw3NS4zNjk1OTU3IEM3Ny45MzgzMDQsNjQuMTI2NTAyNCA4Ny44NzIzODQsNTYuOTIyMjM1NyAxMDMuNTk0NjI0LDUxLjgyOTk2OTEgQzExMC43NzMyOTEsNDkuNTA0NjM1NyAxMTcuMTk5NzQ0LDQ3LjEzNzkxNTcgMTI2LjAzODk5Nyw0Ni45MDMyNDkxIEMxNDcuNTk0MTk3LDQ2LjMyOTM4MjQgMTY5LjU0NDA2NCw1Ni4wMDc0NjI0IDE4MS4zMjk0NTEsNjYuNjEwNTU1NyBDMTkyLjE1OTk1Nyw3Ni4zNTQzNDI0IDIwNC41MDM0MjQsOTUuMzM0NjA5MSAyMDcuNjA2NTcxLDExMy4xNDE5NjkgQzIxMC44MDAxNzEsMTMxLjQ3MDI4OSAyMDcuMzkxOTU3LDE0OS4zNjUxMTYgMTk5LjA3MzY2NCwxNjQuMTkzMDYyIEwxOTkuMDczNjY0LDE2NC4xOTMwNjIgWlwiIGZpbGw9XCIjMDAwMDAwXCI+XG48L3BhdGg+XG5cdFx0PGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDgzLjYyNjY2NywgNzYuMzczMzMzKVwiPlxuXHRcdFx0PHBhdGggZD1cIk03Ny45ODEwMTMzLDEwNS40MDA3NDcgQzcyLjY3MzI4LDEwNS40MDA3NDcgNjguMDE1MzYsMTAyLjAzOTQ2NyA2Ni4zODk3Niw5Ny4wMzYzNzMzIEw2MC40Nzc4NjY3LDc5LjAyMzM2IEwzMC45MDM0NjY3LDc5LjAyMzM2IEwyNS40MTA1Niw5Ni44NzIxMDY3IEMyMy43NTI1MzMzLDEwMS45NzI0OCAxOS4wNTkyLDEwNS4zODY2NjcgMTMuNzI0MTYsMTA1LjM4NjY2NyBDMTIuNDQzMzA2NywxMDUuMzg2NjY3IDExLjE3MDk4NjcsMTA1LjE4NCA5Ljk0MjYxMzMzLDEwNC43ODU0OTMgQzMuNTY1NjUzMzMsMTAyLjg3MTA0IC0wLjA1NDYxMzMzMzMsOTYuMDA3MjUzMyAxLjg5OTA5MzMzLDg5LjQ5Mzc2IEwyNi44NjE2NTMzLDEwLjQyMjYxMzMgQzI4LjQ4MjU2LDUuMzkyNjQgMzMuMjU0NCwxLjg4NDE2IDM4LjQ2Njk4NjcsMS44ODQxNiBMNTEuNzQwNTg2NywxLjg4NDE2IEM1Ni45ODI2MTMzLDEuODg0MTYgNjEuNzU0MDI2Nyw1LjMzMjkwNjY3IDYzLjM0MzM2LDEwLjI3MTE0NjcgTDg5LjU5NTczMzMsODkuMzEyODUzMyBDOTEuNjk0OTMzMyw5NS43NzUxNDY3IDg4LjIxODg4LDEwMi43MTIzMiA4MS44NTEzMDY3LDEwNC43ODUwNjcgQzgwLjU5MjIxMzMsMTA1LjE5MzgxMyA3OS4yOTA0NTMzLDEwNS40MDA3NDcgNzcuOTgxMDEzMywxMDUuNDAwNzQ3IEw3Ny45ODEwMTMzLDEwNS40MDA3NDcgTDc3Ljk4MTAxMzMsMTA1LjQwMDc0NyBaXCIgZmlsbD1cIiNGRkZGRkZcIj5cbjwvcGF0aD5cblx0XHRcdDxwYXRoIGQ9XCJNNzcuOTgxMDEzMywxMDMuNjk0MDggQzczLjIyNjE4NDEsMTAzLjY5NDA4IDY5LjA2MDg0NjUsMTAwLjY4ODMwOCA2Ny42MDcxMTI2LDk2LjIxNDE2NTcgTDYxLjY5NDA0MDgsNzguMTk3NTQzNSBMNjEuNDA0OTQ0Niw3Ny4zMTY2OTMzIEw2MC40Nzc4NjY3LDc3LjMxNjY5MzMgTDMwLjkwMzQ2NjcsNzcuMzE2NjkzMyBMMjkuOTU4MTQxLDc3LjMxNjY5MzMgTDI5LjY4MDA4ODUsNzguMjIwMjAxOCBMMjQuMTg3MTgxOCw5Ni4wNjg5NDg1IEMyMi43MDcyNjkxLDEwMC42MjA4OTkgMTguNTA2NzIyNiwxMDMuNjggMTMuNzI0MTYsMTAzLjY4IEMxMi41Nzg3NTAyLDEwMy42OCAxMS40Mzk2NjEyLDEwMy40OTg4MjMgMTAuMzM3NjAyOCwxMDMuMTQxMjk1IEM0LjYxMTc0OTA4LDEwMS40MjE5ODggMS4zNzQyMTMwNiw5NS4yNzIyNDQ3IDMuMTI1MTI4NjYsODkuNDM0ODM5NyBMMjguMDgyMjcxNCwxMC4zODEyOTI3IEMyOS41MzA4MjEyLDUuODg2MjQ4NDcgMzMuODExMzg4NSwyLjczNzQ5MzMzIDM4LjQ2Njk4NjcsMi43Mzc0OTMzMyBMNTEuNzQwNTg2NywyLjczNzQ5MzMzIEM1Ni40Mjg4NTQ0LDIuNzM3NDkzMzMgNjAuNzA2NTEzOCw1LjgyOTUwODY1IDYyLjEyNDkxMDMsMTAuMjM2NjI4NCBMODguMzgwOTgyMSw4OS4yODk2NDU5IEM5MC4yNTk5MzA2LDk1LjA3Mzk5NDYgODcuMTQ4NTc3MiwxMDEuMjg3OTQ2IDgxLjQ1NTEwODYsMTAzLjE0MTI2MSBDODAuMzI0NjUxNiwxMDMuNTA4MjQ3IDc5LjE1NjI1ODEsMTAzLjY5NDA4IDc3Ljk4MTAxMzMsMTAzLjY5NDA4IEw3Ny45ODEwMTMzLDEwMy42OTQwOCBaIE03Ny45ODEwMTMzLDEwNi4yNTQwOCBDNzkuNDI1MzQ3NSwxMDYuMjU0MDggODAuODYwNDQ2NCwxMDYuMDI1ODI4IDgyLjI0NjUzNTcsMTA1LjU3NTg1NCBDODkuMjkyMjY0OCwxMDMuMjgyMzU3IDkzLjEyODkyMTEsOTUuNjE5ODQwNiA5MC44MTMxMTQ4LDg4LjQ5MDczNDYgTDY0LjU1ODExMTMsOS40NDEwMjA4IEM2Mi44MDE2MTAxLDMuOTgzMTkwNTQgNTcuNTM2NjA1LDAuMTc3NDkzMzMzIDUxLjc0MDU4NjcsMC4xNzc0OTMzMzMgTDM4LjQ2Njk4NjcsMC4xNzc0OTMzMzMgQzMyLjY5NTE2NTksMC4xNzc0OTMzMzMgMjcuNDMzNjAxMSw0LjA0Nzg2MzMxIDI1LjY0MzM0ODUsOS42MDMzNDg0OCBMMC42Nzg0NzUyNzQsODguNjgxNzQ3MyBDLTEuNDgwOTYzNTksOTUuODgwNjczNCAyLjUxMTQ1NDg3LDEwMy40NjQzMjYgOS41NzQ1NjcyNCwxMDUuNTg0NzcyIEMxMC45MDQxMTczLDEwNi4wMTY0MjkgMTIuMzA5NzM5OCwxMDYuMjQgMTMuNzI0MTYsMTA2LjI0IEMxOS42MTY4ODQ4LDEwNi4yNCAyNC43OTk0MTI4LDEwMi40NjU3NTkgMjYuNjI3ODU1Miw5Ni44NDExNTc3IEwzMi4xMjY4NDQ4LDc4Ljk3MzE4NDkgTDMwLjkwMzQ2NjcsNzkuODc2NjkzMyBMNjAuNDc3ODY2Nyw3OS44NzY2OTMzIEw1OS4yNjE2OTI2LDc4Ljk5NTg0MzIgTDY1LjE3MzU4NTksOTcuMDA4ODU2NSBDNjYuOTY5ODk2MiwxMDIuNTM3MzYxIDcyLjEyMDQ0OTgsMTA2LjI1NDA4IDc3Ljk4MTAxMzMsMTA2LjI1NDA4IEw3Ny45ODEwMTMzLDEwNi4yNTQwOCBaXCIgZmlsbD1cIiMwMDAwMDBcIj5cbjwvcGF0aD5cblx0XHQ8L2c+XG5cdFx0PGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDYxLjQ0MDAwMCwgMTkuMjAwMDAwKVwiIGZpbGw9XCIjRkZGRkZGXCI+XG5cdFx0XHQ8cGF0aCBkPVwiTTIuMTMzNzYsMzMuODU3NzA2NyBMMi4xMDI2MTMzMywzMy44MTU0NjY3IEMtMS4wMTAzNDY2NywyOS41NDkyMjY3IC0wLjA5Njg1MzMzMzMsMjMuNTgxMDEzMyA0LjQ4NzY4LDIwLjIzNTA5MzMgQzkuMDcyMjEzMzMsMTYuODg5NiAxNC45NjE0OTMzLDE3LjgyODY5MzMgMTguMDc0NDUzMywyMi4wOTQ1MDY3IEwxOC4xMDU2LDIyLjEzNjc0NjcgQzIxLjIxODU2LDI2LjQwMjk4NjcgMjAuMzA1MDY2NywzMi4zNzE2MjY3IDE1LjcyMDUzMzMsMzUuNzE3MTIgQzExLjEzNiwzOS4wNjI2MTMzIDUuMjQ2NzIsMzguMTIzOTQ2NyAyLjEzMzc2LDMzLjg1NzcwNjcgTDIuMTMzNzYsMzMuODU3NzA2NyBaIE0xMy45MzQwOCwyNS4yNDYyOTMzIEwxMy45MDI5MzMzLDI1LjIwNDA1MzMgQzEyLjMzODc3MzMsMjMuMDYwNDggOS40MjYzNDY2NywyMi4zMjMyIDcuMTU1NjI2NjcsMjMuOTgwMzczMyBDNC45MDU4MTMzMywyNS42MjIxODY3IDQuNzMwODgsMjguNTQ2OTg2NyA2LjI5NTA0LDMwLjY5MDk4NjcgTDYuMzI2MTg2NjcsMzAuNzMzMjI2NyBDNy44OTA3NzMzMywzMi44NzY4IDEwLjgwMjc3MzMsMzMuNjE0MDggMTMuMDUyNTg2NywzMS45NzIyNjY3IEMxNS4zMjM3MzMzLDMwLjMxNTA5MzMgMTUuNDk4NjY2NywyNy4zOTAyOTMzIDEzLjkzNDA4LDI1LjI0NjI5MzMgTDEzLjkzNDA4LDI1LjI0NjI5MzMgWlwiPlxuPC9wYXRoPlxuXHRcdFx0PHBhdGggZD1cIk0zMi4xNDY3NzMzLDUuODk1MjUzMzMgTDM2LjgyNTE3MzMsNC4zOTQyNCBMNDkuOTQwNDgsMTkuNjQwNzQ2NyBMNDQuNzM2NDI2NywyMS4zMTAyOTMzIEw0Mi40NTcxNzMzLDE4LjU5MjQyNjcgTDM1LjcwMTc2LDIwLjc1OTg5MzMgTDM1LjQ1NDI5MzMsMjQuMjg4ODUzMyBMMzAuMzUwNTA2NywyNS45MjY0IEwzMi4xNDY3NzMzLDUuODk1MjUzMzMgTDMyLjE0Njc3MzMsNS44OTUyNTMzMyBaIE0zOS44NDM4NCwxNS4yNjQgTDM2LjI5NDgyNjcsMTAuOTExMTQ2NyBMMzUuOTE1NTIsMTYuNTI0MzczMyBMMzkuODQzODQsMTUuMjY0IEwzOS44NDM4NCwxNS4yNjQgWlwiPlxuPC9wYXRoPlxuXHRcdFx0PHBhdGggZD1cIk01OC4zNjU4NjY3LDEwLjQ4MTkyIEw1OC40MDY4MjY3LDAuMTU1MzA2NjY3IEw2My41ODMxNDY3LDAuMTc1Nzg2NjY3IEw2My41NDI2MTMzLDEwLjM5NzQ0IEM2My41MzE5NDY3LDEzLjA1MTMwNjcgNjQuODY2OTg2NywxNC4zMTc2NTMzIDY2LjkxNjY5MzMsMTQuMzI2MTg2NyBDNjguOTY2NCwxNC4zMzQyOTMzIDcwLjMxMTI1MzMsMTMuMTMxMDkzMyA3MC4zMjEwNjY3LDEwLjU1NjE2IEw3MC4zNjI0NTMzLDAuMjAzNTIgTDc1LjUzODc3MzMsMC4yMjQgTDc1LjQ5ODI0LDEwLjQxOTIgQzc1LjQ3NDc3MzMsMTYuMzU3NTQ2NyA3Mi4wNzUwOTMzLDE4Ljk0NTcwNjcgNjYuODQ1ODY2NywxOC45MjQ4IEM2MS42MTcwNjY3LDE4LjkwMzQ2NjcgNTguMzQzMjUzMywxNi4yMzYzNzMzIDU4LjM2NTg2NjcsMTAuNDgxOTIgTDU4LjM2NTg2NjcsMTAuNDgxOTIgWlwiPlxuPC9wYXRoPlxuXHRcdFx0PHBhdGggZD1cIk05NC4yMzMxNzMzLDguNjc3NTQ2NjcgTDg4Ljk1NjE2LDcuMDY2ODggTDkwLjI2MDA1MzMsMi43OTQ2NjY2NyBMMTA1LjY4OTYsNy41MDM3ODY2NyBMMTA0LjM4NTcwNywxMS43NzYgTDk5LjEwODY5MzMsMTAuMTY1NzYgTDk1LjA0Mzg0LDIzLjQ4NDU4NjcgTDkwLjE2ODc0NjcsMjEuOTk2OCBMOTQuMjMzMTczMyw4LjY3NzU0NjY3IEw5NC4yMzMxNzMzLDguNjc3NTQ2NjcgWlwiPlxuPC9wYXRoPlxuXHRcdFx0PHBhdGggZD1cIk0xMTkuNDcxNzg3LDEzLjQ2NTE3MzMgTDEyMy43MTU0MTMsMTYuMjg5MjggTDExOS45MDE4NjcsMjIuMDIwMjY2NyBMMTI1LjM0ODY5MywyNS42NDUyMjY3IEwxMjkuMTYyNjY3LDE5LjkxMzgxMzMgTDEzMy40MDYyOTMsMjIuNzM3OTIgTDEyMy4yMTYyMTMsMzguMDUwNTYgTDExOC45NzIxNiwzNS4yMjY0NTMzIEwxMjIuODQ0NTg3LDI5LjQwNzU3MzMgTDExNy4zOTczMzMsMjUuNzgyNjEzMyBMMTEzLjUyNTMzMywzMS42MDE0OTMzIEwxMDkuMjgxNzA3LDI4Ljc3NzM4NjcgTDExOS40NzE3ODcsMTMuNDY1MTczMyBMMTE5LjQ3MTc4NywxMy40NjUxNzMzIFpcIj5cbjwvcGF0aD5cblx0XHQ8L2c+XG5cdFx0PGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDY1LjI4MDAwMCwgMTk2LjI2NjY2NylcIiBmaWxsPVwiI0ZGRkZGRlwiPlxuXHRcdFx0PHBhdGggZD1cIk0xMzAuNjIyMjkzLDMuNzkwMDggTDEzMC42NTQ3MiwzLjgzMTQ2NjY3IEMxMzMuOTI4OTYsNy45NzU2OCAxMzMuMjQzNzMzLDEzLjk3NTQ2NjcgMTI4Ljc5MDE4NywxNy40OTM3NiBDMTI0LjMzNjY0LDIxLjAxMjA1MzMgMTE4LjQxNTM2LDIwLjI5ODY2NjcgMTE1LjE0MTEyLDE2LjE1NDQ1MzMgTDExNS4xMDg2OTMsMTYuMTEzMDY2NyBDMTExLjgzNDQ1MywxMS45Njg0MjY3IDExMi41MjAxMDcsNS45NjkwNjY2NyAxMTYuOTczMjI3LDIuNDUwNzczMzMgQzEyMS40MjY3NzMsLTEuMDY3MDkzMzMgMTI3LjM0ODA1MywtMC4zNTQxMzMzMzMgMTMwLjYyMjI5MywzLjc5MDA4IEwxMzAuNjIyMjkzLDMuNzkwMDggWiBNMTE5LjE1ODE4NywxMi44NDY5MzMzIEwxMTkuMTkwNjEzLDEyLjg4ODMyIEMxMjAuODM1ODQsMTQuOTcwODggMTIzLjc3NDI5MywxNS41OTYzNzMzIDEyNS45ODA1ODcsMTMuODUzNDQgQzEyOC4xNjU5NzMsMTIuMTI2NzIgMTI4LjIyOTU0Nyw5LjE5NzIyNjY3IDEyNi41ODM4OTMsNy4xMTQ2NjY2NyBMMTI2LjU1MTQ2Nyw3LjA3MzI4IEMxMjQuOTA2NjY3LDQuOTkwNzIgMTIxLjk2Nzc4Nyw0LjM2NTIyNjY3IDExOS43ODI0LDYuMDkxOTQ2NjcgQzExNy41NzYxMDcsNy44MzQ4OCAxMTcuNTEyOTYsMTAuNzY0MzczMyAxMTkuMTU4MTg3LDEyLjg0NjkzMzMgTDExOS4xNTgxODcsMTIuODQ2OTMzMyBaXCI+XG48L3BhdGg+XG5cdFx0XHQ8cGF0aCBkPVwiTTEwMS44NDgzMiwzMi45MzA5ODY3IEw5Ny4yNDAzMiwzNC42MzYzNzMzIEw4My40NjY2NjY3LDE5Ljk4MjA4IEw4OC41OTIyMTMzLDE4LjA4NDY5MzMgTDkwLjk4OTIyNjcsMjAuNzAwMTYgTDk3LjY0MjY2NjcsMTguMjM3NDQgTDk3LjczNDQsMTQuNzAxMjI2NyBMMTAyLjc2MTM4NywxMi44NDA1MzMzIEwxMDEuODQ4MzIsMzIuOTMwOTg2NyBMMTAxLjg0ODMyLDMyLjkzMDk4NjcgWiBNOTMuNzQ2MzQ2NywyMy45MTA0IEw5Ny40ODM1MiwyOC4xMDI0IEw5Ny42MTUzNiwyMi40NzgwOCBMOTMuNzQ2MzQ2NywyMy45MTA0IEw5My43NDYzNDY3LDIzLjkxMDQgWlwiPlxuPC9wYXRoPlxuXHRcdFx0PHBhdGggZD1cIk03NS40NzIyMTMzLDI5LjQzMzYgTDc1LjkyNzQ2NjcsMzkuNzQ5OTczMyBMNzAuNzU2MjY2NywzOS45NzgyNCBMNzAuMzA1MjgsMjkuNzY2ODI2NyBDNzAuMTg4MzczMywyNy4xMTU1MiA2OC43OTQwMjY3LDI1LjkxNDg4IDY2Ljc0NjQ1MzMsMjYuMDA1MzMzMyBDNjQuNjk4ODgsMjYuMDk1Nzg2NyA2My40MTMzMzMzLDI3LjM2MjU2IDYzLjUyNjgyNjcsMjkuOTM0OTMzMyBMNjMuOTgzMzYsNDAuMjc3MzMzMyBMNTguODEyMTYsNDAuNTA1NiBMNTguMzYyNDUzMywzMC4zMjA2NCBDNTguMTAwNDgsMjQuMzg4MjY2NyA2MS4zNzIxNiwyMS42Mzk2OCA2Ni41OTU4NCwyMS40MDkyOCBDNzEuODE5OTQ2NywyMS4xNzg0NTMzIDc1LjIxODM0NjcsMjMuNjg0NjkzMyA3NS40NzIyMTMzLDI5LjQzMzYgTDc1LjQ3MjIxMzMsMjkuNDMzNiBaXCI+XG48L3BhdGg+XG5cdFx0XHQ8cGF0aCBkPVwiTTM5LjUzOTYyNjcsMzIuODA2ODI2NyBMNDQuODY3NDEzMywzNC4yNDUxMiBMNDMuNzAzMDQsMzguNTU3ODY2NyBMMjguMTI1MDEzMywzNC4zNTMwNjY3IEwyOS4yODkzODY3LDMwLjAzOTg5MzMgTDM0LjYxNzE3MzMsMzEuNDc4MTg2NyBMMzguMjQ2ODI2NywxOC4wMzEzNiBMNDMuMTY4ODUzMywxOS4zNiBMMzkuNTM5NjI2NywzMi44MDY4MjY3IEwzOS41Mzk2MjY3LDMyLjgwNjgyNjcgWlwiPlxuPC9wYXRoPlxuXHRcdFx0PHBhdGggZD1cIk0xNC4zNTczMzMzLDI5LjA1OTQxMzMgTDkuOTg0NDI2NjcsMjYuNDM4ODI2NyBMMTMuNTIzNjI2NywyMC41MzMzMzMzIEw3LjkxMTY4LDE3LjE2OTQ5MzMgTDQuMzcyNDgsMjMuMDc0OTg2NyBMMCwyMC40NTQ0IEw5LjQ1NjY0LDQuNjc2NjkzMzMgTDEzLjgyOTEyLDcuMjk3NzA2NjcgTDEwLjIzNTczMzMsMTMuMjkzMjI2NyBMMTUuODQ4MTA2NywxNi42NTcwNjY3IEwxOS40NDE0OTMzLDEwLjY2MTU0NjcgTDIzLjgxMzk3MzMsMTMuMjgyNTYgTDE0LjM1NzMzMzMsMjkuMDU5NDEzMyBMMTQuMzU3MzMzMywyOS4wNTk0MTMzIFpcIj5cbjwvcGF0aD5cblx0XHQ8L2c+XG5cdDwvZz5cbjwvc3ZnPmA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuIiwgImltcG9ydCB7IGNvbXBpbGVFcnJvcnMsIHZhbGlkYXRlIH0gZnJvbSBcIkByZWFkbWUvb3BlbmFwaS1wYXJzZXJcIjtcbmltcG9ydCB7IE9wZW5BUElWMiwgT3BlbkFQSVYzLCBPcGVuQVBJVjNfMSB9IGZyb20gXCJvcGVuYXBpLXR5cGVzXCI7XG5cbmV4cG9ydCB0eXBlIE9wZW5BcGkzRG9jdW1lbnQgPSBPcGVuQVBJVjMuRG9jdW1lbnQgfCBPcGVuQVBJVjNfMS5Eb2N1bWVudDtcbmV4cG9ydCB0eXBlIE9wZW5BcGlEb2N1bWVudCA9IE9wZW5BUElWMi5Eb2N1bWVudCB8IE9wZW5BcGkzRG9jdW1lbnQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlbkFwaVZhbGlkYXRpb25FcnJvciB7XG4gIGVycm9yOiBcImludmFsaWRfb3BlbmFwaVwiO1xuICBlcnJvckRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU9wZW5BcGlDb250ZW50ID0gYXN5bmMgKGNvbnRlbnQ6IHVua25vd24pOiBQcm9taXNlPE9wZW5BcGlWYWxpZGF0aW9uRXJyb3IgfCBudWxsPiA9PiB7XG4gIGlmICghY29udGVudCB8fCB0eXBlb2YgY29udGVudCAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogXCJpbnZhbGlkX29wZW5hcGlcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiT3BlbkFQSSBjb250ZW50IGlzIGVtcHR5XCIsXG4gICAgfTtcbiAgfVxuICBpZiAoIShcImluZm9cIiBpbiBjb250ZW50KSB8fCAhY29udGVudC5pbmZvIHx8IHR5cGVvZiBjb250ZW50LmluZm8gIT09IFwib2JqZWN0XCIgfHwgIShcInRpdGxlXCIgaW4gY29udGVudC5pbmZvKSkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogXCJpbnZhbGlkX29wZW5hcGlcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiT3BlbkFQSSBpbmZvIHNlY3Rpb24gaXMgcmVxdWlyZWQgYW5kIG11c3QgaW5jbHVkZSBhIHRpdGxlXCIsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFNlcnZlcnMgYXJlIG9wdGlvbmFsLCBidXQgaWYgdGhleSBleGlzdCwgdGhleSBtdXN0IGhhdmUgYSB1cmwgcHJvcGVydHlcbiAgaWYgKFwic2VydmVyc1wiIGluIGNvbnRlbnQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29udGVudC5zZXJ2ZXJzKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IFwiaW52YWxpZF9vcGVuYXBpXCIsXG4gICAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiU2VydmVycyBtdXN0IGJlIGFuIGFycmF5IGluIHRoZSBPcGVuQVBJIHNwZWNpZmljYXRpb25cIixcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGhhc1ZhbGlkU2VydmVyID0gY29udGVudC5zZXJ2ZXJzLnNvbWUoXG4gICAgICAoc2VydmVyKSA9PiBzZXJ2ZXIgJiYgdHlwZW9mIHNlcnZlciA9PT0gXCJvYmplY3RcIiAmJiBcInVybFwiIGluIHNlcnZlciAmJiB0eXBlb2Ygc2VydmVyLnVybCA9PT0gXCJzdHJpbmdcIixcbiAgICApO1xuXG4gICAgaWYgKCFoYXNWYWxpZFNlcnZlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IFwiaW52YWxpZF9vcGVuYXBpXCIsXG4gICAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiQXQgbGVhc3Qgb25lIHNlcnZlciBtdXN0IGhhdmUgYSB2YWxpZCBVUkwgaW4gdGhlIE9wZW5BUEkgc3BlY2lmaWNhdGlvblwiLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlKGNvbnRlbnQgYXMgT3BlbkFwaURvY3VtZW50KTtcbiAgICBpZiAocmVzdWx0LnZhbGlkID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBcImludmFsaWRfb3BlbmFwaVwiLFxuICAgICAgZXJyb3JEZXNjcmlwdGlvbjogY29tcGlsZUVycm9ycyhyZXN1bHQpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBcImludmFsaWRfb3BlbmFwaVwiLFxuICAgICAgZXJyb3JEZXNjcmlwdGlvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkludmFsaWQgT3BlbkFQSSBzcGVjaWZpY2F0aW9uXCIsXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFNlcnZlclVybEZyb21PcGVuQXBpID0gKG9wZW5BcGlDb250ZW50OiBPcGVuQXBpM0RvY3VtZW50KTogc3RyaW5nID0+IHtcbiAgaWYgKCFvcGVuQXBpQ29udGVudC5zZXJ2ZXJzPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0U2VydmVyID0gb3BlbkFwaUNvbnRlbnQuc2VydmVyc1swXTtcbiAgaWYgKCFmaXJzdFNlcnZlcj8udXJsIHx8IHR5cGVvZiBmaXJzdFNlcnZlci51cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIHJldHVybiBmaXJzdFNlcnZlci51cmw7XG59O1xuIiwgImltcG9ydCBzbmFrZUNhc2UgZnJvbSBcImxvZGFzaC9zbmFrZUNhc2UuanNcIjtcbmltcG9ydCB7IE9wZW5BUElWMyB9IGZyb20gXCJvcGVuYXBpLXR5cGVzXCI7XG5cbmV4cG9ydCBjb25zdCBUT09MX05BTUVfTUFYX0xFTkdUSCA9IHByb2Nlc3MuZW52LlRPT0xfTkFNRV9NQVhfTEVOR1RIID8gcGFyc2VJbnQocHJvY2Vzcy5lbnYuVE9PTF9OQU1FX01BWF9MRU5HVEgpIDogNjA7XG5cbmV4cG9ydCBjb25zdCBnZXRUb29sTmFtZSA9IChvcGVyYXRpb246IE9wZW5BUElWMy5PcGVyYXRpb25PYmplY3QsIG1ldGhvZDogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBpZiAob3BlcmF0aW9uLm9wZXJhdGlvbklkKSB7XG4gICAgcmV0dXJuIHNuYWtlQ2FzZShvcGVyYXRpb24ub3BlcmF0aW9uSWQpO1xuICB9XG4gIGlmIChvcGVyYXRpb24uc3VtbWFyeSkge1xuICAgIHJldHVybiBzbmFrZUNhc2Uob3BlcmF0aW9uLnN1bW1hcnkpO1xuICB9XG4gIHJldHVybiBzbmFrZUNhc2UoYCR7bWV0aG9kfV8ke3BhdGh9YCkuc2xpY2UoMCwgVE9PTF9OQU1FX01BWF9MRU5HVEgpO1xufTtcbiIsICJpbXBvcnQge1xuICBDcmVhdGVTZXJ2ZXJSZXF1ZXN0LFxuICBDcmVhdGVUb29sUmVxdWVzdCxcbiAgRm9sZGVyLFxuICBGb3JtYXR0aW5nQ29uZmlnLFxuICB0eXBlIEh0dHBNZXRob2QsXG4gIE1jcFNlcnZlcixcbiAgUGFyYW1ldGVyLFxuICBQYXJhbWV0ZXJMb2NhdGlvbixcbiAgUmVxdWVzdFBhcmFtQ29uZmlnLFxuICBSZXNwb25zZSxcbiAgU2VydmVyQXV0aFR5cGUsXG4gIFRvb2wsXG4gIFVwZGF0ZVNlcnZlclJlcXVlc3QsXG4gIFVwZGF0ZVRvb2xSZXF1ZXN0LFxufSBmcm9tIFwiQGFnZW50YnJpZGdlL2FwaVwiO1xuaW1wb3J0IHtcbiAgQXBpS2V5UHJvdmlkZXIgYXMgUHJpc21hQXBpS2V5UHJvdmlkZXIsXG4gIE9BdXRoUHJvdmlkZXIgYXMgUHJpc21hT0F1dGhQcm92aWRlcixcbiAgTWNwU2VydmVyIGFzIFByaXNtYVNlcnZlcixcbiAgVG9vbCBhcyBQcmlzbWFUb29sLFxufSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcbmltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gXCJAcHJpc21hL2NsaWVudC9leHRlbnNpb25cIjtcbmltcG9ydCBncm91cEJ5IGZyb20gXCJsb2Rhc2gvZ3JvdXBCeS5qc1wiO1xuaW1wb3J0IG9taXQgZnJvbSBcImxvZGFzaC9vbWl0LmpzXCI7XG5pbXBvcnQgc25ha2VDYXNlIGZyb20gXCJsb2Rhc2gvc25ha2VDYXNlLmpzXCI7XG5pbXBvcnQgeyBPcGVuQVBJVjMgfSBmcm9tIFwib3BlbmFwaS10eXBlc1wiO1xuaW1wb3J0IHsgUGFnaW5hdGVkTGlzdCB9IGZyb20gXCIuLi90eXBlcy9kYXRhLnR5cGVzLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBR0VfU0laRSB9IGZyb20gXCIuLi91dGlscy9jb25maWcuanNcIjtcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSBcIi4uL3V0aWxzL2Nvbm5lY3Rpb24uanNcIjtcbmltcG9ydCB7IGdlbmVyYXRlUmVxdWVzdE92ZXJyaWRlc0Zyb21PcGVyYXRpb24gfSBmcm9tIFwiLi4vdXRpbHMvZ2VuZXJhdGVSZXF1ZXN0T3ZlcnJpZGVzLmpzXCI7XG5pbXBvcnQgeyBnZXRJY29uIH0gZnJvbSBcIi4uL3V0aWxzL2ljb25zLmpzXCI7XG5pbXBvcnQgeyBnZXRTZXJ2ZXJVcmxGcm9tT3BlbkFwaSwgT3BlbkFwaTNEb2N1bWVudCB9IGZyb20gXCIuLi91dGlscy9vcGVuYXBpLmpzXCI7XG5pbXBvcnQgeyBnZXRUb29sTmFtZSwgVE9PTF9OQU1FX01BWF9MRU5HVEggfSBmcm9tIFwiLi4vdXRpbHMvdG9vbHMuanNcIjtcblxuY29uc3QgbWFwU2VydmVyID0gKHNlcnZlcjogUHJpc21hU2VydmVyICYgeyBfY291bnQ/OiB7IHRvb2xzOiBudW1iZXIgfSB9KTogTWNwU2VydmVyID0+ICh7XG4gIC4uLnNlcnZlcixcbiAgZGVzY3JpcHRpb246IHNlcnZlci5kZXNjcmlwdGlvbiB8fCB1bmRlZmluZWQsXG4gIHRvb2xDb3VudDogc2VydmVyLl9jb3VudD8udG9vbHMsXG4gIGF1dGhUeXBlOiBzZXJ2ZXIuYXV0aFR5cGUgYXMgU2VydmVyQXV0aFR5cGUsXG4gIGF1dGhDb25maWdJZDogc2VydmVyLmF1dGhDb25maWdJZCB8fCB1bmRlZmluZWQsXG4gIGNyZWF0ZWRBdDogc2VydmVyLmNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICB1cGRhdGVkQXQ6IHNlcnZlci51cGRhdGVkQXQudG9JU09TdHJpbmcoKSxcbn0pO1xuXG50eXBlIFNlcnZlcldpdGhBdXRoQ29uZmlnID0gUHJpc21hU2VydmVyICYge1xuICBfY291bnQ/OiB7IHRvb2xzOiBudW1iZXIgfTtcbiAgYXV0aENvbmZpZz86IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHNlcnZlcklkOiBzdHJpbmc7XG4gICAgYXV0aFR5cGU6IHN0cmluZztcbiAgICBjcmVhdGVkQXQ6IERhdGU7XG4gICAgdXBkYXRlZEF0OiBEYXRlO1xuICAgIGp3dFByb3ZpZGVyPzoge1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIGp3a3NVcmw6IHN0cmluZztcbiAgICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgfSB8IG51bGw7XG4gIH0gfCBudWxsO1xufTtcblxuY29uc3QgbWFwU2VydmVyV2l0aEF1dGggPSAoc2VydmVyOiBTZXJ2ZXJXaXRoQXV0aENvbmZpZykgPT4gKHtcbiAgLi4ubWFwU2VydmVyKHNlcnZlciksXG4gIGF1dGhDb25maWc6IHNlcnZlci5hdXRoQ29uZmlnXG4gICAgPyB7XG4gICAgICAgIGlkOiBzZXJ2ZXIuYXV0aENvbmZpZy5pZCxcbiAgICAgICAgc2VydmVySWQ6IHNlcnZlci5hdXRoQ29uZmlnLnNlcnZlcklkLFxuICAgICAgICBhdXRoVHlwZTogc2VydmVyLmF1dGhDb25maWcuYXV0aFR5cGUgYXMgU2VydmVyQXV0aFR5cGUsXG4gICAgICAgIGNyZWF0ZWRBdDogc2VydmVyLmF1dGhDb25maWcuY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHVwZGF0ZWRBdDogc2VydmVyLmF1dGhDb25maWcudXBkYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGp3dFByb3ZpZGVyOiBzZXJ2ZXIuYXV0aENvbmZpZy5qd3RQcm92aWRlclxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBpZDogc2VydmVyLmF1dGhDb25maWcuand0UHJvdmlkZXIuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IHNlcnZlci5hdXRoQ29uZmlnLmp3dFByb3ZpZGVyLm5hbWUsXG4gICAgICAgICAgICAgIGp3a3NVcmw6IHNlcnZlci5hdXRoQ29uZmlnLmp3dFByb3ZpZGVyLmp3a3NVcmwsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHNlcnZlci5hdXRoQ29uZmlnLmp3dFByb3ZpZGVyLmVuYWJsZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICB9XG4gICAgOiB1bmRlZmluZWQsXG59KTtcblxuY29uc3QgbWFwVG9vbCA9ICh0b29sOiBQcmlzbWFUb29sLCBhZG1pbkF1dGhvcml6ZWQgPSBmYWxzZSk6IFRvb2wgPT4gKHtcbiAgLi4udG9vbCxcbiAgZm9sZGVySWQ6IHRvb2wuZm9sZGVySWQgfHwgdW5kZWZpbmVkLFxuICBwYXJhbWV0ZXJzOiAodG9vbC5wYXJhbWV0ZXJzIGFzIFJlY29yZDxzdHJpbmcsIFBhcmFtZXRlcj4pIHx8IHt9LFxuICBtZXRob2Q6IHRvb2wubWV0aG9kIGFzIEh0dHBNZXRob2QsXG4gIG9BdXRoUHJvdmlkZXJJZDogdG9vbC5vQXV0aFByb3ZpZGVySWQgfHwgdW5kZWZpbmVkLFxuICBhcGlLZXlQcm92aWRlcklkOiB0b29sLmFwaUtleVByb3ZpZGVySWQgfHwgdW5kZWZpbmVkLFxuICByZXNwb25zZUZvcm1hdHRpbmc6IHRvb2wucmVzcG9uc2VGb3JtYXR0aW5nIGFzIEZvcm1hdHRpbmdDb25maWcgfCB1bmRlZmluZWQsXG4gIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXM6IHRvb2wucmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyBhcyBSZWNvcmQ8c3RyaW5nLCBSZXF1ZXN0UGFyYW1Db25maWc+IHwgbnVsbCxcbiAgcmVzcG9uc2VzOiB0b29sLnJlc3BvbnNlcyBhcyBSZWNvcmQ8c3RyaW5nLCBSZXNwb25zZT4gfCB1bmRlZmluZWQsXG4gIGFkbWluQXV0aG9yaXplZCxcbiAgZW5hYmxlZDogdG9vbC5lbmFibGVkLFxuICBjcmVhdGVkQXQ6IHRvb2wuY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gIHVwZGF0ZWRBdDogdG9vbC51cGRhdGVkQXQudG9JU09TdHJpbmcoKSxcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBdXRoUHJvdmlkZXJGcm9tT3BlbkFwaShcbiAgdHg6IFByaXNtYUNsaWVudCxcbiAgc2VydmVyTmFtZTogc3RyaW5nLFxuICBvcGVuQXBpQ29udGVudDogT3BlbkFwaTNEb2N1bWVudCxcbiAgdGVuYW50SWQ6IHN0cmluZyxcbik6IFByb21pc2U8eyBwcm92aWRlcjogUHJpc21hT0F1dGhQcm92aWRlciB8IFByaXNtYUFwaUtleVByb3ZpZGVyOyBzcGVjTmFtZTogc3RyaW5nIH1bXT4ge1xuICBjb25zdCBwcm92aWRlcnM6IHsgcHJvdmlkZXI6IFByaXNtYU9BdXRoUHJvdmlkZXIgfCBQcmlzbWFBcGlLZXlQcm92aWRlcjsgc3BlY05hbWU6IHN0cmluZyB9W10gPSBbXTtcblxuICBmb3IgKGNvbnN0IFtuYW1lLCBvYXV0aFNjaGVtZV0gb2YgT2JqZWN0LmVudHJpZXMob3BlbkFwaUNvbnRlbnQ/LmNvbXBvbmVudHM/LnNlY3VyaXR5U2NoZW1lcyB8fCB7fSkpIHtcbiAgICBpZiAoXCJ0eXBlXCIgaW4gb2F1dGhTY2hlbWUgJiYgb2F1dGhTY2hlbWUudHlwZSA9PT0gXCJvYXV0aDJcIikge1xuICAgICAgaWYgKCFvYXV0aFNjaGVtZS5mbG93cz8uYXV0aG9yaXphdGlvbkNvZGU/LmF1dGhvcml6YXRpb25VcmwgfHwgIW9hdXRoU2NoZW1lLmZsb3dzPy5hdXRob3JpemF0aW9uQ29kZT8udG9rZW5VcmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBPQXV0aCBVUkxzIGluIHNlY3VyaXR5IHNjaGVtZVwiKTtcbiAgICAgIH1cbiAgICAgIHByb3ZpZGVycy5wdXNoKHtcbiAgICAgICAgc3BlY05hbWU6IG5hbWUsXG4gICAgICAgIHByb3ZpZGVyOiBhd2FpdCB0eC5vQXV0aFByb3ZpZGVyLmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbmFtZTogc2VydmVyTmFtZSArIFwiIE9BdXRoXCIsXG4gICAgICAgICAgICBjbGllbnRJZDogXCJcIixcbiAgICAgICAgICAgIGNsaWVudFNlY3JldDogXCJcIixcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Vcmw6IG9hdXRoU2NoZW1lLmZsb3dzLmF1dGhvcml6YXRpb25Db2RlLmF1dGhvcml6YXRpb25VcmwsXG4gICAgICAgICAgICB0b2tlblVybDogb2F1dGhTY2hlbWUuZmxvd3MuYXV0aG9yaXphdGlvbkNvZGUudG9rZW5VcmwsXG4gICAgICAgICAgICBzY29wZXM6IG9hdXRoU2NoZW1lLmZsb3dzLmF1dGhvcml6YXRpb25Db2RlLnNjb3Blc1xuICAgICAgICAgICAgICA/IE9iamVjdC5rZXlzKG9hdXRoU2NoZW1lLmZsb3dzLmF1dGhvcml6YXRpb25Db2RlLnNjb3BlcylcbiAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgICAgc3ZnOiBnZXRJY29uKFwib2F1dGhHZW5lcmljXCIpLFxuICAgICAgICAgICAgcmVmcmVzaFVybDogb2F1dGhTY2hlbWUuZmxvd3MuYXV0aG9yaXphdGlvbkNvZGUucmVmcmVzaFVybCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgW25hbWUsIGFwaUtleVNjaGVtZV0gb2YgT2JqZWN0LmVudHJpZXMob3BlbkFwaUNvbnRlbnQ/LmNvbXBvbmVudHM/LnNlY3VyaXR5U2NoZW1lcyB8fCB7fSkpIHtcbiAgICBpZiAoXCJ0eXBlXCIgaW4gYXBpS2V5U2NoZW1lICYmIGFwaUtleVNjaGVtZS50eXBlID09PSBcImFwaUtleVwiKSB7XG4gICAgICBwcm92aWRlcnMucHVzaCh7XG4gICAgICAgIHNwZWNOYW1lOiBuYW1lLFxuICAgICAgICBwcm92aWRlcjogYXdhaXQgdHguYXBpS2V5UHJvdmlkZXIuY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB2YWx1ZTogc2VydmVyTmFtZSArIFwiIEFQSSBLZXlcIixcbiAgICAgICAgICAgIGtleU5hbWU6IGFwaUtleVNjaGVtZS5uYW1lLFxuICAgICAgICAgICAga2V5SW46IGFwaUtleVNjaGVtZS5pbixcbiAgICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3ZpZGVycztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNlcnZlcihkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHNlcnZlcjogQ3JlYXRlU2VydmVyUmVxdWVzdCkge1xuICByZXR1cm4gYXdhaXQgZGIubWNwU2VydmVyLmNyZWF0ZSh7XG4gICAgZGF0YTogeyAuLi5zZXJ2ZXIsIHRlbmFudElkIH0sXG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmVyc0ZvclRlbmFudChkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPFBhZ2luYXRlZExpc3Q8TWNwU2VydmVyPj4ge1xuICBjb25zdCBzZXJ2ZXJzID0gYXdhaXQgZGIubWNwU2VydmVyLmZpbmRNYW55KHtcbiAgICB3aGVyZToge1xuICAgICAgdGVuYW50SWQ6IHRlbmFudElkLFxuICAgIH0sXG4gICAgaW5jbHVkZToge1xuICAgICAgX2NvdW50OiB7XG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIHRvb2xzOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIG9yZGVyQnk6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJhc2NcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcImFzY1wiLFxuICAgICAgfSxcbiAgICBdLFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGRhdGE6IHNlcnZlcnMubWFwKG1hcFNlcnZlciksXG4gICAgcGFnaW5hdGlvbjoge1xuICAgICAgY3VycmVudFBhZ2U6IDEsXG4gICAgICBpdGVtc1BlclBhZ2U6IERFRkFVTFRfUEFHRV9TSVpFLFxuICAgICAgdG90YWxJdGVtczogc2VydmVycy5sZW5ndGgsXG4gICAgICB0b3RhbFBhZ2VzOiBNYXRoLmNlaWwoc2VydmVycy5sZW5ndGggLyBERUZBVUxUX1BBR0VfU0laRSksXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlcnZlckJ5SWQoZGI6IERhdGFiYXNlLCB0ZW5hbnRJZDogc3RyaW5nLCBzZXJ2ZXJJZDogc3RyaW5nKSB7XG4gIGNvbnN0IHNlcnZlciA9IGF3YWl0IGRiLm1jcFNlcnZlci5maW5kVW5pcXVlKHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IHNlcnZlcklkLFxuICAgICAgdGVuYW50SWQsXG4gICAgfSxcbiAgICBpbmNsdWRlOiB7XG4gICAgICBhdXRoQ29uZmlnOiB7XG4gICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICBqd3RQcm92aWRlcjogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG4gIHJldHVybiBzZXJ2ZXIgPyBtYXBTZXJ2ZXJXaXRoQXV0aChzZXJ2ZXIpIDogbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVNlcnZlckJ5SWQoXG4gIGRiOiBEYXRhYmFzZSxcbiAgdGVuYW50SWQ6IHN0cmluZyxcbiAgc2VydmVySWQ6IHN0cmluZyxcbiAgdXBkYXRlRGF0YTogVXBkYXRlU2VydmVyUmVxdWVzdCxcbikge1xuICByZXR1cm4gbWFwU2VydmVyKFxuICAgIGF3YWl0IGRiLm1jcFNlcnZlci51cGRhdGUoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgaWQ6IHNlcnZlcklkLFxuICAgICAgICB0ZW5hbnRJZCxcbiAgICAgIH0sXG4gICAgICBkYXRhOiB1cGRhdGVEYXRhLFxuICAgIH0pLFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlU2VydmVyQnlJZChkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHNlcnZlcklkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIG1hcFNlcnZlcihcbiAgICBhd2FpdCBkYi5tY3BTZXJ2ZXIuZGVsZXRlKHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIGlkOiBzZXJ2ZXJJZCxcbiAgICAgICAgdGVuYW50SWQsXG4gICAgICB9LFxuICAgIH0pLFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmVyU2xpbShkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHNlcnZlcklkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGF3YWl0IGRiLm1jcFNlcnZlci5maW5kVW5pcXVlKHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IHNlcnZlcklkLFxuICAgICAgdGVuYW50SWQsXG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGlkOiB0cnVlLFxuICAgICAgdGVuYW50SWQ6IHRydWUsXG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUb29sc0Zyb21PcGVuQXBpU3BlYyhcbiAgZGI6IERhdGFiYXNlLFxuICB0ZW5hbnRJZDogc3RyaW5nLFxuICBzZXJ2ZXJJZDogc3RyaW5nLFxuICBvcGVuQXBpQ29udGVudDogT3BlbkFwaTNEb2N1bWVudCxcbiAgc2VsZWN0ZWRUb29scz86IHN0cmluZ1tdLFxuKSB7XG4gIHJldHVybiBhd2FpdCBkYi4kdHJhbnNhY3Rpb24oYXN5bmMgKHR4OiBQcmlzbWFDbGllbnQpID0+IHtcbiAgICBjb25zdCBmb2xkZXJzQnlOYW1lOiBSZWNvcmQ8c3RyaW5nLCBGb2xkZXI+ID0ge307XG4gICAgY29uc3QgY3JlYXRlZFRvb2xzOiBUb29sW10gPSBbXTtcblxuICAgIC8vIEdldCBleGlzdGluZyBmb2xkZXJzIGZvciB0aGlzIHNlcnZlclxuICAgIGNvbnN0IGV4aXN0aW5nRm9sZGVycyA9IGF3YWl0IHR4LmZvbGRlci5maW5kTWFueSh7XG4gICAgICB3aGVyZTogeyBzZXJ2ZXJJZCwgdGVuYW50SWQgfSxcbiAgICB9KTtcbiAgICBleGlzdGluZ0ZvbGRlcnMuZm9yRWFjaCgoZm9sZGVyOiBGb2xkZXIpID0+IHtcbiAgICAgIGZvbGRlcnNCeU5hbWVbZm9sZGVyLm5hbWVdID0gZm9sZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGF1dGggcHJvdmlkZXJzXG4gICAgY29uc3QgcHJvdmlkZXJzID0gYXdhaXQgY3JlYXRlQXV0aFByb3ZpZGVyRnJvbU9wZW5BcGkodHgsIGBTZXJ2ZXIgJHtzZXJ2ZXJJZH1gLCBvcGVuQXBpQ29udGVudCwgdGVuYW50SWQpO1xuICAgIGNvbnN0IG9hdXRoUHJvdmlkZXJzQnlOYW1lID0gZ3JvdXBCeShcbiAgICAgIHByb3ZpZGVycy5maWx0ZXIoKHApID0+IFwiYXV0aG9yaXphdGlvblVybFwiIGluIHAucHJvdmlkZXIpLFxuICAgICAgXCJzcGVjTmFtZVwiLFxuICAgICk7XG4gICAgY29uc3QgYXBpS2V5UHJvdmlkZXJzQnlOYW1lID0gZ3JvdXBCeShcbiAgICAgIHByb3ZpZGVycy5maWx0ZXIoKHApID0+IFwia2V5SW5cIiBpbiBwLnByb3ZpZGVyKSxcbiAgICAgIFwic3BlY05hbWVcIixcbiAgICApO1xuXG4gICAgaWYgKG9wZW5BcGlDb250ZW50LnBhdGhzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtwYXRoLCBwYXRoSXRlbV0gb2YgT2JqZWN0LmVudHJpZXMob3BlbkFwaUNvbnRlbnQucGF0aHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aEl0ZW0gPT09IFwib2JqZWN0XCIgJiYgcGF0aEl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFttZXRob2QsIG9wZXJhdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMocGF0aEl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBvcGVyYXRpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgb3BlcmF0aW9uICE9PSBudWxsICYmXG4gICAgICAgICAgICAgIChcIm9wZXJhdGlvbklkXCIgaW4gb3BlcmF0aW9uIHx8IFwicmVzcG9uc2VzXCIgaW4gb3BlcmF0aW9uKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPVxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5wYXJhbWV0ZXJzPy5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgICAoYWNjLCBwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcIm9iamVjdFwiICYmIHBhcmFtICE9PSBudWxsICYmIFwibmFtZVwiIGluIHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWNjW3BhcmFtLm5hbWVdID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBPcGVuQVBJVjMuUGFyYW1ldGVyT2JqZWN0PixcbiAgICAgICAgICAgICAgICApIHx8IHt9O1xuXG4gICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ucmVxdWVzdEJvZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IG9wZXJhdGlvbi5yZXF1ZXN0Qm9keTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RCb2R5ID09PSBcIm9iamVjdFwiICYmIFwiY29udGVudFwiIGluIHJlcXVlc3RCb2R5KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBqc29uQ29udGVudCA9IHJlcXVlc3RCb2R5LmNvbnRlbnQ/LltcImFwcGxpY2F0aW9uL2pzb25cIl07XG4gICAgICAgICAgICAgICAgICBpZiAoanNvbkNvbnRlbnQ/LnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW1wiYm9keVwiXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBpbjogXCJib2R5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJib2R5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBqc29uQ29udGVudC5zY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHJlcXVlc3RCb2R5LnJlcXVpcmVkID8/IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IGZvbGRlcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgY29uc3QgdGFncyA9IG9wZXJhdGlvbi50YWdzIHx8IFtdO1xuICAgICAgICAgICAgICBpZiAodGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFnID0gdGFnc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbGRlcnNCeU5hbWVbdGFnXSkge1xuICAgICAgICAgICAgICAgICAgZm9sZGVyc0J5TmFtZVt0YWddID0gYXdhaXQgdHguZm9sZGVyLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgc2VydmVySWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9sZGVySWQgPSBmb2xkZXJzQnlOYW1lW3RhZ10uaWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZXQgYXBpS2V5UHJvdmlkZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgIGxldCBvQXV0aFByb3ZpZGVySWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICBjb25zdCBzZWN1cml0eVNwZWNOYW1lcyA9IG9wZXJhdGlvbi5zZWN1cml0eT8uZmxhdE1hcCgoc2VjKSA9PiBPYmplY3Qua2V5cyhzZWMpKSB8fCBbXTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBzZWN1cml0eSBvZiBzZWN1cml0eVNwZWNOYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXlQcm92aWRlcnNCeU5hbWVbc2VjdXJpdHldKSB7XG4gICAgICAgICAgICAgICAgICBhcGlLZXlQcm92aWRlcklkID0gYXBpS2V5UHJvdmlkZXJzQnlOYW1lW3NlY3VyaXR5XVswXS5wcm92aWRlci5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9hdXRoUHJvdmlkZXJzQnlOYW1lW3NlY3VyaXR5XSkge1xuICAgICAgICAgICAgICAgICAgb0F1dGhQcm92aWRlcklkID0gb2F1dGhQcm92aWRlcnNCeU5hbWVbc2VjdXJpdHldWzBdLnByb3ZpZGVyLmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gZ2V0VG9vbE5hbWUob3BlcmF0aW9uLCBtZXRob2QsIHBhdGgpO1xuICAgICAgICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gc2VsZWN0ZWRUb29sc1xuICAgICAgICAgICAgICAgID8gc2VsZWN0ZWRUb29scy5zb21lKChzZWxlY3RlZFRvb2wpID0+IHNlbGVjdGVkVG9vbC50b0xvd2VyQ2FzZSgpID09PSB0b29sTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICAgIDogdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRUb29sID0gYXdhaXQgdHgudG9vbC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wZXJhdGlvbi5zdW1tYXJ5IHx8IG9wZXJhdGlvbi5kZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZXM6IG9wZXJhdGlvbi5yZXNwb25zZXMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCkgYXMgSHR0cE1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdHRpbmc6IHt9LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzOiBnZW5lcmF0ZVJlcXVlc3RPdmVycmlkZXNGcm9tT3BlcmF0aW9uKG9wZXJhdGlvbiwgcGF0aEl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICB0ZW5hbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVySWQsXG4gICAgICAgICAgICAgICAgICAgIGZvbGRlcklkLFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXlQcm92aWRlcklkLFxuICAgICAgICAgICAgICAgICAgICBvQXV0aFByb3ZpZGVySWQsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRUb29scy5wdXNoKG1hcFRvb2woY3JlYXRlZFRvb2wpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b29sczogY3JlYXRlZFRvb2xzLFxuICAgICAgYXV0aFByb3ZpZGVyczogcHJvdmlkZXJzLm1hcCgocCkgPT4gcC5wcm92aWRlciksXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVTZXJ2ZXJGcm9tT3BlbkFwaVNwZWMoXG4gIGRiOiBEYXRhYmFzZSxcbiAgdGVuYW50SWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgZGVzY3JpcHRpb246IHN0cmluZyB8IG51bGwsXG4gIG9wZW5BcGlDb250ZW50OiBPcGVuQXBpM0RvY3VtZW50LFxuICBzZWxlY3RlZFRvb2xzPzogc3RyaW5nW10sXG4pIHtcbiAgcmV0dXJuIGF3YWl0IGRiLiR0cmFuc2FjdGlvbihhc3luYyAodHg6IFByaXNtYUNsaWVudCkgPT4ge1xuICAgIGNvbnN0IGZvbGRlcnNCeU5hbWU6IFJlY29yZDxzdHJpbmcsIEZvbGRlcj4gPSB7fTtcblxuICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHR4Lm1jcFNlcnZlci5jcmVhdGUoe1xuICAgICAgZGF0YToge1xuICAgICAgICBuYW1lOiBuYW1lIHx8IG9wZW5BcGlDb250ZW50LmluZm8udGl0bGUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB8fCBvcGVuQXBpQ29udGVudC5pbmZvLmRlc2NyaXB0aW9uIHx8IFwiXCIsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHRlbmFudElkOiB0ZW5hbnRJZCxcbiAgICAgICAgYmFzZVVybDogZ2V0U2VydmVyVXJsRnJvbU9wZW5BcGkob3BlbkFwaUNvbnRlbnQpLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb3ZpZGVycyA9IGF3YWl0IGNyZWF0ZUF1dGhQcm92aWRlckZyb21PcGVuQXBpKHR4LCBzZXJ2ZXIubmFtZSwgb3BlbkFwaUNvbnRlbnQsIHRlbmFudElkKTtcbiAgICBjb25zdCBvYXV0aFByb3ZpZGVyc0J5TmFtZSA9IGdyb3VwQnkoXG4gICAgICBwcm92aWRlcnMuZmlsdGVyKChwKSA9PiBcImF1dGhvcml6YXRpb25VcmxcIiBpbiBwLnByb3ZpZGVyKSxcbiAgICAgIFwic3BlY05hbWVcIixcbiAgICApO1xuICAgIGNvbnN0IGFwaUtleVByb3ZpZGVyc0J5TmFtZSA9IGdyb3VwQnkoXG4gICAgICBwcm92aWRlcnMuZmlsdGVyKChwKSA9PiBcImtleUluXCIgaW4gcC5wcm92aWRlciksXG4gICAgICBcInNwZWNOYW1lXCIsXG4gICAgKTtcblxuICAgIGlmIChvcGVuQXBpQ29udGVudC5wYXRocykge1xuICAgICAgZm9yIChjb25zdCBbcGF0aCwgcGF0aEl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKG9wZW5BcGlDb250ZW50LnBhdGhzKSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhJdGVtID09PSBcIm9iamVjdFwiICYmIHBhdGhJdGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbbWV0aG9kLCBvcGVyYXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKHBhdGhJdGVtKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2Ygb3BlcmF0aW9uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgIG9wZXJhdGlvbiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAoXCJvcGVyYXRpb25JZFwiIGluIG9wZXJhdGlvbiB8fCBcInJlc3BvbnNlc1wiIGluIG9wZXJhdGlvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID1cbiAgICAgICAgICAgICAgICBvcGVyYXRpb24ucGFyYW1ldGVycz8ucmVkdWNlKFxuICAgICAgICAgICAgICAgICAgKGFjYywgcGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJvYmplY3RcIiAmJiBwYXJhbSAhPT0gbnVsbCAmJiBcIm5hbWVcIiBpbiBwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFjY1twYXJhbS5uYW1lXSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgT3BlbkFQSVYzLlBhcmFtZXRlck9iamVjdD4sXG4gICAgICAgICAgICAgICAgKSB8fCB7fTtcblxuICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLnJlcXVlc3RCb2R5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSBvcGVyYXRpb24ucmVxdWVzdEJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0Qm9keSA9PT0gXCJvYmplY3RcIiAmJiBcImNvbnRlbnRcIiBpbiByZXF1ZXN0Qm9keSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QganNvbkNvbnRlbnQgPSByZXF1ZXN0Qm9keS5jb250ZW50Py5bXCJhcHBsaWNhdGlvbi9qc29uXCJdO1xuICAgICAgICAgICAgICAgICAgaWYgKGpzb25Db250ZW50Py5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc1tcImJvZHlcIl0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW46IFwiYm9keVwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYm9keVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYToganNvbkNvbnRlbnQuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiByZXF1ZXN0Qm9keS5yZXF1aXJlZCA/PyB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBmb2xkZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSBvcGVyYXRpb24udGFncyB8fCBbXTtcbiAgICAgICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRhZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKCFmb2xkZXJzQnlOYW1lW3RhZ10pIHtcbiAgICAgICAgICAgICAgICAgIGZvbGRlcnNCeU5hbWVbdGFnXSA9IGF3YWl0IHR4LmZvbGRlci5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGFnLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgICAgICAgICAgICAgIHNlcnZlcklkOiBzZXJ2ZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9sZGVySWQgPSBmb2xkZXJzQnlOYW1lW3RhZ10uaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGFwaUtleVByb3ZpZGVySWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICBsZXQgb0F1dGhQcm92aWRlcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgY29uc3Qgc2VjdXJpdHlTcGVjTmFtZXMgPSBvcGVyYXRpb24uc2VjdXJpdHk/LmZsYXRNYXAoKHNlYykgPT4gT2JqZWN0LmtleXMoc2VjKSkgfHwgW107XG4gICAgICAgICAgICAgIGZvciAoY29uc3Qgc2VjdXJpdHkgb2Ygc2VjdXJpdHlTcGVjTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5UHJvdmlkZXJzQnlOYW1lW3NlY3VyaXR5XSkge1xuICAgICAgICAgICAgICAgICAgYXBpS2V5UHJvdmlkZXJJZCA9IGFwaUtleVByb3ZpZGVyc0J5TmFtZVtzZWN1cml0eV1bMF0ucHJvdmlkZXIuaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYXV0aFByb3ZpZGVyc0J5TmFtZVtzZWN1cml0eV0pIHtcbiAgICAgICAgICAgICAgICAgIG9BdXRoUHJvdmlkZXJJZCA9IG9hdXRoUHJvdmlkZXJzQnlOYW1lW3NlY3VyaXR5XVswXS5wcm92aWRlci5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBnZXRUb29sTmFtZShvcGVyYXRpb24sIG1ldGhvZCwgcGF0aCk7XG4gICAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZFRvb2xzXG4gICAgICAgICAgICAgICAgPyBzZWxlY3RlZFRvb2xzLnNvbWUoKHNlbGVjdGVkVG9vbCkgPT4gc2VsZWN0ZWRUb29sLnRvTG93ZXJDYXNlKCkgPT09IHRvb2xOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgOiB0cnVlO1xuXG4gICAgICAgICAgICAgIGF3YWl0IHR4LnRvb2wuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcGVyYXRpb24uc3VtbWFyeSB8fCBvcGVyYXRpb24uZGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGlzU2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VzOiBvcGVyYXRpb24ucmVzcG9uc2VzIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSBhcyBIdHRwTWV0aG9kLFxuICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtYXR0aW5nOiB7fSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXM6IGdlbmVyYXRlUmVxdWVzdE92ZXJyaWRlc0Zyb21PcGVyYXRpb24ob3BlcmF0aW9uLCBwYXRoSXRlbSksXG4gICAgICAgICAgICAgICAgICB0ZW5hbnRJZCxcbiAgICAgICAgICAgICAgICAgIHNlcnZlcklkOiBzZXJ2ZXIuaWQsXG4gICAgICAgICAgICAgICAgICBmb2xkZXJJZCxcbiAgICAgICAgICAgICAgICAgIGFwaUtleVByb3ZpZGVySWQsXG4gICAgICAgICAgICAgICAgICBvQXV0aFByb3ZpZGVySWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlcnZlcixcbiAgICAgIG9hdXRoUHJvdmlkZXJzOiBPYmplY3QudmFsdWVzKG9hdXRoUHJvdmlkZXJzQnlOYW1lKS5tYXAoKHByb3ZpZGVycykgPT4gcHJvdmlkZXJzWzBdLnByb3ZpZGVyKSxcbiAgICB9O1xuICB9KTtcbn1cblxuY29uc3QgVE9ET1NfT1BFTkFQSV9TUEVDID0ge1xuICBvcGVuYXBpOiBcIjMuMC4wXCIsXG4gIGluZm86IHtcbiAgICB0aXRsZTogXCJUb2RvcyBBUElcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBIFJFU1QgQVBJIGZvciB0ZXN0aW5nIGFuZCBwcm90b3R5cGluZyBhcHBsaWNhdGlvbnMgdGhhdCBuZWVkIHRvIGludGVyYWN0IHdpdGggYSBUT0RPIGxpc3QuXCIsXG4gICAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICAgIGNvbnRhY3Q6IHtcbiAgICAgIG5hbWU6IFwiVG9kb3MgQVBJXCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9qc29ucGxhY2Vob2xkZXIudHlwaWNvZGUuY29tXCIsXG4gICAgfSxcbiAgfSxcbiAgc2VydmVyczogW1xuICAgIHtcbiAgICAgIHVybDogXCJodHRwczovL2pzb25wbGFjZWhvbGRlci50eXBpY29kZS5jb21cIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkpTT05QbGFjZWhvbGRlciBBUEkgU2VydmVyXCIsXG4gICAgfSxcbiAgXSxcbiAgdGFnczogW1xuICAgIHtcbiAgICAgIG5hbWU6IFwidG9kb3NcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk9wZXJhdGlvbnMgcmVsYXRlZCB0byB0b2RvIGl0ZW1zXCIsXG4gICAgfSxcbiAgXSxcbiAgcGF0aHM6IHtcbiAgICBcIi90b2Rvc1wiOiB7XG4gICAgICBnZXQ6IHtcbiAgICAgICAgb3BlcmF0aW9uSWQ6IFwiZ2V0LWFsbC10b2Rvc1wiLFxuICAgICAgICB0YWdzOiBbXCJ0b2Rvc1wiXSxcbiAgICAgICAgc3VtbWFyeTogXCJHZXQgYWxsIHRvZG9zXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJldHVybnMgYSBsaXN0IG9mIGFsbCB0b2RvIGl0ZW1zXCIsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcInVzZXJJZFwiLFxuICAgICAgICAgICAgaW46IFwicXVlcnlcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbHRlciB0b2RvcyBieSB1c2VyIElEXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgIGZvcm1hdDogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICByZXNwb25zZXM6IHtcbiAgICAgICAgICBcIjIwMFwiOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJBIGxpc3Qgb2YgdG9kbyBpdGVtc1wiLFxuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgJHJlZjogXCIjL2NvbXBvbmVudHMvc2NoZW1hcy9Ub2RvXCIsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcG9zdDoge1xuICAgICAgICBvcGVyYXRpb25JZDogXCJjcmVhdGUtYS1uZXctdG9kb1wiLFxuICAgICAgICB0YWdzOiBbXCJ0b2Rvc1wiXSxcbiAgICAgICAgc3VtbWFyeTogXCJDcmVhdGUgYSBuZXcgdG9kb1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDcmVhdGVzIGEgbmV3IHRvZG8gaXRlbVwiLFxuICAgICAgICByZXF1ZXN0Qm9keToge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvZG8gaXRlbSB0byBjcmVhdGVcIixcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAkcmVmOiBcIiMvY29tcG9uZW50cy9zY2hlbWFzL1RvZG9JbnB1dFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZXM6IHtcbiAgICAgICAgICBcIjIwMVwiOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUb2RvIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5XCIsXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAkcmVmOiBcIiMvY29tcG9uZW50cy9zY2hlbWFzL1RvZG9cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIFwiL3RvZG9zL3tpZH1cIjoge1xuICAgICAgZ2V0OiB7XG4gICAgICAgIG9wZXJhdGlvbklkOiBcImdldC1hLXRvZG9cIixcbiAgICAgICAgdGFnczogW1widG9kb3NcIl0sXG4gICAgICAgIHN1bW1hcnk6IFwiR2V0IGEgdG9kbyBieSBJRFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXR1cm5zIGEgc2luZ2xlIHRvZG8gYnkgSURcIixcbiAgICAgICAgcGFyYW1ldGVyczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgICAgICAgIGluOiBcInBhdGhcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIklEIG9mIHRoZSB0b2RvIHRvIHJldHJpZXZlXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgZm9ybWF0OiBcImludDY0XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHJlc3BvbnNlczoge1xuICAgICAgICAgIFwiMjAwXCI6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvZG8gZm91bmRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICRyZWY6IFwiIy9jb21wb25lbnRzL3NjaGVtYXMvVG9kb1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcHV0OiB7XG4gICAgICAgIG9wZXJhdGlvbklkOiBcInVwZGF0ZS1hLXRvZG9cIixcbiAgICAgICAgdGFnczogW1widG9kb3NcIl0sXG4gICAgICAgIHN1bW1hcnk6IFwiVXBkYXRlIGEgdG9kbyBjb21wbGV0ZWx5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlcGxhY2VzIGFsbCBwcm9wZXJ0aWVzIG9mIGEgdG9kbyBpdGVtXCIsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgICAgICBpbjogXCJwYXRoXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJRCBvZiB0aGUgdG9kbyB0byB1cGRhdGVcIixcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICBmb3JtYXQ6IFwiaW50NjRcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcmVxdWVzdEJvZHk6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJVcGRhdGVkIHRvZG8gb2JqZWN0XCIsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgJHJlZjogXCIjL2NvbXBvbmVudHMvc2NoZW1hcy9Ub2RvVXBkYXRlXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlczoge1xuICAgICAgICAgIFwiMjAwXCI6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRvZG8gdXBkYXRlZCBzdWNjZXNzZnVsbHlcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICRyZWY6IFwiIy9jb21wb25lbnRzL3NjaGVtYXMvVG9kb1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZGVsZXRlOiB7XG4gICAgICAgIG9wZXJhdGlvbklkOiBcImRlbGV0ZS1hLXRvZG9cIixcbiAgICAgICAgdGFnczogW1widG9kb3NcIl0sXG4gICAgICAgIHN1bW1hcnk6IFwiRGVsZXRlIGEgdG9kb1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJEZWxldGVzIGEgdG9kbyBpdGVtXCIsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcImlkXCIsXG4gICAgICAgICAgICBpbjogXCJwYXRoXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJRCBvZiB0aGUgdG9kbyB0byBkZWxldGVcIixcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICBmb3JtYXQ6IFwiaW50NjRcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgcmVzcG9uc2VzOiB7XG4gICAgICAgICAgXCIyMDBcIjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVG9kbyBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBzY2hlbWFzOiB7XG4gICAgICBUb2RvOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHJlcXVpcmVkOiBbXCJpZFwiLCBcInVzZXJJZFwiLCBcInRpdGxlXCIsIFwiY29tcGxldGVkXCJdLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImludDY0XCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHRvZG9cIixcbiAgICAgICAgICAgIGV4YW1wbGU6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VySWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImludDY0XCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJRCBvZiB0aGUgdXNlciB3aG8gb3ducyB0aGlzIHRvZG9cIixcbiAgICAgICAgICAgIGV4YW1wbGU6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRhc2sgZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGV4YW1wbGU6IFwiQ29tcGxldGUgcHJvamVjdCBkb2N1bWVudGF0aW9uXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiV2hldGhlciB0aGUgdGFzayBpcyBjb21wbGV0ZWRcIixcbiAgICAgICAgICAgIGV4YW1wbGU6IGZhbHNlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgVG9kb0lucHV0OiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHJlcXVpcmVkOiBbXCJ1c2VySWRcIiwgXCJ0aXRsZVwiXSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHVzZXJJZDoge1xuICAgICAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiaW50NjRcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIklEIG9mIHRoZSB1c2VyIHdobyBvd25zIHRoaXMgdG9kb1wiLFxuICAgICAgICAgICAgZXhhbXBsZTogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVGFzayBkZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgZXhhbXBsZTogXCJXcml0ZSB1bml0IHRlc3RzXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiV2hldGhlciB0aGUgdGFzayBpcyBjb21wbGV0ZWRcIixcbiAgICAgICAgICAgIGV4YW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBUb2RvVXBkYXRlOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHJlcXVpcmVkOiBbXCJpZFwiLCBcInVzZXJJZFwiLCBcInRpdGxlXCIsIFwiY29tcGxldGVkXCJdLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImludDY0XCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJRCBvZiB0aGUgdG9kbyAobXVzdCBtYXRjaCBwYXRoIHBhcmFtZXRlcilcIixcbiAgICAgICAgICAgIGV4YW1wbGU6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VySWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImludDY0XCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJRCBvZiB0aGUgdXNlciB3aG8gb3ducyB0aGlzIHRvZG9cIixcbiAgICAgICAgICAgIGV4YW1wbGU6IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRhc2sgZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGV4YW1wbGU6IFwiVXBkYXRlZCB0YXNrIGRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiV2hldGhlciB0aGUgdGFzayBpcyBjb21wbGV0ZWRcIixcbiAgICAgICAgICAgIGV4YW1wbGU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVFeGFtcGxlVG9kb3NTZXJ2ZXIoZGI6IERhdGFiYXNlLCB0ZW5hbnRJZDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZVNlcnZlckZyb21PcGVuQXBpU3BlYyhcbiAgICAgIGRiLFxuICAgICAgdGVuYW50SWQsXG4gICAgICBcIlRvZG9zIEFQSSBFeGFtcGxlXCIsXG4gICAgICBcIkEgc2FtcGxlIFRvLURvcyBBUEkgZm9yIHRlc3RpbmcgYW5kIGxlYXJuaW5nIE1DUCBjYXBhYmlsaXRpZXNcIixcbiAgICAgIFRPRE9TX09QRU5BUElfU1BFQyBhcyBPcGVuQXBpM0RvY3VtZW50LFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNyZWF0ZUV4YW1wbGVUb2Rvc1NlcnZlcjpcIiwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUb29sc0ZvclNlcnZlcihkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHNlcnZlcklkOiBzdHJpbmcsIGFkbWluRW1haWw6IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIGF3YWl0IGRiLnRvb2wuZmluZE1hbnkoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgc2VydmVySWQ6IHNlcnZlcklkLFxuICAgICAgICB0ZW5hbnRJZCxcbiAgICAgIH0sXG4gICAgICBpbmNsdWRlOiB7XG4gICAgICAgIG9BdXRoUHJvdmlkZXI6IHtcbiAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICBwcm92aWRlclRva2Vuczoge1xuICAgICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICAgIGVtYWlsOiBhZG1pbkVtYWlsLFxuICAgICAgICAgICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBvcmRlckJ5OiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFzY1wiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwiYXNjXCIsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pXG4gICkubWFwKCh0b29sKSA9PiBtYXBUb29sKHRvb2wsICh0b29sLm9BdXRoUHJvdmlkZXI/LnByb3ZpZGVyVG9rZW5zIHx8IFtdKS5sZW5ndGggPiAwKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUb29sQnlJZChkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHRvb2xJZDogc3RyaW5nLCBhZG1pbkVtYWlsOiBzdHJpbmcpIHtcbiAgY29uc3QgdG9vbCA9IGF3YWl0IGRiLnRvb2wuZmluZFVuaXF1ZSh7XG4gICAgd2hlcmU6IHtcbiAgICAgIGlkOiB0b29sSWQsXG4gICAgICB0ZW5hbnRJZCxcbiAgICB9LFxuICAgIGluY2x1ZGU6IHtcbiAgICAgIG9BdXRoUHJvdmlkZXI6IHtcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIHByb3ZpZGVyVG9rZW5zOiB7XG4gICAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgZW1haWw6IGFkbWluRW1haWwsXG4gICAgICAgICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gdG9vbCA/IG1hcFRvb2wodG9vbCwgKHRvb2wub0F1dGhQcm92aWRlcj8ucHJvdmlkZXJUb2tlbnMgfHwgW10pLmxlbmd0aCA+IDApIDogbnVsbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRvb2woZGI6IERhdGFiYXNlLCBzZXJ2ZXJJZDogc3RyaW5nLCB0ZW5hbnRJZDogc3RyaW5nLCB0b29sRGF0YTogQ3JlYXRlVG9vbFJlcXVlc3QpIHtcbiAgcmV0dXJuIGF3YWl0IGRiLiR0cmFuc2FjdGlvbihhc3luYyAodHg6IFByaXNtYUNsaWVudCkgPT4ge1xuICAgIGlmICh0b29sRGF0YS5vQXV0aFByb3ZpZGVySWQpIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdHgub0F1dGhQcm92aWRlci5maW5kVW5pcXVlKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHRvb2xEYXRhLm9BdXRoUHJvdmlkZXJJZCwgdGVuYW50SWQgfSxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9BdXRoIHByb3ZpZGVyIHdpdGggSUQgJHt0b29sRGF0YS5vQXV0aFByb3ZpZGVySWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b29sRGF0YS5hcGlLZXlQcm92aWRlcklkKSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHR4LmFwaUtleVByb3ZpZGVyLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogdG9vbERhdGEuYXBpS2V5UHJvdmlkZXJJZCwgdGVuYW50SWQgfSxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBLZXkgcHJvdmlkZXIgd2l0aCBJRCAke3Rvb2xEYXRhLmFwaUtleVByb3ZpZGVySWR9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHNlcnZlciBoYXMgSldUIGF1dGhlbnRpY2F0aW9uIGVuYWJsZWRcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0eC5tY3BTZXJ2ZXIuZmluZFVuaXF1ZSh7XG4gICAgICB3aGVyZTogeyBpZDogc2VydmVySWQgfSxcbiAgICAgIHNlbGVjdDogeyBhdXRoVHlwZTogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgLy8gUHJlcGFyZSByZXF1ZXN0IHBhcmFtZXRlciBvdmVycmlkZXMsIGF1dG9tYXRpY2FsbHkgYWRkaW5nIEpXVCBoZWFkZXIgaWYgc2VydmVyIHVzZXMgSldUIGF1dGhcbiAgICBsZXQgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyA9IHRvb2xEYXRhLnJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMgfHwge307XG5cbiAgICBpZiAoc2VydmVyPy5hdXRoVHlwZSA9PT0gU2VydmVyQXV0aFR5cGUuSldUKSB7XG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IGFkZCBKV1QgYXV0aG9yaXphdGlvbiBoZWFkZXIgZm9yIHRvb2xzIG9uIHNlcnZlcnMgd2l0aCBKV1QgYXV0aFxuICAgICAgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyA9IHtcbiAgICAgICAgLi4ucmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyxcbiAgICAgICAgQXV0aG9yaXphdGlvbjoge1xuICAgICAgICAgIHZhbHVlOiBcIkJlYXJlciB7e3Rvb2xQYXJhbXMuand0fX1cIixcbiAgICAgICAgICBsb2NhdGlvbjogUGFyYW1ldGVyTG9jYXRpb24uSEVBREVSLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdHgudG9vbC5jcmVhdGUoe1xuICAgICAgZGF0YToge1xuICAgICAgICBuYW1lOiBzbmFrZUNhc2UodG9vbERhdGEubmFtZSkuc2xpY2UoMCwgVE9PTF9OQU1FX01BWF9MRU5HVEgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogdG9vbERhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgIGZvbGRlcklkOiB0b29sRGF0YS5mb2xkZXJJZCxcbiAgICAgICAgcGFyYW1ldGVyczogdG9vbERhdGEucGFyYW1ldGVycyB8fCB7fSxcbiAgICAgICAgbWV0aG9kOiB0b29sRGF0YS5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgdXJsOiB0b29sRGF0YS51cmwgfHwgXCJcIixcbiAgICAgICAgb0F1dGhQcm92aWRlcklkOiB0b29sRGF0YS5vQXV0aFByb3ZpZGVySWQsXG4gICAgICAgIGFwaUtleVByb3ZpZGVySWQ6IHRvb2xEYXRhLmFwaUtleVByb3ZpZGVySWQsXG4gICAgICAgIHJlc3BvbnNlRm9ybWF0dGluZzogdG9vbERhdGEucmVzcG9uc2VGb3JtYXR0aW5nIHx8IHt9LFxuICAgICAgICByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzOiByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzIHx8IG51bGwsXG4gICAgICAgIHRlbmFudElkOiB0ZW5hbnRJZCxcbiAgICAgICAgc2VydmVySWQ6IHNlcnZlcklkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVUb29sQnlJZChkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHRvb2xJZDogc3RyaW5nLCB1cGRhdGVEYXRhOiBVcGRhdGVUb29sUmVxdWVzdCkge1xuICAvLyBGaWx0ZXIgb3V0IG51bGwgdmFsdWVzIGZvciBKU09OIGZpZWxkcyB0byBhdm9pZCBQcmlzbWEgdHlwZSBpc3N1ZXNcbiAgY29uc3QgeyByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzLCByZXNwb25zZUZvcm1hdHRpbmcsIHBhcmFtZXRlcnMsIHJlc3BvbnNlcywgLi4ucmVzdCB9ID0gdXBkYXRlRGF0YTtcblxuICBjb25zdCBqc29uRmllbGRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuICBpZiAocmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyAhPT0gbnVsbCAmJiByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBqc29uRmllbGRzLnJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMgPSByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzO1xuICB9XG4gIGlmIChyZXNwb25zZUZvcm1hdHRpbmcgIT09IG51bGwgJiYgcmVzcG9uc2VGb3JtYXR0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBqc29uRmllbGRzLnJlc3BvbnNlRm9ybWF0dGluZyA9IHJlc3BvbnNlRm9ybWF0dGluZztcbiAgfVxuICBpZiAocGFyYW1ldGVycyAhPT0gbnVsbCAmJiBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICBqc29uRmllbGRzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICB9XG4gIGlmIChyZXNwb25zZXMgIT09IG51bGwgJiYgcmVzcG9uc2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICBqc29uRmllbGRzLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgfVxuXG4gIHJldHVybiBtYXBUb29sKFxuICAgIGF3YWl0IGRiLnRvb2wudXBkYXRlKHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIGlkOiB0b29sSWQsXG4gICAgICAgIHRlbmFudElkLFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgLi4ub21pdChyZXN0LCBbXCJmb2xkZXJJZFwiLCBcInByb3ZpZGVySWRcIl0pLFxuICAgICAgICAuLi5qc29uRmllbGRzLFxuICAgICAgICAuLi4odXBkYXRlRGF0YS5uYW1lID8geyBuYW1lOiBzbmFrZUNhc2UodXBkYXRlRGF0YS5uYW1lKS5zbGljZSgwLCBUT09MX05BTUVfTUFYX0xFTkdUSCkgfSA6IHt9KSxcbiAgICAgICAgLi4uKFwiZm9sZGVySWRcIiBpbiB1cGRhdGVEYXRhXG4gICAgICAgICAgPyB1cGRhdGVEYXRhLmZvbGRlcklkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBmb2xkZXI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHVwZGF0ZURhdGEuZm9sZGVySWQsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGZvbGRlcjoge1xuICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih1cGRhdGVEYXRhLnByb3ZpZGVySWRcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgb0F1dGhQcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiB1cGRhdGVEYXRhLnByb3ZpZGVySWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgb0F1dGhQcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSksXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVUb29sQnlJZChkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHRvb2xJZDogc3RyaW5nKSB7XG4gIHJldHVybiBhd2FpdCBkYi50b29sLmRlbGV0ZSh7XG4gICAgd2hlcmU6IHtcbiAgICAgIGlkOiB0b29sSWQsXG4gICAgICB0ZW5hbnRJZCxcbiAgICB9LFxuICB9KTtcbn1cbiIsICJpbXBvcnQgY29ycyBmcm9tIFwiY29yc1wiO1xuaW1wb3J0IGV4cHJlc3MgZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IFN0YXR1c0NvZGVzIH0gZnJvbSBcImh0dHAtc3RhdHVzLWNvZGVzXCI7XG5pbXBvcnQgeyBkYk1pZGRsZXdhcmUgfSBmcm9tIFwiLi9taWRkbGV3YXJlcy9kYi5taWRkbGV3YXJlLmpzXCI7XG5pbXBvcnQgeyBlcnJvckhhbmRsZXIgfSBmcm9tIFwiLi9taWRkbGV3YXJlcy9lcnJvci5taWRkbGV3YXJlLmpzXCI7XG5pbXBvcnQgeyBsb2dnZXJNaWRkbGV3YXJlIH0gZnJvbSBcIi4vbWlkZGxld2FyZXMvbG9nZ2VyLm1pZGRsZXdhcmUuanNcIjtcbmltcG9ydCB7IGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUgfSBmcm9tIFwiLi9taWRkbGV3YXJlcy9zZXNzaW9uLm1pZGRsZXdhcmUuanNcIjtcbmltcG9ydCBhZG1pbnNSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL2FkbWlucy5yb3V0ZXMuanNcIjtcbmltcG9ydCBhaVJvdXRlciBmcm9tIFwiLi9yb3V0ZXMvYWkucm91dGVzLmpzXCI7XG5pbXBvcnQgYW5hbHl0aWNzUm91dGVyIGZyb20gXCIuL3JvdXRlcy9hbmFseXRpY3Mucm91dGVzLmpzXCI7XG5pbXBvcnQgZm9sZGVyc1JvdXRlciBmcm9tIFwiLi9yb3V0ZXMvZm9sZGVycy5yb3V0ZXMuanNcIjtcbmltcG9ydCBoZWFsdGhSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL2hlYWx0aC5yb3V0ZXMuanNcIjtcbmltcG9ydCBtY3BSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL21jcC5yb3V0ZXMuanNcIjtcbmltcG9ydCBtaXJyb3JSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL21pcnJvci5yb3V0ZXMuanNcIjtcbmltcG9ydCBvYXV0aFJvdXRlciBmcm9tIFwiLi9yb3V0ZXMvb2F1dGgucm91dGVzLmpzXCI7XG5pbXBvcnQgb3duaWRSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL293bmlkLnJvdXRlcy5qc1wiO1xuaW1wb3J0IHByb3ZpZGVyc1JvdXRlciBmcm9tIFwiLi9yb3V0ZXMvcHJvdmlkZXJzLnJvdXRlcy5qc1wiO1xuaW1wb3J0IHNlcnZlckF1dGhSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL3NlcnZlci1hdXRoLnJvdXRlcy5qc1wiO1xuaW1wb3J0IHNlcnZlcnNSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL3NlcnZlcnMucm91dGVzLmpzXCI7XG5pbXBvcnQgdGVuYW50Um91dGVyIGZyb20gXCIuL3JvdXRlcy90ZW5hbnQucm91dGVzLmpzXCI7XG5pbXBvcnQgdXNlcnNSb3V0ZXIgZnJvbSBcIi4vcm91dGVzL3VzZXJzLnJvdXRlcy5qc1wiO1xuaW1wb3J0IHsgZGlzY29ubmVjdERhdGFiYXNlIH0gZnJvbSBcIi4vdXRpbHMvY29ubmVjdGlvbi5qc1wiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuaW1wb3J0IGxvZ2dlciBmcm9tIFwiLi9sb2dnZXIuanNcIjtcbmltcG9ydCB7IGlzQXBwUmVxdWVzdCB9IGZyb20gXCIuL3V0aWxzL3JlcS1ndWFyZHMuanNcIjtcblxuY29uc3QgYXBwID0gZXhwcmVzcygpO1xuY29uc3QgcG9ydCA9IHByb2Nlc3MuZW52LlBPUlQgfHwgMzMzMztcblxucHJvY2Vzcy5vbihcIlNJR0lOVFwiLCBhc3luYyAoKSA9PiB7XG4gIGF3YWl0IGRpc2Nvbm5lY3REYXRhYmFzZSgpO1xuICBwcm9jZXNzLmV4aXQoMCk7XG59KTtcblxucHJvY2Vzcy5vbihcIlNJR1RFUk1cIiwgYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBkaXNjb25uZWN0RGF0YWJhc2UoKTtcbiAgcHJvY2Vzcy5leGl0KDApO1xufSk7XG5cbnByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBhc3luYyAoZXJyb3IpID0+IHtcbiAgY29uc29sZS5lcnJvcihcInNlcnZlciB1bmNhdWdodCBleGNlcHRpb25cIiwgZXJyb3IpO1xuICBhd2FpdCBkaXNjb25uZWN0RGF0YWJhc2UoKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufSk7XG5cbnByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwgYXN5bmMgKHJlYXNvbikgPT4ge1xuICBjb25zb2xlLmVycm9yKFwic2VydmVyIHVuaGFuZGxlZCByZWplY3Rpb246XCIsIHJlYXNvbik7XG4gIGF3YWl0IGRpc2Nvbm5lY3REYXRhYmFzZSgpO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59KTtcblxuYXBwLnNldChcInRydXN0IHByb3h5XCIsIHRydWUpO1xuYXBwLnVzZShjb3JzKCkpO1xuYXBwLnVzZShsb2dnZXJNaWRkbGV3YXJlKTtcbmFwcC51c2UoZGJNaWRkbGV3YXJlKTtcbmFwcC51c2UoZXhwcmVzcy5qc29uKCkpO1xuYXBwLnVzZShleHByZXNzLnRleHQoKSk7XG5hcHAudXNlKGV4cHJlc3MudXJsZW5jb2RlZCh7IGV4dGVuZGVkOiBmYWxzZSB9KSk7XG5hcHAudXNlKGV4cHJlc3MucmF3KHsgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiwgbGltaXQ6IFwiNTBtYlwiIH0pKTtcblxuLy8gQWRtaW4gcm91dGVzXG5hcHAudXNlKFwiL2FwaS9wcm92aWRlcnNcIiwgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSwgcHJvdmlkZXJzUm91dGVyKTtcbmFwcC51c2UoXCIvYXBpL3NlcnZlcnNcIiwgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSwgc2VydmVyc1JvdXRlcik7XG5hcHAudXNlKFwiL2FwaS9zZXJ2ZXJzXCIsIGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUsIHNlcnZlckF1dGhSb3V0ZXIpO1xuYXBwLnVzZShcIi9hcGkvc2VydmVyc1wiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCBhbmFseXRpY3NSb3V0ZXIpO1xuYXBwLnVzZShcIi9hcGkvc2VydmVyc1wiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCBmb2xkZXJzUm91dGVyKTtcbmFwcC51c2UoXCIvYXBpL3VzZXJzXCIsIGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUsIHVzZXJzUm91dGVyKTtcbmFwcC51c2UoXCIvYXBpL3RlbmFudFwiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCB0ZW5hbnRSb3V0ZXIpO1xuYXBwLnVzZShcIi9hcGkvYWRtaW5zXCIsIGFkbWluc1JvdXRlcik7XG5hcHAudXNlKFwiL2FwaS9haVwiLCBhaVJvdXRlcik7XG5cbi8vIE1DUCByb3V0ZXMgKHNlcnZlciBhdXRoIG1pZGRsZXdhcmUgaXMgbGF6eS1pbml0aWFsaXplZCBvbiBmaXJzdCByZXF1ZXN0KVxuYXBwLnVzZShtY3BSb3V0ZXIpO1xuXG4vLyBPQXV0aCByb3V0ZXNcbmFwcC51c2Uob2F1dGhSb3V0ZXIpO1xuXG4vLyBIZWFsdGggcm91dGVzXG5hcHAudXNlKFwiL2FwaS9oZWFsdGhcIiwgaGVhbHRoUm91dGVyKTtcblxuLy8gTWlycm9yIHJvdXRlc1xuYXBwLnVzZShcIi9hcGkvbWlycm9yXCIsIG1pcnJvclJvdXRlcik7XG5cbmFwcC51c2UoXCIvYXBpL293bmlkXCIsIG93bmlkUm91dGVyKTtcblxuYXBwLnVzZSgocmVxLCByZXMpID0+IHtcbiAgaWYgKGlzQXBwUmVxdWVzdChyZXEpKSB7XG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhgNDA0IE5vdCBGb3VuZDogJHtyZXEubWV0aG9kfSAke3JlcS5wYXRofWApO1xuICB9XG4gIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHtcbiAgICBlcnJvcjogXCJOb3QgRm91bmRcIixcbiAgfSk7XG59KTtcblxuYXBwLnVzZShlcnJvckhhbmRsZXIpO1xuXG50cnkge1xuICBjb25zdCBzZXJ2ZXIgPSBhcHAubGlzdGVuKHBvcnQsICgpID0+IHtcbiAgICBsb2dnZXIuaW5mbyhgU2VydmVyIGlzIHJ1bm5pbmcgb24gcG9ydCAke3BvcnR9YCk7XG4gIH0pO1xuXG4gIHNlcnZlci5vbihcImVycm9yXCIsIChlcnI6IE5vZGVKUy5FcnJub0V4Y2VwdGlvbikgPT4ge1xuICAgIGlmIChlcnIuY29kZSA9PT0gXCJFQUREUklOVVNFXCIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgUG9ydCAke3BvcnR9IGlzIGFscmVhZHkgaW4gdXNlYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBzdGFydCBzZXJ2ZXI6XCIsIGVycik7XG4gICAgfVxuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfSk7XG59IGNhdGNoIChlKSB7XG4gIGxvZ2dlci5lcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIHNlcnZlciBzdGFydHVwOlwiLCBlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvY2F0Y2gtb3ItcmV0dXJuXG4gIGRpc2Nvbm5lY3REYXRhYmFzZSgpLmZpbmFsbHkoKCkgPT4gcHJvY2Vzcy5leGl0KDEpKTtcbn1cbiIsICJpbXBvcnQgeyBQcmlzbWEsIFByaXNtYUNsaWVudCB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuaW1wb3J0IHsgZmllbGRFbmNyeXB0aW9uRXh0ZW5zaW9uIH0gZnJvbSBcInByaXNtYS1maWVsZC1lbmNyeXB0aW9uXCI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5pbXBvcnQgbG9nZ2VyIGZyb20gXCIuLi9sb2dnZXIuanNcIjtcbmltcG9ydCB7IGdldEFwcFNlY3JldHMgfSBmcm9tIFwiLi4vc2VydmljZXMvc2VjcmV0cy5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBnZXRSZXF1ZXN0TG9nZ2VyIH0gZnJvbSBcIi4vbG9nZ2VyLWNscy5qc1wiO1xuaW1wb3J0IFF1ZXJ5RXZlbnQgPSBQcmlzbWEuUXVlcnlFdmVudDtcbmltcG9ydCBMb2dFdmVudCA9IFByaXNtYS5Mb2dFdmVudDtcblxuY29uc3QgcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCh7XG4gIGxvZzogW1xuICAgIHtcbiAgICAgIGVtaXQ6IFwiZXZlbnRcIixcbiAgICAgIGxldmVsOiBcInF1ZXJ5XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBlbWl0OiBcImV2ZW50XCIsXG4gICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgIH0sXG4gICAge1xuICAgICAgZW1pdDogXCJldmVudFwiLFxuICAgICAgbGV2ZWw6IFwiaW5mb1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgZW1pdDogXCJldmVudFwiLFxuICAgICAgbGV2ZWw6IFwid2FyblwiLFxuICAgIH0sXG4gIF0sXG59KTtcblxuY29uc3QgYXVkaXRMb2cgPSAobW9kZWw6IHN0cmluZyB8IHVuZGVmaW5lZCwgb3BlcmF0aW9uOiBzdHJpbmcsIGFyZ3M6IHsgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfSkgPT4ge1xuICBpZiAoXG4gICAgIW1vZGVsIHx8XG4gICAgKCFvcGVyYXRpb24uc3RhcnRzV2l0aChcImNyZWF0ZVwiKSAmJiAhb3BlcmF0aW9uLnN0YXJ0c1dpdGgoXCJ1cGRhdGVcIikgJiYgIW9wZXJhdGlvbi5zdGFydHNXaXRoKFwiZGVsZXRlXCIpKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaWQgPSBhcmdzW1wiZGF0YVwiXT8uW1wiaWRcIl07XG4gIGNvbnN0IG5hbWUgPSBhcmdzW1wiZGF0YVwiXT8uW1wibmFtZVwiXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZ3NbXCJkYXRhXCJdIHx8IHt9KTtcbiAgZ2V0UmVxdWVzdExvZ2dlcigpPy5pbmZvKFwiREIgQXVkaXQgTG9nXCIsIHtcbiAgICBtb2RlbCxcbiAgICBvcGVyYXRpb24sXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgICBrZXlzLFxuICB9KTtcbn07XG5cbnByaXNtYS4kb24oXCJxdWVyeVwiLCAoZTogUXVlcnlFdmVudCkgPT4ge1xuICBsb2dnZXIuZGVidWcoXCJRdWVyeTpcIiwge1xuICAgIHF1ZXJ5OiBlLnF1ZXJ5LFxuICAgIGR1cmF0aW9uOiBlLmR1cmF0aW9uLFxuICAgIHRpbWVzdGFtcDogZS50aW1lc3RhbXAsXG4gIH0pO1xufSk7XG5cbnByaXNtYS4kb24oXCJlcnJvclwiLCAoZTogTG9nRXZlbnQpID0+IHtcbiAgbG9nZ2VyLmVycm9yKFwiRGF0YWJhc2UgZXJyb3I6XCIsIHtcbiAgICBlcnJvcjogZS5tZXNzYWdlLFxuICAgIHRpbWVzdGFtcDogZS50aW1lc3RhbXAsXG4gIH0pO1xufSk7XG5cbnByaXNtYS4kb24oXCJ3YXJuXCIsIChlOiBMb2dFdmVudCkgPT4ge1xuICBsb2dnZXIud2FybihcIkRhdGFiYXNlIHdhcm5pbmc6XCIsIHtcbiAgICB3YXJuaW5nOiBlLm1lc3NhZ2UsXG4gICAgdGltZXN0YW1wOiBlLnRpbWVzdGFtcCxcbiAgfSk7XG59KTtcblxucHJpc21hLiRvbihcImluZm9cIiwgKGU6IExvZ0V2ZW50KSA9PiB7XG4gIGxvZ2dlci5kZWJ1ZyhcIkRhdGFiYXNlIGluZm86XCIsIHtcbiAgICBpbmZvOiBlLm1lc3NhZ2UsXG4gICAgdGltZXN0YW1wOiBlLnRpbWVzdGFtcCxcbiAgfSk7XG59KTtcblxucHJvY2Vzcy5vbihcIlNJR0lOVFwiLCBhc3luYyAoKSA9PiB7XG4gIGF3YWl0IHByaXNtYS4kZGlzY29ubmVjdCgpO1xuICBwcm9jZXNzLmV4aXQoMCk7XG59KTtcblxuZXhwb3J0IHR5cGUgRGF0YWJhc2UgPSB0eXBlb2YgcHJpc21hO1xuXG5leHBvcnQgY29uc3QgZGlzY29ubmVjdERhdGFiYXNlID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IHByaXNtYS4kZGlzY29ubmVjdCgpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkRhdGFiYXNlIGNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGRpc2Nvbm5lY3RpbmcgZnJvbSBkYXRhYmFzZVwiLCBlcnJvcik7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHNlY3JldHMgPSBhd2FpdCBnZXRBcHBTZWNyZXRzKCk7XG4gIHJldHVybiBwcmlzbWFcbiAgICAuJGV4dGVuZHMoXG4gICAgICBmaWVsZEVuY3J5cHRpb25FeHRlbnNpb24oe1xuICAgICAgICBlbmNyeXB0aW9uS2V5OiBzZWNyZXRzLmRiRW5jcnlwdGlvbktleSxcbiAgICAgIH0pLFxuICAgIClcbiAgICAuJGV4dGVuZHMoe1xuICAgICAgbmFtZTogXCJhdWRpdExvZ1wiLFxuICAgICAgcXVlcnk6IHtcbiAgICAgICAgJGFsbE9wZXJhdGlvbnMoeyBtb2RlbCwgb3BlcmF0aW9uLCBhcmdzLCBxdWVyeSB9KSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gcXVlcnkoYXJncyk7XG4gICAgICAgICAgYXVkaXRMb2cobW9kZWwsIG9wZXJhdGlvbiwgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSkgYXMgRGF0YWJhc2U7XG59KSgpO1xuIiwgImltcG9ydCB7IGNyZWF0ZU5hbWVzcGFjZSB9IGZyb20gXCJjbHMtaG9va2VkXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwid2luc3RvblwiO1xuXG5jb25zdCByZXF1ZXN0TG9nZ2VyTmFtZXNwYWNlID0gY3JlYXRlTmFtZXNwYWNlKFwicmVxLWxvZ2dlclwiKTtcbmNvbnN0IHJlcXVlc3RMb2dnZXJLZXkgPSBcImxvZ2dlclwiO1xuXG5leHBvcnQgY29uc3Qgd2l0aFJlcXVlc3RMb2dnZXIgPSAobG9nZ2VyOiBMb2dnZXIsIGFjdGlvbjogKCkgPT4gdW5rbm93bikgPT4ge1xuICByZXF1ZXN0TG9nZ2VyTmFtZXNwYWNlLnJ1bigoKSA9PiB7XG4gICAgcmVxdWVzdExvZ2dlck5hbWVzcGFjZS5zZXQocmVxdWVzdExvZ2dlcktleSwgbG9nZ2VyKTtcbiAgICBhY3Rpb24oKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UmVxdWVzdExvZ2dlciA9ICgpID0+IHtcbiAgcmV0dXJuIHJlcXVlc3RMb2dnZXJOYW1lc3BhY2UuZ2V0KHJlcXVlc3RMb2dnZXJLZXkpIGFzIExvZ2dlciB8IG51bGw7XG59O1xuIiwgImltcG9ydCB7IE5leHRGdW5jdGlvbiwgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHByaXNtYSwgeyBEYXRhYmFzZSB9IGZyb20gXCIuLi91dGlscy9jb25uZWN0aW9uLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBkYk1pZGRsZXdhcmUgPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdCAmIHsgZGI/OiBEYXRhYmFzZSB9LFxuICBfcmVzOiBSZXNwb25zZSxcbiAgbmV4dDogTmV4dEZ1bmN0aW9uLFxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHJlcS5kYiA9IGF3YWl0IHByaXNtYTtcbiAgbmV4dCgpO1xufTtcbiIsICJpbXBvcnQgeyBOZXh0RnVuY3Rpb24sIFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IFN0YXR1c0NvZGVzIH0gZnJvbSBcImh0dHAtc3RhdHVzLWNvZGVzXCI7XG5pbXBvcnQgeyBpc0FwcFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5leHBvcnQgY29uc3QgZXJyb3JIYW5kbGVyID0gKGVycjogRXJyb3IsIHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSwgbmV4dDogTmV4dEZ1bmN0aW9uKSA9PiB7XG4gIGlmIChpc0FwcFJlcXVlc3QocmVxKSkge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJFcnJvclwiLCBlcnIpO1xuICB9XG4gIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHtcbiAgICBlcnJvcjogZXJyLm1lc3NhZ2UsXG4gIH0pO1xufTtcbiIsICJpbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJ3aW5zdG9uXCI7XG5pbXBvcnQgeyBTZXJ2ZXJBdXRoUmVzdWx0IH0gZnJvbSBcIi4uL3NlcnZpY2VzL2ludGVyZmFjZXMvYXV0aC1zdHJhdGVneS5pbnRlcmZhY2UuanNcIjtcbmltcG9ydCB7IEFkbWluQ2xhaW1zLCBFbmRVc2VyQ2xhaW1zIH0gZnJvbSBcIi4uL3NlcnZpY2VzL2p3dC5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBEYXRhYmFzZSB9IGZyb20gXCIuL2Nvbm5lY3Rpb24uanNcIjtcblxuaW50ZXJmYWNlIEFwcENvbnRleHQge1xuICBsb2dnZXI6IExvZ2dlcjtcbiAgZGI6IERhdGFiYXNlO1xufVxuXG5leHBvcnQgdHlwZSBBcHBSZXF1ZXN0ID0gUmVxdWVzdCAmXG4gIEFwcENvbnRleHQgJiB7XG4gICAgdXNlcj86IEVuZFVzZXJDbGFpbXM7XG4gICAgYWRtaW4/OiBBZG1pbkNsYWltcztcbiAgICBzZXJ2ZXJJZD86IHN0cmluZztcbiAgICBzZXJ2ZXJBdXRoPzogU2VydmVyQXV0aFJlc3VsdDtcbiAgfTtcbmV4cG9ydCB0eXBlIEVuZFVzZXJSZXF1ZXN0ID0gQXBwUmVxdWVzdCAmIHsgdXNlcjogRW5kVXNlckNsYWltcyB9O1xuZXhwb3J0IHR5cGUgQWRtaW5SZXF1ZXN0ID0gQXBwUmVxdWVzdCAmIHsgYWRtaW46IEFkbWluQ2xhaW1zIH07XG5leHBvcnQgdHlwZSBXaXRoU2VydmVySWRSZXF1ZXN0ID0gQXBwUmVxdWVzdCAmIHsgc2VydmVySWQ6IHN0cmluZyB9O1xuXG5leHBvcnQgY29uc3QgaXNBcHBSZXF1ZXN0ID0gKHJlcTogUmVxdWVzdCk6IHJlcSBpcyBBcHBSZXF1ZXN0ID0+IFwibG9nZ2VyXCIgaW4gcmVxICYmIFwiZGJcIiBpbiByZXE7XG5cbmV4cG9ydCBjb25zdCBpc0VuZFVzZXJSZXF1ZXN0ID0gKHJlcTogUmVxdWVzdCk6IHJlcSBpcyBFbmRVc2VyUmVxdWVzdCA9PiBcInVzZXJcIiBpbiByZXE7XG5cbmV4cG9ydCBjb25zdCBpc1dpdGhTZXJ2ZXJJZFJlcXVlc3QgPSAocmVxOiBSZXF1ZXN0KTogcmVxIGlzIFdpdGhTZXJ2ZXJJZFJlcXVlc3QgPT4gXCJzZXJ2ZXJJZFwiIGluIHJlcTtcblxuZXhwb3J0IGNvbnN0IGlzRW5kVXNlcldpdGhTZXJ2ZXJJZFJlcXVlc3QgPSAocmVxOiBSZXF1ZXN0KTogcmVxIGlzIEVuZFVzZXJSZXF1ZXN0ICYgV2l0aFNlcnZlcklkUmVxdWVzdCA9PlxuICBcInNlcnZlcklkXCIgaW4gcmVxICYmIFwidXNlclwiIGluIHJlcTtcblxuZXhwb3J0IGNvbnN0IGlzQWRtaW5SZXF1ZXN0ID0gKHJlcTogUmVxdWVzdCk6IHJlcSBpcyBBZG1pblJlcXVlc3QgPT4gXCJhZG1pblwiIGluIHJlcTtcblxuZXhwb3J0IGNsYXNzIFR5cGVHdWFyZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlR5cGUgZ3VhcmQgZmFpbGVkXCIpO1xuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCB7IE5leHRGdW5jdGlvbiwgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIndpbnN0b25cIjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBsb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyLmpzXCI7XG5pbXBvcnQgeyB3aXRoUmVxdWVzdExvZ2dlciB9IGZyb20gXCIuLi91dGlscy9sb2dnZXItY2xzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBsb2dnZXJNaWRkbGV3YXJlID0gKHJlcTogUmVxdWVzdCAmIHsgbG9nZ2VyPzogTG9nZ2VyIH0sIHJlczogUmVzcG9uc2UsIG5leHQ6IE5leHRGdW5jdGlvbikgPT4ge1xuICByZXEubG9nZ2VyID0gbG9nZ2VyLmNoaWxkKHtcbiAgICByZXF1ZXN0OiB7XG4gICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgIHBhdGg6IHJlcS5wYXRoLFxuICAgICAgcGFyYW1zOiBPYmplY3Qua2V5cyhyZXEucGFyYW1zIHx8IHt9KSxcbiAgICAgIGJvZHlMZW46IHJlcS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gfHwgbnVsbCxcbiAgICB9LFxuICB9KTtcbiAgd2l0aFJlcXVlc3RMb2dnZXIocmVxLmxvZ2dlciwgKCkgPT4ge1xuICAgIG5leHQoKTtcbiAgfSk7XG59O1xuIiwgImltcG9ydCB7IEFkbWluUm9sZSB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuaW1wb3J0IHsgTmV4dEZ1bmN0aW9uLCBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBTdGF0dXNDb2RlcyB9IGZyb20gXCJodHRwLXN0YXR1cy1jb2Rlc1wiO1xuaW1wb3J0IHsgY2FjaGVHZXRPckFkZCwgQ2FjaGVJdGVtVHlwZSB9IGZyb20gXCIuLi9zZXJ2aWNlcy9jYWNoZS5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyB2ZXJpZnlBZG1pblRva2VuLCB2ZXJpZnlFbmRVc2VyVG9rZW4gfSBmcm9tIFwiLi4vc2VydmljZXMvand0LnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IG1hcmtUb2tlbkFzVXNlZCB9IGZyb20gXCIuLi9zZXJ2aWNlcy9vYXV0aC5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBoYXNoRm9yTG9nZ2luZyB9IGZyb20gXCIuLi91dGlscy9oYXNoLmpzXCI7XG5pbXBvcnQgeyBBcHBSZXF1ZXN0LCBpc0FkbWluUmVxdWVzdCwgaXNBcHBSZXF1ZXN0LCBUeXBlR3VhcmRFcnJvciB9IGZyb20gXCIuLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5cbmNvbnN0IHNlc3Npb25NaWRkbGV3YXJlID0gYXN5bmMgPFQgZXh0ZW5kcyB7IGlkOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmc7IHRlbmFudElkOiBzdHJpbmc7IGp0aT86IHN0cmluZyB9PihcbiAgcmVxOiBSZXF1ZXN0LFxuICByZXM6IFJlc3BvbnNlLFxuICBuZXh0OiBOZXh0RnVuY3Rpb24sXG4gIHNjb3BlOiBcInVzZXJcIiB8IFwiYWRtaW5cIixcbiAgdmVyaWZpZXI6ICh0b2tlbjogc3RyaW5nKSA9PiBQcm9taXNlPFQgfCBudWxsPixcbiAgc2V0dGVyOiAocmVxOiBBcHBSZXF1ZXN0LCBkZWNvZGVkOiBUKSA9PiB2b2lkLFxuKSA9PiB7XG4gIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IGF1dGhIZWFkZXIgPSByZXEuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aChcIkJlYXJlciBcIikpIHtcbiAgICByZXEubG9nZ2VyLndhcm4oYE5vIGF1dGhvcml6YXRpb24gaGVhZGVyIGZvciAke3Njb3BlfSBwcm92aWRlZCBvbiByZXF1ZXN0IHRvICR7cmVxLnBhdGh9YCk7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuVU5BVVRIT1JJWkVEKS5qc29uKHtcbiAgICAgIGVycm9yOiBcInVuYXV0aG9yaXplZFwiLFxuICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJObyB0b2tlbiBwcm92aWRlZFwiLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnNwbGl0KFwiIFwiKVsxXTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgdmVyaWZpZXIodG9rZW4pO1xuICAgIGlmICghZGVjb2RlZCkge1xuICAgICAgcmVxLmxvZ2dlci5kZWJ1ZyhcIlRva2VuIHZlcmlmaWNhdGlvbiBmYWlsZWRcIik7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5VTkFVVEhPUklaRUQpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJ1bmF1dGhvcml6ZWRcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJJbnZhbGlkIHRva2VuXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUgPT09IFwidXNlclwiKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGNhY2hlR2V0T3JBZGQoXG4gICAgICAgIHsgdHlwZTogQ2FjaGVJdGVtVHlwZS5FTkRVU0VSX1RPS0VOLCBpZHM6IFtkZWNvZGVkLmVtYWlsLCBkZWNvZGVkLmp0aSB8fCBcIlwiXSB9LFxuICAgICAgICBhc3luYyAoKSA9PlxuICAgICAgICAgIGF3YWl0IHJlcS5kYi5wcm92aWRlclRva2VuLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgaWQ6IGRlY29kZWQuanRpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHJlcS5sb2dnZXIud2FybihcIlRva2VuIG5vdCBmb3VuZCBpbiBkYXRhYmFzZVwiLCBkZWNvZGVkLmp0aSk7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLlVOQVVUSE9SSVpFRCkuanNvbih7XG4gICAgICAgICAgZXJyb3I6IFwidW5hdXRob3JpemVkXCIsXG4gICAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJJbnZhbGlkIHRva2VuXCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IG1hcmtUb2tlbkFzVXNlZChyZXEuZGIsIHRva2VuLmlkKSk7XG4gICAgfVxuXG4gICAgc2V0dGVyKHJlcSwgZGVjb2RlZCk7XG4gICAgcmVxLmxvZ2dlciA9IHJlcS5sb2dnZXIuY2hpbGQoe1xuICAgICAgdGVuYW50SWQ6IGRlY29kZWQudGVuYW50SWQsXG4gICAgICBbc2NvcGUgPT09IFwidXNlclwiID8gXCJlbmRVc2VySWRcIiA6IFwiYWRtaW5JZFwiXTogZGVjb2RlZC5pZCxcbiAgICAgIGVtYWlsOiBhd2FpdCBoYXNoRm9yTG9nZ2luZyhkZWNvZGVkLmVtYWlsKSxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dCgpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5VTkFVVEhPUklaRUQpLmpzb24oe1xuICAgICAgZXJyb3I6IFwidW5hdXRob3JpemVkXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIkludmFsaWQgdG9rZW5cIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUgPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlLCBuZXh0OiBOZXh0RnVuY3Rpb24pID0+IHtcbiAgcmV0dXJuIHNlc3Npb25NaWRkbGV3YXJlKHJlcSwgcmVzLCBuZXh0LCBcImFkbWluXCIsIHZlcmlmeUFkbWluVG9rZW4sIChyZXEsIGRlY29kZWQpID0+IChyZXEuYWRtaW4gPSBkZWNvZGVkKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZW5kVXNlclNlc3Npb25NaWRkbGV3YXJlID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSwgbmV4dDogTmV4dEZ1bmN0aW9uKSA9PiB7XG4gIHJldHVybiBzZXNzaW9uTWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgXCJ1c2VyXCIsIHZlcmlmeUVuZFVzZXJUb2tlbiwgKHJlcSwgZGVjb2RlZCkgPT4gKHJlcS51c2VyID0gZGVjb2RlZCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHN1cGVyQWRtaW5Pbmx5TWlkZGxld2FyZSA9IChcbiAgcmVxOiBSZXF1ZXN0PFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIG9iamVjdCwgb2JqZWN0PixcbiAgcmVzOiBSZXNwb25zZSxcbiAgbmV4dDogTmV4dEZ1bmN0aW9uLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgaWYgKHJlcS5hZG1pbi5yb2xlID09PSBBZG1pblJvbGUuc3VwZXJhZG1pbikge1xuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuRk9SQklEREVOKS5qc29uKHtcbiAgICBlcnJvcjogXCJmb3JiaWRkZW5cIixcbiAgICBlcnJvckRlc2NyaXB0aW9uOiBcIlN1cGVyYWRtaW4gcHJpdmlsZWdlcyByZXF1aXJlZFwiLFxuICB9KTtcbn07XG4iLCAiaW1wb3J0IHsgT0F1dGhQcm92aWRlciwgUHJvdmlkZXJUb2tlbiB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBTdGF0dXNDb2RlcyB9IGZyb20gXCJodHRwLXN0YXR1cy1jb2Rlc1wiO1xuaW1wb3J0IG9taXQgZnJvbSBcImxvZGFzaC9vbWl0LmpzXCI7XG5pbXBvcnQgcXMgZnJvbSBcInFzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwid2luc3RvblwiO1xuaW1wb3J0IHsgT0F1dGhFcnJvciB9IGZyb20gXCIuLi90eXBlcy9lcnJvci50eXBlcy5qc1wiO1xuaW1wb3J0IHsgaXNMb2NhbFJ1biB9IGZyb20gXCIuLi91dGlscy9jb25maWcuanNcIjtcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSBcIi4uL3V0aWxzL2Nvbm5lY3Rpb24uanNcIjtcblxuZXhwb3J0IGNvbnN0IEVORFVTRVJfU0NPUEUgPSBcImVuZHVzZXJcIjtcbmV4cG9ydCBjb25zdCBUT09MX1NDT1BFID0gXCJ0b29sXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVEYXRhIHtcbiAgcmVkaXJlY3RVcmk6IHN0cmluZyB8IG51bGw7XG4gIGNsaWVudFN0YXRlOiBzdHJpbmc7XG4gIGNsaWVudElkOiBzdHJpbmcgfCBudWxsO1xuICBzZXJ2ZXJJZDogc3RyaW5nIHwgbnVsbDtcbiAgc2NvcGU6IHN0cmluZyB8IG51bGw7XG4gIHByb3ZpZGVySWQ6IHN0cmluZyB8IG51bGw7XG4gIG9yaWdpbkFkZHJlc3M6IHN0cmluZyB8IG51bGw7XG4gIHVzZXJJZDogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IGVuY29kZURhdGEgPSA8VD4oZGF0YTogVCkgPT4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoZGF0YSkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuZXhwb3J0IGNvbnN0IGRlY29kZURhdGEgPSA8VD4oZW5jb2RlZDogc3RyaW5nKTogVCA9PiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKGVuY29kZWQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkpO1xuXG5jb25zdCBvYXV0aEF1dGhIZWFkZXIgPSAocHJvdmlkZXI6IE9BdXRoUHJvdmlkZXIpID0+XG4gIFwiQmFzaWMgXCIgKyBCdWZmZXIuZnJvbShgJHtwcm92aWRlci5jbGllbnRJZH06JHtwcm92aWRlci5jbGllbnRTZWNyZXR9YCkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG5cbmV4cG9ydCBjb25zdCBnZXRIb3N0VXJsID0gKHJlcTogUmVxdWVzdCwgdXNlU2VydmVySG9zdDogYm9vbGVhbik6IHN0cmluZyA9PiB7XG4gIGlmICh1c2VTZXJ2ZXJIb3N0KSB7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBpc0xvY2FsUnVuID8gcmVxLmdldChcIlgtRm9yd2FyZGVkLVByb3RvXCIpIHx8IHJlcS5wcm90b2NvbCA6IFwiaHR0cHNcIjtcbiAgICBjb25zdCBob3N0ID0gYCR7cHJvdG9jb2x9Oi8vJHtyZXEuZ2V0KFwiaG9zdFwiKX1gO1xuICAgIHJldHVybiBob3N0LmVuZHNXaXRoKFwiL1wiKSA/IGhvc3Quc2xpY2UoMCwgLTEpIDogaG9zdDtcbiAgfVxuICAvLyB3ZSBhc3N1bWUgd2hlbiBkZXBsb3llZCwgdGhlIGhvc3QgaXMgYWx3YXlzIHRoZSBzYW1lIGFzIHRoZSBjb25zb2xlIFVSTFxuICByZXR1cm4gcHJvY2Vzcy5lbnYuQ09OU09MRV9VUkwgYXMgc3RyaW5nO1xufTtcblxuZXhwb3J0IGNvbnN0IGNhbGxiYWNrVXJsID0gKHJlcTogUmVxdWVzdCkgPT4gYCR7Z2V0SG9zdFVybChyZXEsIGlzTG9jYWxSdW4pfS9hcGkvb2F1dGgvY2FsbGJhY2tgO1xuXG5pbnRlcmZhY2UgVG9rZW5FeGNoYW5nZVJlc3VsdCB7XG4gIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gIHJlZnJlc2hUb2tlbj86IHN0cmluZztcbiAgZXhwaXJlc0luOiBudW1iZXIgfCBudWxsO1xuICBzY29wZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGV4Y2hhbmdlQ29kZUZvclRva2VuID0gYXN5bmMgKFxuICBsb2dnZXI6IExvZ2dlcixcbiAgcHJvdmlkZXI6IE9BdXRoUHJvdmlkZXIsXG4gIGNvZGU6IHN0cmluZyxcbiAgY2FsbGJhY2tVcmw6IHN0cmluZyxcbik6IFByb21pc2U8VG9rZW5FeGNoYW5nZVJlc3VsdD4gPT4ge1xuICBsb2dnZXIuZGVidWcoYEV4Y2hhbmdpbmcgYXV0aCBjb2RlIGZvciB0b2tlbiB3aXRoIHByb3ZpZGVyOiAke3Byb3ZpZGVyLm5hbWV9ICgke3Byb3ZpZGVyLmlkfSlgKTtcbiAgbG9nZ2VyLmRlYnVnKGBVc2luZyBjYWxsYmFjayBVUkw6ICR7Y2FsbGJhY2tVcmx9YCk7XG5cbiAgY29uc3QgdG9rZW5SZXF1ZXN0RGF0YTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICByZWRpcmVjdF91cmk6IGNhbGxiYWNrVXJsLFxuICAgIGNvZGUsXG4gICAgZ3JhbnRfdHlwZTogXCJhdXRob3JpemF0aW9uX2NvZGVcIixcbiAgfTtcblxuICBjb25zdCByZWZyZXNoVXJsID0gcHJvdmlkZXIucmVmcmVzaFVybCB8fCBwcm92aWRlci50b2tlblVybDtcbiAgbG9nZ2VyLmRlYnVnKGBNYWtpbmcgdG9rZW4gcmVxdWVzdCB0bzogJHtyZWZyZXNoVXJsfWApO1xuICBjb25zdCBjb250ZW50VHlwZSA9IHByb3ZpZGVyLmNvbnRlbnRUeXBlIHx8IFwiYXBwbGljYXRpb24vanNvblwiO1xuICB0cnkge1xuICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KFxuICAgICAgcHJvdmlkZXIucmVmcmVzaFVybCB8fCBwcm92aWRlci50b2tlblVybCxcbiAgICAgIGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiZm9ybVwiKSA/IHFzLnN0cmluZ2lmeSh0b2tlblJlcXVlc3REYXRhKSA6IHRva2VuUmVxdWVzdERhdGEsXG4gICAgICB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZSxcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBvYXV0aEF1dGhIZWFkZXIocHJvdmlkZXIpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYFRva2VuIGV4Y2hhbmdlIHN1Y2Nlc3NmdWwsIHJlY2VpdmVkIGFjY2Vzc190b2tlbjogJHt0b2tlblJlc3BvbnNlLmRhdGEuYWNjZXNzX3Rva2VuID8gXCJcdTI3MTNcIiA6IFwiXHUyNzE3XCJ9LCByZWZyZXNoX3Rva2VuOiAke3Rva2VuUmVzcG9uc2UuZGF0YS5yZWZyZXNoX3Rva2VuID8gXCJcdTI3MTNcIiA6IFwiXHUyNzE3XCJ9YCxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY2Vzc1Rva2VuOiB0b2tlblJlc3BvbnNlLmRhdGEuYWNjZXNzX3Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuOiB0b2tlblJlc3BvbnNlLmRhdGEucmVmcmVzaF90b2tlbixcbiAgICAgIGV4cGlyZXNJbjogdG9rZW5SZXNwb25zZS5kYXRhLmV4cGlyZXNfaW4gfHwgMzYwMCxcbiAgICAgIHNjb3BlOiB0b2tlblJlc3BvbnNlLmRhdGEuc2NvcGUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgYXhpb3MuaXNBeGlvc0Vycm9yKGVycm9yKSAmJiBlcnJvci5yZXNwb25zZVxuICAgICAgICA/IGAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c1RleHR9OiAke2Vycm9yLnJlc3BvbnNlLmRhdGF9YFxuICAgICAgICA6IFwiRmFpbGVkIHRvIGdyYW50IHRva2VuXCI7XG4gICAgbG9nZ2VyLndhcm4oXG4gICAgICBgVG9rZW4gZXhjaGFuZ2UgZmFpbGVkYCxcbiAgICAgIGF4aW9zLmlzQXhpb3NFcnJvcihlcnJvcikgJiYgZXJyb3IucmVzcG9uc2UgPyBvbWl0KGVycm9yLCBbXCJyZXF1ZXN0XCIsIFwicmVzcG9uc2VcIl0pIDogZXJyb3IsXG4gICAgICB7XG4gICAgICAgIHJlZnJlc2hVcmwsXG4gICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAuLi4oYXhpb3MuaXNBeGlvc0Vycm9yKGVycm9yKSAmJiBlcnJvci5yZXNwb25zZVxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBzdGF0dXM6IGVycm9yLnJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgZGF0YTogZXJyb3IucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHt9KSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICB0aHJvdyBuZXcgT0F1dGhFcnJvcihlcnJvck1lc3NhZ2UsIFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNULCBcInRva2VuX2dyYW50X2ZhaWxlZFwiKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZnJlc2hBbmRQZXJzaXN0QWNjZXNzVG9rZW4gPSBhc3luYyAoXG4gIGRiOiBEYXRhYmFzZSxcbiAgbG9nZ2VyOiBMb2dnZXIsXG4gIHVzZXJJZDogc3RyaW5nLFxuICBwcm92aWRlcjogT0F1dGhQcm92aWRlcixcbiAgcmVmcmVzaFRva2VuOiBzdHJpbmcsXG4gIG9yaWdpbkFkZHJlc3M6IHN0cmluZyB8IG51bGwsXG4pOiBQcm9taXNlPFByb3ZpZGVyVG9rZW4+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlblJlcXVlc3REYXRhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgZ3JhbnRfdHlwZTogXCJyZWZyZXNoX3Rva2VuXCIsXG4gICAgfTtcblxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcHJvdmlkZXIuY29udGVudFR5cGUgfHwgXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgY29uc3QgdG9rZW5SZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoXG4gICAgICBwcm92aWRlci5yZWZyZXNoVXJsIHx8IHByb3ZpZGVyLnRva2VuVXJsLFxuICAgICAgY29udGVudFR5cGUuaW5jbHVkZXMoXCJmb3JtXCIpID8gcXMuc3RyaW5naWZ5KHRva2VuUmVxdWVzdERhdGEpIDogdG9rZW5SZXF1ZXN0RGF0YSxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlLFxuICAgICAgICAgIEF1dGhvcml6YXRpb246IG9hdXRoQXV0aEhlYWRlcihwcm92aWRlciksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCB0b2tlbkRhdGEgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogdG9rZW5SZXNwb25zZS5kYXRhLmFjY2Vzc190b2tlbixcbiAgICAgIGV4cGlyZXNJbjogdG9rZW5SZXNwb25zZS5kYXRhLmV4cGlyZXNfaW4gfHwgMzYwMCxcbiAgICAgIHNjb3BlOiB0b2tlblJlc3BvbnNlLmRhdGEuc2NvcGUsXG4gICAgICByZWZyZXNoVG9rZW46IHRva2VuUmVzcG9uc2UuZGF0YS5yZWZyZXNoX3Rva2VuIHx8IHJlZnJlc2hUb2tlbixcbiAgICB9IGFzIFRva2VuRXhjaGFuZ2VSZXN1bHQ7XG5cbiAgICByZXR1cm4gYXdhaXQgcGVyc2lzdFRva2VuKGRiLCBsb2dnZXIsIHVzZXJJZCwgcHJvdmlkZXIuaWQsIHRva2VuRGF0YSwgb3JpZ2luQWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLndhcm4oYFRva2VuIHJlZnJlc2ggZmFpbGVkYCwgZXJyb3IsIHtcbiAgICAgIC4uLihheGlvcy5pc0F4aW9zRXJyb3IoZXJyb3IpICYmIGVycm9yLnJlc3BvbnNlXG4gICAgICAgID8ge1xuICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiBlcnJvci5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7fSksXG4gICAgfSk7XG4gICAgdGhyb3cgbmV3IE9BdXRoRXJyb3IoYEZhaWxlZCB0byByZWZyZXNoIHRva2VuYCwgU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QsIFwidG9rZW5fcmVmcmVzaF9mYWlsZWRcIik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwZXJzaXN0VG9rZW4gPSBhc3luYyAoXG4gIGRiOiBEYXRhYmFzZSxcbiAgbG9nZ2VyOiBMb2dnZXIsXG4gIHVzZXJJZDogc3RyaW5nLFxuICBwcm92aWRlcklkOiBzdHJpbmcgfCBudWxsLFxuICB0b2tlbjogVG9rZW5FeGNoYW5nZVJlc3VsdCxcbiAgb3JpZ2luQWRkcmVzczogc3RyaW5nIHwgbnVsbCxcbiAganRpOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbikgPT4ge1xuICBsb2dnZXIuZGVidWcoYFBlcnNpc3RpbmcgdG9rZW4gZm9yIHVzZXIgJHt1c2VySWR9IGFuZCBwcm92aWRlciAke3Byb3ZpZGVySWR9YCk7XG5cbiAgaWYgKHByb3ZpZGVySWQpIHtcbiAgICBhd2FpdCBkYi5wcm92aWRlclRva2VuLmRlbGV0ZU1hbnkoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgdXNlcklkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBkYi5wcm92aWRlclRva2VuLmNyZWF0ZSh7XG4gICAgZGF0YToge1xuICAgICAgaWQ6IGp0aSB8fCB1bmRlZmluZWQsXG4gICAgICBwcm92aWRlcklkLFxuICAgICAgdXNlcklkLFxuICAgICAgYWNjZXNzVG9rZW46IHRva2VuLmFjY2Vzc1Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuOiB0b2tlbi5yZWZyZXNoVG9rZW4sXG4gICAgICBzY29wZXM6IHRva2VuLnNjb3BlPy5zcGxpdChcIiBcIiksXG4gICAgICBpc3N1ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIGV4cGlyZXNBdDogdG9rZW4uZXhwaXJlc0luID09PSBudWxsID8gbnVsbCA6IG5ldyBEYXRlKERhdGUubm93KCkgKyB0b2tlbi5leHBpcmVzSW4gKiAxMDAwKSxcbiAgICAgIG9yaWdpbkFkZHJlc3MsXG4gICAgfSxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QXV0aG9yaXplVXJsID0gKFxuICByZXE6IFJlcXVlc3QsXG4gIHByb3ZpZGVyOiBPQXV0aFByb3ZpZGVyLFxuICBjbGllbnRTdGF0ZTogc3RyaW5nLFxuICBzZXJ2ZXJJZDogc3RyaW5nLFxuICB1c2VySWQ6IHN0cmluZyB8IG51bGwsXG4gIG9yaWdTY29wZTogc3RyaW5nLFxuICBvcmlnaW5BZGRyZXNzOiBzdHJpbmcgfCBudWxsLFxuICBvcmlnUmVkaXJlY3RVcmk6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICBvcmlnQ2xpZW50SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICByZXNwb25zZVR5cGUgPSBcImNvZGVcIixcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHN0YXRlRGF0YTogU3RhdGVEYXRhID0ge1xuICAgIHJlZGlyZWN0VXJpOiBvcmlnUmVkaXJlY3RVcmksXG4gICAgY2xpZW50U3RhdGUsXG4gICAgY2xpZW50SWQ6IG9yaWdDbGllbnRJZCxcbiAgICBzZXJ2ZXJJZCxcbiAgICBzY29wZTogb3JpZ1Njb3BlLFxuICAgIHByb3ZpZGVySWQ6IHByb3ZpZGVyLmlkLFxuICAgIG9yaWdpbkFkZHJlc3MsXG4gICAgdXNlcklkLFxuICB9O1xuICBjb25zdCBzdGF0ZVBhcmFtID0gZW5jb2RlRGF0YShzdGF0ZURhdGEpO1xuXG4gIGNvbnN0IGF1dGhVcmwgPSBuZXcgVVJMKHByb3ZpZGVyLmF1dGhvcml6YXRpb25VcmwpO1xuICBhdXRoVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJjbGllbnRfaWRcIiwgcHJvdmlkZXIuY2xpZW50SWQpO1xuICBhdXRoVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZWRpcmVjdF91cmlcIiwgY2FsbGJhY2tVcmwocmVxKSk7XG4gIGF1dGhVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInJlc3BvbnNlX3R5cGVcIiwgcmVzcG9uc2VUeXBlKTtcbiAgYXV0aFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic2NvcGVcIiwgcHJvdmlkZXIuc2NvcGVzLmpvaW4oXCIgXCIpKTtcbiAgYXV0aFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic3RhdGVcIiwgc3RhdGVQYXJhbSk7XG4gIGF1dGhVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInByb21wdFwiLCBcImNvbnNlbnRcIik7XG5cbiAgcmV0dXJuIGF1dGhVcmwudG9TdHJpbmcoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRVc2VyVXNlYWJsZVRva2VucyA9IGFzeW5jIChkYjogRGF0YWJhc2UsIHVzZXJJZDogc3RyaW5nLCBwcm92aWRlcklkOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIGF3YWl0IGRiLnByb3ZpZGVyVG9rZW4uZmluZE1hbnkoe1xuICAgIHdoZXJlOiB7XG4gICAgICB1c2VySWQsXG4gICAgICBwcm92aWRlcklkLFxuICAgICAgT1I6IFtcbiAgICAgICAge1xuICAgICAgICAgIGV4cGlyZXNBdDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4cGlyZXNBdDogeyBndGU6IG5ldyBEYXRlKCkgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIE5PVDoge1xuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiBudWxsLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAgb3JkZXJCeToge1xuICAgICAgZXhwaXJlc0F0OiBcImRlc2NcIixcbiAgICB9LFxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXJrVG9rZW5Bc1VzZWQgPSBhc3luYyAoZGI6IERhdGFiYXNlLCB0b2tlbklkOiBzdHJpbmcpID0+XG4gIGF3YWl0IGRiLnByb3ZpZGVyVG9rZW4udXBkYXRlKHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IHRva2VuSWQsXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBsYXN0VXNlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH0sXG4gIH0pO1xuIiwgIi8vIEpTT04tUlBDIDIuMCBFcnJvciBDb2RlcyBwZXIgc3BlY2lmaWNhdGlvblxuLy8gaHR0cHM6Ly93d3cuanNvbnJwYy5vcmcvc3BlY2lmaWNhdGlvbiNlcnJvcl9vYmplY3RcblxuLy8gU3RhbmRhcmQgSlNPTi1SUEMgMi4wIGVycm9yIGNvZGVzICgtMzI3NjggdG8gLTMyMDAwKVxuZXhwb3J0IGNvbnN0IEpTT05SUENfSU5URVJOQUxfRVJST1IgPSAtMzI2MDM7IC8vIEludGVybmFsIEpTT04tUlBDIGVycm9yXG5leHBvcnQgY29uc3QgSlNPTlJQQ19NRVRIT0RfTk9UX0FMTE9XRUQgPSAtMzIwMDA7IC8vIE1ldGhvZCBub3QgYWxsb3dlZFxuXG4vLyBDdXN0b20gYXBwbGljYXRpb24gZXJyb3IgY29kZXNcbmV4cG9ydCBjb25zdCBBUFBfSU5TVUZGSUNJRU5UX1BFUk1JU1NJT05TID0gLTMzMDAxOyAvLyBBdXRob3JpemF0aW9uIGVycm9yXG5leHBvcnQgY29uc3QgQVBQX0lOVkFMSURfU0VSVkVSID0gLTMzMDAzOyAvLyBJbnZhbGlkIHNlcnZlciBJRFxuZXhwb3J0IGNvbnN0IEFQUF9VU0VSX05PVF9GT1VORCA9IC0zMzEwMDsgLy8gVXNlciBub3QgZm91bmQsIHNob3VsZCByZS1hdXRoXG5leHBvcnQgY29uc3QgQVBQX0JBRF9SRVFVRVNUID0gLTMzNDAwOyAvLyBCYWQgcmVxdWVzdFxuXG4vLyBJbnRlcmZhY2UgZm9yIEpTT04tUlBDIDIuMCBlcnJvciByZXNwb25zZVxuZXhwb3J0IGludGVyZmFjZSBKc29uUnBjRXJyb3JSZXNwb25zZSB7XG4gIGpzb25ycGM6IHN0cmluZztcbiAgZXJyb3I6IHtcbiAgICBjb2RlOiBudW1iZXI7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIGRhdGE/OiB1bmtub3duO1xuICB9O1xuICBpZDogdW5rbm93bjtcbn1cblxuLy8gSW50ZXJmYWNlIGZvciByZWd1bGFyIGVycm9yIHJlc3BvbnNlXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUmVzcG9uc2Uge1xuICBlcnJvcjoge1xuICAgIGNvZGU6IG51bWJlcjtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgZGF0YT86IHVua25vd247XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBPQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzdGF0dXNDb2RlOiBudW1iZXI7XG4gIGVycm9yQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgc3RhdHVzQ29kZTogbnVtYmVyLCBlcnJvckNvZGU6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiT0F1dGhFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzaEZvckxvZ2dpbmcoc3RyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBkYXRhID0gZW5jb2Rlci5lbmNvZGUoc3RyKTtcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBkYXRhKS50aGVuKChoYXNoQnVmZmVyKSA9PiB7XG4gICAgY29uc3QgaGFzaEFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShoYXNoQnVmZmVyKSk7XG4gICAgY29uc3QgYmFzZTY0ID0gQnVmZmVyLmZyb20oaGFzaEFycmF5KS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICByZXR1cm4gYmFzZTY0LnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgUm91dGVyIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7XG4gIGFkZFRvV2FpdGxpc3QsXG4gIGVuYWJsZUFkbWluLFxuICBsaXN0QWRtaW5zLFxuICBzZW5kQWRtaW5BcHByb3ZlZE5vdGlmaWNhdGlvbixcbiAgdXBkYXRlQWRtaW4sXG59IGZyb20gXCIuLi9jb250cm9sbGVycy9hZG1pbnMuY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IHsgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSwgc3VwZXJBZG1pbk9ubHlNaWRkbGV3YXJlIH0gZnJvbSBcIi4uL21pZGRsZXdhcmVzL3Nlc3Npb24ubWlkZGxld2FyZS5qc1wiO1xuXG5jb25zdCByb3V0ZXIgPSBSb3V0ZXIoKTtcblxucm91dGVyLnBvc3QoXCIvd2FpdGxpc3RcIiwgYWRkVG9XYWl0bGlzdCk7XG5yb3V0ZXIucHV0KFwiLzphZG1pbklkL2VuYWJsZVwiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCBzdXBlckFkbWluT25seU1pZGRsZXdhcmUsIGVuYWJsZUFkbWluKTtcbnJvdXRlci5wdXQoXCIvOmFkbWluSWRcIiwgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSwgc3VwZXJBZG1pbk9ubHlNaWRkbGV3YXJlLCB1cGRhdGVBZG1pbik7XG5yb3V0ZXIuZ2V0KFwiL1wiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCBzdXBlckFkbWluT25seU1pZGRsZXdhcmUsIGxpc3RBZG1pbnMpO1xucm91dGVyLnBvc3QoXG4gIFwiLzphZG1pbklkL3NlbmQtYXBwcm92ZWQtbm90aWZpY2F0aW9uXCIsXG4gIGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUsXG4gIHN1cGVyQWRtaW5Pbmx5TWlkZGxld2FyZSxcbiAgc2VuZEFkbWluQXBwcm92ZWROb3RpZmljYXRpb24sXG4pO1xuXG5leHBvcnQgZGVmYXVsdCByb3V0ZXI7XG4iLCAiaW1wb3J0IHsgVXBkYXRlQWRtaW5SZXF1ZXN0IH0gZnJvbSBcIkBhZ2VudGJyaWRnZS9hcGlcIjtcbmltcG9ydCB7IFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IFN0YXR1c0NvZGVzIH0gZnJvbSBcImh0dHAtc3RhdHVzLWNvZGVzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVBZG1pblVzZXIsXG4gIGNyZWF0ZVRlbmFudCxcbiAgZ2V0QWRtaW4sXG4gIGdldEFkbWlucyxcbiAgcHV0RW5hYmxlZCxcbiAgcHV0VXBkYXRlQWRtaW4sXG59IGZyb20gXCIuLi9zZXJ2aWNlcy9hZG1pbnMuc2VydmljZS5qc1wiO1xuaW1wb3J0IHsgYW5hbHl0aWNzLCBBbmFseXRpY3NFdmVudHMgfSBmcm9tIFwiLi4vc2VydmljZXMvYW5hbHl0aWNzLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7XG4gIHNlbmRBZGRUb1dhaXRsaXN0RW1haWwsXG4gIHNlbmRBZG1pbkFwcHJvdmVkTm90aWZpY2F0aW9uIGFzIHNlbmRBZG1pbkFwcHJvdmVkTm90aWZpY2F0aW9uU2VydmljZSxcbn0gZnJvbSBcIi4uL3NlcnZpY2VzL2VtYWlsLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IHZlcmlmeUFkbWluVmVyaWZpY2F0aW9uVG9rZW4gfSBmcm9tIFwiLi4vc2VydmljZXMvand0LnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IGlzQWRtaW5SZXF1ZXN0LCBpc0FwcFJlcXVlc3QsIFR5cGVHdWFyZEVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL3JlcS1ndWFyZHMuanNcIjtcblxuZXhwb3J0IGNvbnN0IGFkZFRvV2FpdGxpc3QgPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdDxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBvYmplY3QsIHsgZW1haWw6IHN0cmluZzsgZWFzdGVyRWdnQnlwYXNzPzogYm9vbGVhbiB9PixcbiAgcmVzOiBSZXNwb25zZSxcbikgPT4ge1xuICBpZiAoIWlzQXBwUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgY29uc3QgZW1haWwgPSByZXEuYm9keS5lbWFpbC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBlYXN0ZXJFZ2dCeXBhc3MgPSByZXEuYm9keS5lYXN0ZXJFZ2dCeXBhc3MgfHwgZmFsc2U7XG5cbiAgcmVxLmxvZ2dlci5kZWJ1ZyhcIlByb2Nlc3Npbmcgd2FpdGxpc3QgcmVxdWVzdFwiLCB7IGVtYWlsLCBlYXN0ZXJFZ2dCeXBhc3MgfSk7XG5cbiAgdHJ5IHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiBhZG1pbiBhbHJlYWR5IGV4aXN0c1xuICAgIGNvbnN0IGV4aXN0aW5nQWRtaW4gPSBhd2FpdCByZXEuZGIuYWRtaW4uZmluZEZpcnN0KHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgZXF1YWxzOiBlbWFpbCxcbiAgICAgICAgICBtb2RlOiBcImluc2Vuc2l0aXZlXCIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKGV4aXN0aW5nQWRtaW4pIHtcbiAgICAgIC8vIElmIHVzZXIgZXhpc3RzIGFuZCBoYXMgZWFzdGVyIGVnZywgZW5hYmxlIHRoZW1cbiAgICAgIGlmIChlYXN0ZXJFZ2dCeXBhc3MgJiYgIWV4aXN0aW5nQWRtaW4uZW5hYmxlZCkge1xuICAgICAgICBhd2FpdCByZXEuZGIuYWRtaW4udXBkYXRlKHtcbiAgICAgICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdBZG1pbi5pZCB9LFxuICAgICAgICAgIGRhdGE6IHsgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBzZW5kQWRtaW5BcHByb3ZlZE5vdGlmaWNhdGlvblNlcnZpY2UocmVxLmxvZ2dlciwgZXhpc3RpbmdBZG1pbiwgdHJ1ZSk7XG4gICAgICAgIHJlcS5sb2dnZXIuaW5mbyhcIlx1RDgzRFx1REU4MCBFYXN0ZXIgZWdnIGJ5cGFzcyB1c2VkIC0gZW5hYmxlZCBleGlzdGluZyB1c2VyXCIsIHsgZW1haWwgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuT0spLmpzb24oeyBtZXNzYWdlOiBcIkFjY291bnQgZW5hYmxlZCB2aWEgZWFzdGVyIGVnZyBieXBhc3MhXCIgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgYWxyZWFkeSBleGlzdHMgYW5kIGlzIGVpdGhlciBlbmFibGVkIG9yIGRvZXNuJ3QgaGF2ZSBlYXN0ZXIgZWdnXG4gICAgICBjb25zdCBtZXNzYWdlID0gZXhpc3RpbmdBZG1pbi5lbmFibGVkID8gXCJVc2VyIGFscmVhZHkgaGFzIGFjY2Vzc1wiIDogXCJVc2VyIGFscmVhZHkgb24gd2FpdGxpc3RcIjtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk9LKS5qc29uKHsgbWVzc2FnZSB9KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IHRlbmFudCBhbmQgYWRtaW5cbiAgICBsZXQgYWRtaW47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRlbmFudCA9IGF3YWl0IGNyZWF0ZVRlbmFudChyZXEuZGIsIGVtYWlsKTtcbiAgICAgIGFkbWluID0gYXdhaXQgY3JlYXRlQWRtaW5Vc2VyKHJlcS5kYiwgZW1haWwsIHRlbmFudC5pZCwge1xuICAgICAgICBlbWFpbFZlcmlmaWVkOiB0cnVlLFxuICAgICAgICBlbmFibGVkOiBlYXN0ZXJFZ2dCeXBhc3MsXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJhY2sgYWNjb3VudCBhY3RpdmF0aW9uIGZvciBlYXN0ZXIgZWdnIHVzZXJzXG4gICAgICBpZiAoZWFzdGVyRWdnQnlwYXNzKSB7XG4gICAgICAgIGFuYWx5dGljcy50cmFjayhhZG1pbi5pZCwgQW5hbHl0aWNzRXZlbnRzLkFETUlOX0FDQ09VTlRfQUNUSVZBVEVELCB7XG4gICAgICAgICAgZW1haWw6IGFkbWluLmVtYWlsLFxuICAgICAgICAgIHRlbmFudF9pZDogYWRtaW4udGVuYW50SWQsXG4gICAgICAgICAgYWN0aXZhdGlvbl9tZXRob2Q6IFwiZWFzdGVyX2VnZ1wiLFxuICAgICAgICAgIGFwcHJvdmVkX2J5OiBcImVhc3Rlcl9lZ2dcIixcbiAgICAgICAgICB3YWl0X3RpbWVfaG91cnM6IDAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGNyZWF0ZUVycm9yOiB1bmtub3duKSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYWRtaW4gd2FzIGNyZWF0ZWQgYnkgYW5vdGhlciBjb25jdXJyZW50IHJlcXVlc3RcbiAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlRXJyb3IgYXMgeyBjb2RlPzogc3RyaW5nOyBtZXRhPzogeyB0YXJnZXQ/OiBzdHJpbmdbXSB9IH07XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJQMjAwMlwiICYmIGVycm9yLm1ldGE/LnRhcmdldD8uaW5jbHVkZXMoXCJlbWFpbFwiKSkge1xuICAgICAgICByZXEubG9nZ2VyLmluZm8oXCJBZG1pbiB3YXMgY3JlYXRlZCBjb25jdXJyZW50bHksIGZldGNoaW5nIGV4aXN0aW5nXCIsIHsgZW1haWwgfSk7XG5cbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGFkbWluIHRoYXQgd2FzIGp1c3QgY3JlYXRlZFxuICAgICAgICBjb25zdCBleGlzdGluZ0FkbWluID0gYXdhaXQgcmVxLmRiLmFkbWluLmZpbmRGaXJzdCh7XG4gICAgICAgICAgd2hlcmU6IHsgZW1haWw6IHsgZXF1YWxzOiBlbWFpbCwgbW9kZTogXCJpbnNlbnNpdGl2ZVwiIH0gfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nQWRtaW4pIHtcbiAgICAgICAgICAvLyBJZiBlYXN0ZXIgZWdnLCBlbmFibGUgdGhlIHVzZXJcbiAgICAgICAgICBpZiAoZWFzdGVyRWdnQnlwYXNzICYmICFleGlzdGluZ0FkbWluLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGFkbWluID0gYXdhaXQgcmVxLmRiLmFkbWluLnVwZGF0ZSh7XG4gICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBleGlzdGluZ0FkbWluLmlkIH0sXG4gICAgICAgICAgICAgIGRhdGE6IHsgZW5hYmxlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRyYWNrIGFjY291bnQgYWN0aXZhdGlvbiBmb3IgZWFzdGVyIGVnZyB1c2Vyc1xuICAgICAgICAgICAgYW5hbHl0aWNzLnRyYWNrKGFkbWluLmlkLCBBbmFseXRpY3NFdmVudHMuQURNSU5fQUNDT1VOVF9BQ1RJVkFURUQsIHtcbiAgICAgICAgICAgICAgZW1haWw6IGFkbWluLmVtYWlsLFxuICAgICAgICAgICAgICB0ZW5hbnRfaWQ6IGFkbWluLnRlbmFudElkLFxuICAgICAgICAgICAgICBhY3RpdmF0aW9uX21ldGhvZDogXCJlYXN0ZXJfZWdnXCIsXG4gICAgICAgICAgICAgIGFwcHJvdmVkX2J5OiBcImVhc3Rlcl9lZ2dcIixcbiAgICAgICAgICAgICAgd2FpdF90aW1lX2hvdXJzOiBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZXhpc3RpbmdBZG1pbi5jcmVhdGVkQXQuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCkpLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IHNlbmRBZG1pbkFwcHJvdmVkTm90aWZpY2F0aW9uU2VydmljZShyZXEubG9nZ2VyLCBhZG1pbiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXEubG9nZ2VyLmluZm8oXCJcdUQ4M0RcdURFODAgRWFzdGVyIGVnZyBieXBhc3MgdXNlZCAtIGVuYWJsZWQgY29uY3VycmVudCB1c2VyXCIsIHsgZW1haWwgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkbWluID0gZXhpc3RpbmdBZG1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3I7IC8vIFJlLXRocm93IGlmIHdlIHN0aWxsIGNhbid0IGZpbmQgdGhlIGFkbWluXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yOyAvLyBSZS10aHJvdyBpZiBpdCdzIG5vdCBhIGR1cGxpY2F0ZSBlbWFpbCBlcnJvclxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNlbmQgYXBwcm9wcmlhdGUgZW1haWxcbiAgICBjb25zdCBzdWNjZXNzID0gZWFzdGVyRWdnQnlwYXNzXG4gICAgICA/IGF3YWl0IHNlbmRBZG1pbkFwcHJvdmVkTm90aWZpY2F0aW9uU2VydmljZShyZXEubG9nZ2VyLCBhZG1pbiwgdHJ1ZSlcbiAgICAgIDogYXdhaXQgc2VuZEFkZFRvV2FpdGxpc3RFbWFpbChyZXEubG9nZ2VyLCBhZG1pbik7XG5cbiAgICBpZiAoZWFzdGVyRWdnQnlwYXNzKSB7XG4gICAgICByZXEubG9nZ2VyLmluZm8oXCJcdUQ4M0RcdURFODAgRWFzdGVyIGVnZyBieXBhc3MgdXNlZFwiLCB7IGVtYWlsIH0pO1xuICAgIH1cblxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZWFzdGVyRWdnQnlwYXNzID8gXCJBY2NvdW50IGNyZWF0ZWQgYW5kIGVuYWJsZWQgdmlhIGVhc3RlciBlZ2cgYnlwYXNzIVwiIDogXCJBZGRlZCB0byB3YWl0bGlzdFwiO1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5PSykuanNvbih7IG1lc3NhZ2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHsgbWVzc2FnZTogXCJGYWlsZWQgdG8gc2VuZCBlbWFpbFwiIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRXJyb3IgaW4gYWRkVG9XYWl0bGlzdFwiLCB7IGVycm9yLCBlbWFpbCB9KTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgcmVxdWVzdFwiIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbGlzdEFkbWlucyA9IGFzeW5jIChyZXE6IFJlcXVlc3Q8UmVjb3JkPHN0cmluZywgc3RyaW5nPiwgb2JqZWN0LCBvYmplY3Q+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIGNvbnN0IGFkbWlucyA9IGF3YWl0IGdldEFkbWlucyhyZXEuZGIpO1xuXG4gIGlmICghYWRtaW5zKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgbWVzc2FnZTogXCJObyBhZG1pbnMgZm91bmRcIiB9KTtcbiAgfVxuICByZXMuanNvbihhZG1pbnMpO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUFkbWluID0gYXN5bmMgKHJlcTogUmVxdWVzdDxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBvYmplY3QsIFVwZGF0ZUFkbWluUmVxdWVzdD4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgY29uc3QgYWRtaW4gPSBhd2FpdCBwdXRVcGRhdGVBZG1pbihyZXEuZGIsIHJlcS5wYXJhbXMuYWRtaW5JZCwgcmVxLmJvZHkpO1xuXG4gIHJlcy5qc29uKGFkbWluKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlbmFibGVBZG1pbiA9IGFzeW5jIChcbiAgcmVxOiBSZXF1ZXN0PFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIG9iamVjdCwgeyB0b2tlbj86IHN0cmluZzsgZW5hYmxlZDogYm9vbGVhbjsgc2VuZE5vdGlmaWNhdGlvbj86IGJvb2xlYW4gfT4sXG4gIHJlczogUmVzcG9uc2UsXG4pID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgbGV0IGFkbWluSWQgPSByZXEucGFyYW1zLmFkbWluSWQ7XG4gIGlmIChyZXEuYm9keS50b2tlbikge1xuICAgIGNvbnN0IGFkbWluID0gYXdhaXQgdmVyaWZ5QWRtaW5WZXJpZmljYXRpb25Ub2tlbihyZXEuYm9keS50b2tlbik7XG4gICAgaWYgKCFhZG1pbikge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuVU5BVVRIT1JJWkVEKS5qc29uKHsgbWVzc2FnZTogXCJJbnZhbGlkIHZlcmlmaWNhdGlvbiB0b2tlblwiIH0pO1xuICAgIH1cbiAgICBhZG1pbklkID0gYWRtaW4uaWQ7XG4gIH1cbiAgY29uc3QgYWRtaW4gPSBhd2FpdCBwdXRFbmFibGVkKFxuICAgIHJlcS5kYixcbiAgICByZXEubG9nZ2VyLFxuICAgIGFkbWluSWQsXG4gICAgcmVxLmJvZHkuZW5hYmxlZCxcbiAgICByZXEuYm9keS5zZW5kTm90aWZpY2F0aW9uLFxuICAgIHJlcS5hZG1pbi5pZCxcbiAgKTtcblxuICByZXMuanNvbihhZG1pbik7XG59O1xuXG5leHBvcnQgY29uc3Qgc2VuZEFkbWluQXBwcm92ZWROb3RpZmljYXRpb24gPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdDxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBvYmplY3QsIHsgYWRtaW5JZDogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIGNvbnN0IGFkbWluID0gYXdhaXQgZ2V0QWRtaW4ocmVxLmRiLCByZXEucGFyYW1zLmFkbWluSWQpO1xuICBpZiAoIWFkbWluKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgbWVzc2FnZTogXCJBZG1pbiBub3QgZm91bmRcIiB9KTtcbiAgfVxuICBhd2FpdCBzZW5kQWRtaW5BcHByb3ZlZE5vdGlmaWNhdGlvblNlcnZpY2UocmVxLmxvZ2dlciwgYWRtaW4pO1xuXG4gIHJlcy5qc29uKGFkbWluKTtcbn07XG4iLCAiaW1wb3J0IHsgQWRtaW4sIEFkbWluUm9sZSB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuXG5pbXBvcnQgeyBVcGRhdGVBZG1pblJlcXVlc3QgfSBmcm9tIFwiQGFnZW50YnJpZGdlL2FwaVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIndpbnN0b25cIjtcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSBcIi4uL3V0aWxzL2Nvbm5lY3Rpb24uanNcIjtcbmltcG9ydCB7IGFuYWx5dGljcywgQW5hbHl0aWNzRXZlbnRzIH0gZnJvbSBcIi4vYW5hbHl0aWNzLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IHNlbmRBZG1pbkFwcHJvdmVkTm90aWZpY2F0aW9uIH0gZnJvbSBcIi4vZW1haWwuc2VydmljZS5qc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVBZG1pblRva2VuIH0gZnJvbSBcIi4vand0LnNlcnZpY2UuanNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFkbWluVXNlcihcbiAgZGI6IERhdGFiYXNlLFxuICBlbWFpbDogc3RyaW5nLFxuICB0ZW5hbnRJZDogc3RyaW5nLFxuICBleHRyYXM/OiBQYXJ0aWFsPE9taXQ8QWRtaW4sIFwiZW1haWxcIiB8IFwidGVuYW50SWRcIj4+LFxuKSB7XG4gIGxldCByb2xlOiBBZG1pblJvbGU7XG4gIGlmIChlbWFpbC5lbmRzV2l0aChcIkBvd25pZC5jb21cIikpIHtcbiAgICByb2xlID0gQWRtaW5Sb2xlLnN1cGVyYWRtaW47XG4gIH0gZWxzZSB7XG4gICAgcm9sZSA9IEFkbWluUm9sZS5hZG1pbjtcbiAgfVxuICByZXR1cm4gYXdhaXQgZGIuYWRtaW4uY3JlYXRlKHtcbiAgICBkYXRhOiB7XG4gICAgICAuLi5leHRyYXMsXG4gICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgIHRlbmFudElkOiB0ZW5hbnRJZCxcbiAgICAgIHJvbGUsXG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZW5hbnQoZGI6IERhdGFiYXNlLCBuYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGF3YWl0IGRiLnRlbmFudC5jcmVhdGUoe1xuICAgIGRhdGE6IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRBZG1pbk93bklkRGF0YShkYjogRGF0YWJhc2UsIGVtYWlsOiBzdHJpbmcsIG93bklkRGF0YTogc3RyaW5nKSB7XG4gIGNvbnN0IGFkbWluID0gYXdhaXQgZGIuYWRtaW4uZmluZEZpcnN0KHtcbiAgICB3aGVyZToge1xuICAgICAgZW1haWw6IHtcbiAgICAgICAgZXF1YWxzOiBlbWFpbCxcbiAgICAgICAgbW9kZTogXCJpbnNlbnNpdGl2ZVwiLFxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcblxuICBpZiAoIWFkbWluKSB7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcIk5PVF9GT1VORFwiLCBlcnJvcjogXCJBZG1pbiBub3QgZm91bmRcIiB9O1xuICB9XG5cbiAgYXdhaXQgZGIuYWRtaW4udXBkYXRlKHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IGFkbWluLmlkLFxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgb3duaWREYXRhOiBvd25JZERhdGEsXG4gICAgfSxcbiAgfSk7XG4gIHJldHVybiB7IHN0YXR1czogXCJPS1wiLCBlcnJvcjogbnVsbCB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWRtaW5Pd25JZERhdGEoZGI6IERhdGFiYXNlLCBsb2dnZXI6IExvZ2dlciwgZW1haWw6IHN0cmluZykge1xuICBjb25zdCBhZG1pbiA9IGF3YWl0IGRiLmFkbWluLmZpbmRGaXJzdCh7XG4gICAgd2hlcmU6IHtcbiAgICAgIGVtYWlsOiB7XG4gICAgICAgIGVxdWFsczogZW1haWwsXG4gICAgICAgIG1vZGU6IFwiaW5zZW5zaXRpdmVcIixcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgaWYgKCFhZG1pbikge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkFkbWluIG5vdCBmb3VuZFwiLCB7IGVtYWlsIH0pO1xuICAgIHJldHVybiB7IHN0YXR1czogXCJOT1RfRk9VTkRcIiwgZXJyb3I6IFwiQWRtaW4gbm90IGZvdW5kXCIgfTtcbiAgfVxuXG4gIGxvZ2dlci5kZWJ1ZyhcIkFkbWluIGZvdW5kXCIsIHsgZW1haWwsIG93bmlkRGF0YTogYWRtaW4ub3duaWREYXRhLCBlbmFibGVkOiBhZG1pbi5lbmFibGVkIH0pO1xuXG4gIGlmICghYWRtaW4uZW5hYmxlZCkge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJMT0NLRURcIiwgZXJyb3I6IFwiQWRtaW4gbm90IGVuYWJsZWRcIiB9O1xuICB9XG5cbiAgaWYgKGFkbWluLm93bmlkRGF0YSkge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJPS1wiLCBkYXRhOiB7IG93bklkRGF0YTogYWRtaW4ub3duaWREYXRhIH0gfTtcbiAgfVxuXG4gIHJldHVybiB7IHN0YXR1czogXCJOT19DT05URU5UXCIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFkbWluU2Vzc2lvbihkYjogRGF0YWJhc2UsIGxvZ2dlcjogTG9nZ2VyLCBlbWFpbDogc3RyaW5nKSB7XG4gIGNvbnN0IGFkbWluID0gYXdhaXQgZGIuYWRtaW4uZmluZEZpcnN0KHtcbiAgICB3aGVyZToge1xuICAgICAgZW1haWw6IHtcbiAgICAgICAgZXF1YWxzOiBlbWFpbCxcbiAgICAgICAgbW9kZTogXCJpbnNlbnNpdGl2ZVwiLFxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcblxuICBpZiAoIWFkbWluKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiQWRtaW4gbm90IGZvdW5kXCIsIHsgZW1haWwgfSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcIk5PVF9GT1VORFwiLCBlcnJvcjogXCJBZG1pbiBub3QgZm91bmRcIiB9O1xuICB9XG5cbiAgY29uc3QgdG9rZW4gPSBhd2FpdCBnZW5lcmF0ZUFkbWluVG9rZW4oYWRtaW4pO1xuICByZXR1cm4geyBzdGF0dXM6IFwiT0tcIiwgZGF0YTogeyB0b2tlbiB9IH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBZG1pbnMoZGI6IERhdGFiYXNlKSB7XG4gIHJldHVybiBkYi5hZG1pbi5maW5kTWFueSh7XG4gICAgd2hlcmU6IHtcbiAgICAgIHJvbGU6IHtcbiAgICAgICAgaW46IFtcImFkbWluXCIsIFwic3VwZXJhZG1pblwiXSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBvcmRlckJ5OiBbeyBuYW1lOiBcImFzY1wiIH0sIHsgaWQ6IFwiYXNjXCIgfV0sXG4gICAgaW5jbHVkZTogeyB0ZW5hbnQ6IHRydWUgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwdXRFbmFibGVkKFxuICBkYjogRGF0YWJhc2UsXG4gIGxvZ2dlcjogTG9nZ2VyLFxuICBhZG1pbklkOiBzdHJpbmcsXG4gIGVuYWJsZWQ6IGJvb2xlYW4sXG4gIHNlbmROb3RpZmljYXRpb24/OiBib29sZWFuLFxuICBhcHByb3ZlZEJ5QWRtaW5JZD86IHN0cmluZyxcbikge1xuICBjb25zdCBhZG1pbiA9IGF3YWl0IGRiLmFkbWluLnVwZGF0ZSh7XG4gICAgd2hlcmU6IHsgaWQ6IGFkbWluSWQgfSxcbiAgICBkYXRhOiB7IGVuYWJsZWQgfSxcbiAgICBpbmNsdWRlOiB7IHRlbmFudDogdHJ1ZSB9LFxuICB9KTtcblxuICBpZiAoZW5hYmxlZCkge1xuICAgIGFuYWx5dGljcy50cmFjayhhZG1pbi5pZCwgQW5hbHl0aWNzRXZlbnRzLkFETUlOX0FDQ09VTlRfQUNUSVZBVEVELCB7XG4gICAgICBlbWFpbDogYWRtaW4uZW1haWwsXG4gICAgICB0ZW5hbnRfaWQ6IGFkbWluLnRlbmFudElkLFxuICAgICAgYWN0aXZhdGlvbl9tZXRob2Q6IFwibWFudWFsX2FwcHJvdmFsXCIsXG4gICAgICBhcHByb3ZlZF9ieTogYXBwcm92ZWRCeUFkbWluSWQgfHwgXCJzeXN0ZW1cIixcbiAgICAgIHdhaXRfdGltZV9ob3VyczogYWRtaW4uY3JlYXRlZEF0XG4gICAgICAgID8gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIG5ldyBEYXRlKGFkbWluLmNyZWF0ZWRBdCkuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCkpXG4gICAgICAgIDogMCxcbiAgICB9KTtcbiAgfVxuICBpZiAoc2VuZE5vdGlmaWNhdGlvbikge1xuICAgIGF3YWl0IHNlbmRBZG1pbkFwcHJvdmVkTm90aWZpY2F0aW9uKGxvZ2dlciwgYWRtaW4pO1xuICB9XG4gIHJldHVybiBhZG1pbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1dFVwZGF0ZUFkbWluKGRiOiBEYXRhYmFzZSwgYWRtaW5JZDogc3RyaW5nLCB1cGRhdGVzOiBVcGRhdGVBZG1pblJlcXVlc3QpIHtcbiAgY29uc3QgZGF0YTogeyBuYW1lPzogc3RyaW5nOyByb2xlPzogQWRtaW5Sb2xlIH0gPSB7fTtcblxuICBpZiAodXBkYXRlcy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBkYXRhLm5hbWUgPSB1cGRhdGVzLm5hbWU7XG4gIH1cblxuICBpZiAodXBkYXRlcy5yb2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICBkYXRhLnJvbGUgPSB1cGRhdGVzLnJvbGUudG9Mb3dlckNhc2UoKSBhcyBBZG1pblJvbGU7XG4gIH1cblxuICByZXR1cm4gZGIuYWRtaW4udXBkYXRlKHtcbiAgICB3aGVyZTogeyBpZDogYWRtaW5JZCB9LFxuICAgIGRhdGEsXG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWRtaW4oZGI6IERhdGFiYXNlLCBhZG1pbklkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGRiLmFkbWluLmZpbmRVbmlxdWUoe1xuICAgIHdoZXJlOiB7IGlkOiBhZG1pbklkIH0sXG4gIH0pO1xufVxuIiwgImltcG9ydCB7IERlZXBQYXJ0aWFsLCBPcGVuQVBJIH0gZnJvbSBcIkBhZ2VudGJyaWRnZS91dGlsc1wiO1xuaW1wb3J0IHsgSHR0cE1ldGhvZCwgdHlwZSBQcmlzbWEgfSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcbmltcG9ydCB7IFJlZlJlc29sdmVyIH0gZnJvbSBcImpzb24tc2NoZW1hLXJlZi1yZXNvbHZlclwiO1xuaW1wb3J0IHsgT3BlbkFQSVYyLCBPcGVuQVBJVjMgfSBmcm9tIFwib3BlbmFwaS10eXBlc1wiO1xuaW1wb3J0IHsgRW50cmllcyB9IGZyb20gXCJ0eXBlLWZlc3RcIjtcbmltcG9ydCB7IGZpbHRlck9iamVjdCB9IGZyb20gXCIuLi9maWx0ZXJPYmplY3QuanNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBPcGVuQXBpVmFsaWRhdGlvbkVycm9yQ29udGVudCB7XG4gIGVycm9yOiBzdHJpbmc7XG4gIGVycm9yRGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuZW51bSBFcnJvcnMge1xuICBOb3RSZXNvbHZhYmxlUmVmID0gXCJjYW5ub3QgcmVzb2x2ZSAkcmVmXCIsXG4gIEVtcHR5UmVmID0gXCIkcmVmIGlzIG5vdCBhIHN0cmluZ1wiLFxuICBFbXB0eSA9IFwiZW1wdHkgb2JqZWN0XCIsXG4gIE5vdFZhbGlkUGF0aCA9IFwibm90IGEgdmFsaWQgcGF0aFwiLFxufVxuY2xhc3MgT3BlbkFwaVZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyBlcnJvcjogc3RyaW5nLFxuICAgIHB1YmxpYyBlcnJvckRlc2NyaXB0aW9uPzogc3RyaW5nLFxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5lcnJvckRlc2NyaXB0aW9uID0gZXJyb3JEZXNjcmlwdGlvbjtcbiAgfVxufVxuY29uc3QgaXNPcGVuQXBpVjIgPSAob3BlbkFwaUNvbnRlbnQ6IERlZXBQYXJ0aWFsPE9wZW5BUEkuRG9jdW1lbnQ+KTogb3BlbkFwaUNvbnRlbnQgaXMgT3BlbkFQSS5WMkRvY3VtZW50ID0+IHtcbiAgcmV0dXJuIFwic3dhZ2dlclwiIGluIG9wZW5BcGlDb250ZW50O1xufTtcblxudHlwZSBCYXNlVmFsaWRhdGVkT3BlbkFwaSA9IERlZXBQYXJ0aWFsPE9wZW5BUEkuRG9jdW1lbnQ+ICYgeyBpbmZvOiB7IHRpdGxlOiBzdHJpbmcgfSB9O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVPcGVuQXBpQ29udGVudDogKFxuICByZWZSZXNvbHZlcjogUmVmUmVzb2x2ZXIsXG4gIG9wZW5BcGlDb250ZW50OiBEZWVwUGFydGlhbDxPcGVuQVBJLkRvY3VtZW50PixcbikgPT4gYXNzZXJ0cyBvcGVuQXBpQ29udGVudCBpcyBCYXNlVmFsaWRhdGVkT3BlbkFwaSA9IChcbiAgcmVmUmVzb2x2ZXI6IFJlZlJlc29sdmVyLFxuICBvcGVuQXBpQ29udGVudDogRGVlcFBhcnRpYWw8T3BlbkFQSS5Eb2N1bWVudD4sXG4pOiBhc3NlcnRzIG9wZW5BcGlDb250ZW50IGlzIEJhc2VWYWxpZGF0ZWRPcGVuQXBpID0+IHtcbiAgaWYgKCFvcGVuQXBpQ29udGVudCkge1xuICAgIHRocm93IG5ldyBPcGVuQXBpVmFsaWRhdGlvbkVycm9yKFwiRW1wdHkgT3BlbkFQSSBjb250ZW50XCIsIFwiaW52YWxpZF9vcGVuYXBpXCIsIFwiT3BlbkFQSSBjb250ZW50IGlzIGVtcHR5XCIpO1xuICB9XG5cbiAgaWYgKCFvcGVuQXBpQ29udGVudD8uaW5mbykge1xuICAgIHRocm93IG5ldyBPcGVuQXBpVmFsaWRhdGlvbkVycm9yKFxuICAgICAgXCJPcGVuQVBJIGluZm8gc2VjdGlvbiBpcyByZXF1aXJlZFwiLFxuICAgICAgXCJpbnZhbGlkX29wZW5hcGlcIixcbiAgICAgIFwiT3BlbkFQSSBpbmZvIHNlY3Rpb24gaXMgcmVxdWlyZWRcIixcbiAgICApO1xuICB9XG5cbiAgaWYgKCFvcGVuQXBpQ29udGVudD8uaW5mbz8udGl0bGUpIHtcbiAgICB0aHJvdyBuZXcgT3BlbkFwaVZhbGlkYXRpb25FcnJvcihcIk9wZW5BUEkgdGl0bGUgaXMgcmVxdWlyZWRcIiwgXCJpbnZhbGlkX29wZW5hcGlcIiwgXCJPcGVuQVBJIHRpdGxlIGlzIHJlcXVpcmVkXCIpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBnZXRTZXJ2ZXJVcmxGcm9tT3BlbkFwaShvcGVuQXBpQ29udGVudCk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBPcGVuQXBpVmFsaWRhdGlvbkVycm9yKFxuICAgICAgXCJTZXJ2ZXIgVVJMIGlzIHJlcXVpcmVkIGluIHRoZSBPcGVuQVBJIHNwZWNpZmljYXRpb25cIixcbiAgICAgIFwiaW52YWxpZF9vcGVuYXBpXCIsXG4gICAgICBcIlNlcnZlciBVUkwgaXMgcmVxdWlyZWQgaW4gdGhlIE9wZW5BUEkgc3BlY2lmaWNhdGlvblwiLFxuICAgICk7XG4gIH1cblxuICB0cnkge1xuICAgIGdldFNlY3VyaXR5U2NoZW1lc0Zyb21PcGVuQXBpKHJlZlJlc29sdmVyLCBvcGVuQXBpQ29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgIHRocm93IG5ldyBPcGVuQXBpVmFsaWRhdGlvbkVycm9yKFxuICAgICAgXCJTZWN1cml0eSBzY2hlbWVzIGFyZSByZXF1aXJlZCBpbiB0aGUgT3BlbkFQSSBzcGVjaWZpY2F0aW9uXCIsXG4gICAgICBcImludmFsaWRfb3BlbmFwaVwiLFxuICAgICAgXCJTZWN1cml0eSBzY2hlbWVzIGFyZSByZXF1aXJlZCBpbiB0aGUgT3BlbkFQSSBzcGVjaWZpY2F0aW9uXCIsXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFNlcnZlclVybEZyb21PcGVuQXBpID0gKG9wZW5BcGlDb250ZW50OiBEZWVwUGFydGlhbDxPcGVuQVBJLkRvY3VtZW50Pik6IHN0cmluZyA9PiB7XG4gIGlmIChpc09wZW5BcGlWMihvcGVuQXBpQ29udGVudCkgJiYgb3BlbkFwaUNvbnRlbnQuaG9zdCkge1xuICAgIHJldHVybiBvcGVuQXBpQ29udGVudC5ob3N0O1xuICB9XG5cbiAgaWYgKFwic2VydmVyc1wiIGluIG9wZW5BcGlDb250ZW50ICYmIEFycmF5LmlzQXJyYXkob3BlbkFwaUNvbnRlbnQuc2VydmVycykgJiYgb3BlbkFwaUNvbnRlbnQuc2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG9wZW5BcGlDb250ZW50LnNlcnZlcnNbMF0udXJsO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmVyIFVSTCBpcyByZXF1aXJlZCBpbiB0aGUgT3BlbkFQSSBzcGVjaWZpY2F0aW9uXCIpO1xufTtcblxuY29uc3QgZ2V0U2VjdXJpdHlTY2hlbWVzRnJvbU9wZW5BcGkzID0gKFxuICByZWZSZXNvbHZlcjogUmVmUmVzb2x2ZXIsXG4gIG9wZW5BcGlDb250ZW50OiBEZWVwUGFydGlhbDxPcGVuQVBJLkRvY3VtZW50Pixcbik6IE9wZW5BUEkuU2VjdXJpdHlTY2hlbWVPQXV0aDIgPT4ge1xuICBpZiAoIShcImNvbXBvbmVudHNcIiBpbiBvcGVuQXBpQ29udGVudCkgfHwgIW9wZW5BcGlDb250ZW50LmNvbXBvbmVudHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPQXV0aCAyLjAgc2VjdXJpdHkgcmVxdWlyZW1lbnQgbXVzdCBoYXZlIGV4YWN0bHkgb25lIHNjb3BlXCIpO1xuICB9XG4gIGlmICghKFwic2VjdXJpdHlTY2hlbWVzXCIgaW4gb3BlbkFwaUNvbnRlbnQuY29tcG9uZW50cykgfHwgIW9wZW5BcGlDb250ZW50LmNvbXBvbmVudHMuc2VjdXJpdHlTY2hlbWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT0F1dGggMi4wIHNlY3VyaXR5IHJlcXVpcmVtZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBzY29wZVwiKTtcbiAgfVxuXG4gIGNvbnN0IHNlY1NjaGVtYXM6IFJlY29yZDxzdHJpbmcsIE9wZW5BUEkuU2VjdXJpdHlTY2hlbWVPQXV0aDI+ID0ge307XG4gIE9iamVjdC5rZXlzKG9wZW5BcGlDb250ZW50LmNvbXBvbmVudHMuc2VjdXJpdHlTY2hlbWVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAob3BlbkFwaUNvbnRlbnQuY29tcG9uZW50cy5zZWN1cml0eVNjaGVtZXNba2V5XSkge1xuICAgICAgc2VjU2NoZW1hc1trZXldID0gcmVzb2x2ZVJlZihyZWZSZXNvbHZlciwgb3BlbkFwaUNvbnRlbnQuY29tcG9uZW50cy5zZWN1cml0eVNjaGVtZXNba2V5XSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIXNlY1NjaGVtYXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPQXV0aCAyLjAgc2VjdXJpdHkgcmVxdWlyZW1lbnQgbXVzdCBoYXZlIGV4YWN0bHkgb25lIHNjb3BlXCIpO1xuICB9XG4gIGNvbnN0IG9hdXRoU2VjdXJpdHkgPSBmaWx0ZXJPYmplY3Qoc2VjU2NoZW1hcywgKFtfLCBpdGVtXSkgPT4gaXRlbVtcInR5cGVcIl0gPT09IFwib2F1dGgyXCIpO1xuICBpZiAoT2JqZWN0LmtleXMob2F1dGhTZWN1cml0eSkubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT0F1dGggMi4wIHNlY3VyaXR5IHJlcXVpcmVtZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBzY29wZVwiKTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gT2JqZWN0LnZhbHVlcyhvYXV0aFNlY3VyaXR5KVswXTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9BdXRoIDIuMCBzZWN1cml0eSByZXF1aXJlbWVudCBtdXN0IGhhdmUgZXhhY3RseSBvbmUgc2NvcGVcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgZ2V0VG9vbE5hbWUgPSAocGF0aDogc3RyaW5nLCBtZXRob2Q6IE9wZW5BUEkuSHR0cE1ldGhvZHMsIG9wZXJhdGlvbjogT3BlbkFQSS5PcGVyYXRpb24pOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gb3BlcmF0aW9uPy5vcGVyYXRpb25JZCB8fCBgJHttZXRob2QudG9VcHBlckNhc2UoKX0gJHtwYXRofWA7XG59O1xuXG5jb25zdCBnZXRTZWN1cml0eVNjaGVtZXNGcm9tT3BlbkFwaTIgPSAoXG4gIHJlZlJlc29sdmVyOiBSZWZSZXNvbHZlcixcbiAgb3BlbkFwaUNvbnRlbnQ6IERlZXBQYXJ0aWFsPE9wZW5BUEkuRG9jdW1lbnQ+LFxuKTogT3BlbkFQSS5TZWN1cml0eVNjaGVtZU9BdXRoMiA9PiB7XG4gIGlmICghKFwic2VjdXJpdHlEZWZpbml0aW9uc1wiIGluIG9wZW5BcGlDb250ZW50KSB8fCAhb3BlbkFwaUNvbnRlbnQuc2VjdXJpdHlEZWZpbml0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9BdXRoIDIuMCBzZWN1cml0eSByZXF1aXJlbWVudCBtdXN0IGhhdmUgZXhhY3RseSBvbmUgc2NvcGVcIik7XG4gIH1cbiAgY29uc3Qgc2VjU2NoZW1hczogT3BlbkFQSS5TZWN1cml0eVNjaGVtZU9BdXRoMltdID1cbiAgICBcIiRyZWZcIiBpbiBvcGVuQXBpQ29udGVudC5zZWN1cml0eURlZmluaXRpb25zICYmIHR5cGVvZiBvcGVuQXBpQ29udGVudC5zZWN1cml0eURlZmluaXRpb25zW1wiJHJlZlwiXSA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyByZWZSZXNvbHZlci5nZXREZXJlZlNjaGVtYShvcGVuQXBpQ29udGVudC5zZWN1cml0eURlZmluaXRpb25zW1wiJHJlZlwiXSlcbiAgICAgIDogb3BlbkFwaUNvbnRlbnQuc2VjdXJpdHlEZWZpbml0aW9ucztcbiAgaWYgKHNlY1NjaGVtYXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk9BdXRoIDIuMCBzZWN1cml0eSByZXF1aXJlbWVudCBtdXN0IGhhdmUgZXhhY3RseSBvbmUgc2NvcGVcIik7XG4gIH1cbiAgY29uc3Qgb2F1dGhTZWN1cml0eSA9IHNlY1NjaGVtYXMuZmlsdGVyKChzY2hlbWUpID0+IHNjaGVtZS50eXBlID09PSBcIm9hdXRoMlwiKTtcbiAgaWYgKG9hdXRoU2VjdXJpdHkubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT0F1dGggMi4wIHNlY3VyaXR5IHJlcXVpcmVtZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBzY29wZVwiKTtcbiAgfVxuXG4gIGlmIChcIiRyZWZcIiBpbiBvYXV0aFNlY3VyaXR5WzBdICYmIHR5cGVvZiBvYXV0aFNlY3VyaXR5WzBdW1wiJHJlZlwiXSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSByZWZSZXNvbHZlci5nZXREZXJlZlNjaGVtYShvYXV0aFNlY3VyaXR5WzBdW1wiJHJlZlwiXSk7XG4gICAgaWYgKHJlc29sdmVkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT0F1dGggMi4wIHNlY3VyaXR5IHJlcXVpcmVtZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBzY29wZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkVmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiT0F1dGggMi4wIHNlY3VyaXR5IHJlcXVpcmVtZW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBzY29wZVwiKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTZWN1cml0eVNjaGVtZXNGcm9tT3BlbkFwaSA9IChcbiAgcmVmUmVzb2x2ZXI6IFJlZlJlc29sdmVyLFxuICBvcGVuQXBpQ29udGVudDogRGVlcFBhcnRpYWw8T3BlbkFQSS5Eb2N1bWVudD4sXG4pOiBPcGVuQVBJLlNlY3VyaXR5U2NoZW1lT0F1dGgyID0+IHtcbiAgaWYgKGlzT3BlbkFwaVYyKG9wZW5BcGlDb250ZW50KSkge1xuICAgIHJldHVybiBnZXRTZWN1cml0eVNjaGVtZXNGcm9tT3BlbkFwaTIocmVmUmVzb2x2ZXIsIG9wZW5BcGlDb250ZW50KTtcbiAgfVxuICByZXR1cm4gZ2V0U2VjdXJpdHlTY2hlbWVzRnJvbU9wZW5BcGkzKHJlZlJlc29sdmVyLCBvcGVuQXBpQ29udGVudCk7XG59O1xuXG5jb25zdCBpc0h0dHBNZXRob2QgPSAobWV0aG9kOiB1bmtub3duKTogbWV0aG9kIGlzIE9wZW5BUEkuSHR0cE1ldGhvZHMgPT5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciB0cygyMzQ1KSBlcnJvciBzaG91bGQgYmUgaWdub3JlZFxuICBbLi4uT2JqZWN0LnZhbHVlcyhPcGVuQVBJVjIuSHR0cE1ldGhvZHMpLCAuLi5PYmplY3QudmFsdWVzKE9wZW5BUElWMy5IdHRwTWV0aG9kcyldLmluY2x1ZGVzKG1ldGhvZCk7XG5cbmNvbnN0IGlzT3BlcmF0aW9uT2JqZWN0ID0gKG9iamVjdDogdW5rbm93bik6IG9iamVjdCBpcyBPcGVuQVBJLk9wZXJhdGlvbk9iamVjdCA9PiB7XG4gIHJldHVybiAoXG4gICAgISFvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmXG4gICAgXCJvcGVyYXRpb25JZFwiIGluIG9iamVjdCAmJlxuICAgIFwicGFyYW1ldGVyc1wiIGluIG9iamVjdCAmJlxuICAgIFwicmVzcG9uc2VzXCIgaW4gb2JqZWN0ICYmXG4gICAgXCJzZWN1cml0eVwiIGluIG9iamVjdFxuICApO1xufTtcbmNvbnN0IHJlc29sdmVSZWYgPSA8VD4oXG4gIHJlZlJlc29sdmVyOiBSZWZSZXNvbHZlcixcbiAgaXRlbTogVCB8IE9wZW5BUEkuUmVmZXJlbmNlT2JqZWN0LFxuKTogRXhjbHVkZTxULCBPcGVuQVBJLlJlZmVyZW5jZU9iamVjdD4gfCBUID0+IHtcbiAgaWYgKCFpdGVtIHx8IHR5cGVvZiBpdGVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgaWYgKCEoXCIkcmVmXCIgaW4gaXRlbSkpIHtcbiAgICByZXR1cm4gaXRlbSBhcyBFeGNsdWRlPFQsIE9wZW5BUEkuUmVmZXJlbmNlT2JqZWN0PjtcbiAgfVxuICBpZiAodHlwZW9mIGl0ZW1bXCIkcmVmXCJdICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVycm9ycy5Ob3RSZXNvbHZhYmxlUmVmKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZFBhdGhJdGVtID0gcmVmUmVzb2x2ZXIuZ2V0RGVyZWZTY2hlbWEoaXRlbVtcIiRyZWZcIl0pO1xuICBpZiAoIXJlc29sdmVkUGF0aEl0ZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRXJyb3JzLk5vdFJlc29sdmFibGVSZWYpO1xuICB9XG4gIHJldHVybiByZXNvbHZlZFBhdGhJdGVtIGFzIEV4Y2x1ZGU8VCwgT3BlbkFQSS5SZWZlcmVuY2VPYmplY3Q+O1xufTtcblxuY29uc3QgaXNSZXF1ZXN0Qm9keSA9IChvYmplY3Q6IHVua25vd24pOiBvYmplY3QgaXMgT3BlbkFQSS5SZXF1ZXN0Qm9keU9iamVjdCA9PiB7XG4gIHJldHVybiAoXG4gICAgISFvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmXG4gICAgXCJjb250ZW50XCIgaW4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdC5jb250ZW50ID09PSBcIm9iamVjdFwiICYmXG4gICAgb2JqZWN0LmNvbnRlbnQgIT09IG51bGxcbiAgKTtcbn07XG5cbmNvbnN0IGdldFRvb2xzRnJvbU9wZW5BcGkgPSAoXG4gIHJlZlJlc29sdmVyOiBSZWZSZXNvbHZlcixcbiAgb3BlbkFwaUNvbnRlbnQ6IERlZXBQYXJ0aWFsPE9wZW5BUEkuRG9jdW1lbnQ+LFxuKTogW01jcFNlcnZlckNyZWF0ZVtcInNlcnZlclwiXVtcImZvbGRlcnNcIl0sIE1jcFNlcnZlckNyZWF0ZVtcImZhaWxlZFRvb2xzXCJdXSA9PiB7XG4gIGNvbnN0IGZvbGRlcnM6IE1jcFNlcnZlckNyZWF0ZVtcInNlcnZlclwiXVtcImZvbGRlcnNcIl0gPSB7fTtcbiAgY29uc3QgZmFpbGVkVG9vbHM6IHsgdG9vbE5hbWU6IHN0cmluZzsgZXJyb3I6IHN0cmluZyB9W10gPSBbXTtcblxuICBpZiAoIW9wZW5BcGlDb250ZW50LnBhdGhzKSB7XG4gICAgcmV0dXJuIFtmb2xkZXJzLCBmYWlsZWRUb29sc107XG4gIH1cblxuICAvLyBwYXRoOiAvcGV0L3tpZH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBmb3IgKGxldCBbcGF0aCwgX3BhdGhPYmplY3RdIG9mIE9iamVjdC5lbnRyaWVzKG9wZW5BcGlDb250ZW50W1wicGF0aHNcIl0pIGFzIEVudHJpZXM8XG4gICAgRGVlcFBhcnRpYWw8T3BlbkFQSS5Eb2N1bWVudFtcInBhdGhzXCJdPlxuICA+KSB7XG4gICAgY29uc3QgcGF0aE9iamVjdCA9IHJlc29sdmVSZWYocmVmUmVzb2x2ZXIsIF9wYXRoT2JqZWN0KTtcbiAgICBpZiAoIXBhdGhPYmplY3QpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIF9vcGVyYXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKHBhdGhPYmplY3QpIGFzIEVudHJpZXM8dHlwZW9mIHBhdGhPYmplY3Q+KSB7XG4gICAgICBpZiAoIWlzSHR0cE1ldGhvZChtZXRob2QpIHx8ICFpc09wZXJhdGlvbk9iamVjdChfb3BlcmF0aW9uKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHJlc29sdmVSZWYocmVmUmVzb2x2ZXIsIF9vcGVyYXRpb24pO1xuICAgICAgY29uc3QgbWV0aG9kU3RyID0gU3RyaW5nKG1ldGhvZCk7XG4gICAgICBjb25zdCBmb2xkZXJOYW1lOiBzdHJpbmcgPSBvcGVyYXRpb24udGFncz8uWzBdIHx8IFwidW5rbm93blwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBnZXRUb29sTmFtZShTdHJpbmcocGF0aCksIG1ldGhvZCwgb3BlcmF0aW9uKTtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IG9wZXJhdGlvbi5zdW1tYXJ5IHx8IG9wZXJhdGlvbi5kZXNjcmlwdGlvbiB8fCBgJHttZXRob2RTdHIudG9VcHBlckNhc2UoKX0gJHtwYXRofWA7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBwYXJhbWV0ZXJzXG5cbiAgICAgICAgY29uc3QgcGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgT3BlbkFQSS5PcGVuQVBJVjMgfCBPcGVuQVBJLlJlcXVlc3RCb2R5T2JqZWN0PiA9XG4gICAgICAgICAgcmVzb2x2ZVJlZihyZWZSZXNvbHZlciwgb3BlcmF0aW9uLnBhcmFtZXRlcnMpID8/IE9iamVjdCgpO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgcmVxdWVzdCBib2R5IGZvciBPcGVuQVBJIDMueFxuICAgICAgICBpZiAoXCJyZXF1ZXN0Qm9keVwiIGluIG9wZXJhdGlvbiAmJiBpc1JlcXVlc3RCb2R5KG9wZXJhdGlvbltcInJlcXVlc3RCb2R5XCJdKSkge1xuICAgICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gcmVzb2x2ZVJlZihyZWZSZXNvbHZlciwgb3BlcmF0aW9uW1wicmVxdWVzdEJvZHlcIl0pO1xuICAgICAgICAgIGlmIChyZXF1ZXN0Qm9keSkge1xuICAgICAgICAgICAgcGFyYW1ldGVyc1tcInJlcXVlc3RCb2R5XCJdID0gcmVxdWVzdEJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmFjdCByZXNwb25zZXNcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gcmVzb2x2ZVJlZihyZWZSZXNvbHZlciwgb3BlcmF0aW9uLnJlc3BvbnNlcyk7XG4gICAgICAgIGlmICghKGZvbGRlck5hbWUgaW4gZm9sZGVycykpIHtcbiAgICAgICAgICBmb2xkZXJzW2ZvbGRlck5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9sZGVyc1tmb2xkZXJOYW1lXS5wdXNoKHtcbiAgICAgICAgICBuYW1lOiB0b29sTmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZFN0ci50b1VwcGVyQ2FzZSgpIGFzIEh0dHBNZXRob2QsXG4gICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMgYXMgdW5rbm93biBhcyBQcmlzbWEuSW5wdXRKc29uT2JqZWN0LFxuICAgICAgICAgIHJlc3BvbnNlczogcmVzcG9uc2VzIGFzIFByaXNtYS5JbnB1dEpzb25PYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kU3RyID0gU3RyaW5nKG1ldGhvZCk7XG5cbiAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBvcGVyYXRpb24/Lm9wZXJhdGlvbklkIHx8IGAke21ldGhvZFN0ci50b1VwcGVyQ2FzZSgpfSAke3BhdGh9YDtcbiAgICAgICAgZmFpbGVkVG9vbHMucHVzaCh7XG4gICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yIHByb2Nlc3NpbmcgdG9vbFwiLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2ZvbGRlcnMsIGZhaWxlZFRvb2xzXTtcbn07XG5cbmNvbnN0IGdldEF1dGhQcm92aWRlckZyb21PcGVuQXBpID0gKFxuICByZWZSZXNvbHZlcjogUmVmUmVzb2x2ZXIsXG4gIG9wZW5BcGlDb250ZW50OiBEZWVwUGFydGlhbDxPcGVuQVBJLkRvY3VtZW50Pixcbik6IE1jcFNlcnZlckNyZWF0ZVtcInNlcnZlclwiXVtcImF1dGhQcm92aWRlclwiXSA9PiB7XG4gIGNvbnN0IHNlY3VyaXR5U2NoZW1lcyA9IGdldFNlY3VyaXR5U2NoZW1lc0Zyb21PcGVuQXBpKHJlZlJlc29sdmVyLCBvcGVuQXBpQ29udGVudCk7XG5cbiAgLy8gRXh0cmFjdCBPQXV0aCBVUkxzIGZyb20gc2VjdXJpdHkgc2NoZW1lc1xuICBsZXQgYXV0aG9yaXphdGlvblVybCA9IFwiXCI7XG4gIGxldCB0b2tlblVybCA9IFwiXCI7XG4gIGxldCBzY29wZXM6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKFwiZmxvd3NcIiBpbiBzZWN1cml0eVNjaGVtZXMgJiYgc2VjdXJpdHlTY2hlbWVzLmZsb3dzKSB7XG4gICAgY29uc3QgZmxvdyA9XG4gICAgICBzZWN1cml0eVNjaGVtZXMuZmxvd3MuYXV0aG9yaXphdGlvbkNvZGUgfHxcbiAgICAgIHNlY3VyaXR5U2NoZW1lcy5mbG93cy5pbXBsaWNpdCB8fFxuICAgICAgc2VjdXJpdHlTY2hlbWVzLmZsb3dzLnBhc3N3b3JkIHx8XG4gICAgICBzZWN1cml0eVNjaGVtZXMuZmxvd3MuY2xpZW50Q3JlZGVudGlhbHM7XG5cbiAgICBpZiAoZmxvdykge1xuICAgICAgYXV0aG9yaXphdGlvblVybCA9IFwiYXV0aG9yaXphdGlvblVybFwiIGluIGZsb3cgPyBmbG93LmF1dGhvcml6YXRpb25VcmwgOiBcIlwiO1xuICAgICAgdG9rZW5VcmwgPSBcInRva2VuVXJsXCIgaW4gZmxvdyA/IGZsb3cudG9rZW5VcmwgOiBcIlwiO1xuICAgICAgc2NvcGVzID0gZmxvdy5zY29wZXMgPyBPYmplY3Qua2V5cyhmbG93LnNjb3BlcykgOiBbXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJhdXRob3JpemF0aW9uVXJsXCIgaW4gc2VjdXJpdHlTY2hlbWVzICYmIFwidG9rZW5VcmxcIiBpbiBzZWN1cml0eVNjaGVtZXMpIHtcbiAgICAvLyBPcGVuQVBJIDIuMCBmb3JtYXRcbiAgICBhdXRob3JpemF0aW9uVXJsID0gc2VjdXJpdHlTY2hlbWVzLmF1dGhvcml6YXRpb25VcmwgfHwgXCJcIjtcbiAgICB0b2tlblVybCA9IHNlY3VyaXR5U2NoZW1lcy50b2tlblVybCB8fCBcIlwiO1xuICAgIHNjb3BlcyA9IHNlY3VyaXR5U2NoZW1lcy5zY29wZXMgPyBPYmplY3Qua2V5cyhzZWN1cml0eVNjaGVtZXMuc2NvcGVzKSA6IFtdO1xuICB9XG5cbiAgY29uc3QgYXV0aFByb3ZpZGVyOiBNY3BTZXJ2ZXJDcmVhdGVbXCJzZXJ2ZXJcIl1bXCJhdXRoUHJvdmlkZXJcIl0gPSB7XG4gICAgbmFtZTogXCJPQXV0aCAyLjBcIixcbiAgICBjbGllbnRJZDogXCJcIixcbiAgICBjbGllbnRTZWNyZXQ6IFwiXCIsXG4gICAgYXV0aG9yaXphdGlvblVybCxcbiAgICB0b2tlblVybCxcbiAgICBzY29wZXMsXG4gIH07XG4gIHJldHVybiBhdXRoUHJvdmlkZXI7XG59O1xuXG5pbnRlcmZhY2UgTWNwU2VydmVyQ3JlYXRlIHtcbiAgc2VydmVyOiB7XG4gICAgc2VydmVyOiBPbWl0PFByaXNtYS5NY3BTZXJ2ZXJDcmVhdGVJbnB1dCwgXCJ0ZW5hbnRcIj47XG4gICAgZm9sZGVyczogUmVjb3JkPHN0cmluZywgT21pdDxQcmlzbWEuVG9vbENyZWF0ZUlucHV0LCBcInRlbmFudFwiIHwgXCJzZXJ2ZXJcIj5bXT47XG4gICAgYXV0aFByb3ZpZGVyOiBPbWl0PFByaXNtYS5PQXV0aFByb3ZpZGVyQ3JlYXRlSW5wdXQsIFwidGVuYW50XCIgfCBcInNlcnZlclwiPjtcbiAgfTtcbiAgZmFpbGVkVG9vbHM6IHtcbiAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgIGVycm9yOiBzdHJpbmc7XG4gIH1bXTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldE1jcFNlcnZlckZyb21PcGVuQXBpID0gKG9wZW5BcGlDb250ZW50OiBEZWVwUGFydGlhbDxPcGVuQVBJLkRvY3VtZW50Pik6IE1jcFNlcnZlckNyZWF0ZSA9PiB7XG4gIC8vICNyZWdpb246IHNldHVwXG4gIGNvbnN0IHJlZlJlc29sdmVyID0gbmV3IFJlZlJlc29sdmVyKCk7XG4gIHJlZlJlc29sdmVyLmFkZFNjaGVtYShvcGVuQXBpQ29udGVudCk7XG4gIHZhbGlkYXRlT3BlbkFwaUNvbnRlbnQocmVmUmVzb2x2ZXIsIG9wZW5BcGlDb250ZW50KTtcbiAgY29uc3Qgc2VydmVyOiBNY3BTZXJ2ZXJDcmVhdGVbXCJzZXJ2ZXJcIl1bXCJzZXJ2ZXJcIl0gPSB7XG4gICAgbmFtZTogb3BlbkFwaUNvbnRlbnQuaW5mby50aXRsZSxcbiAgICBiYXNlVXJsOiBnZXRTZXJ2ZXJVcmxGcm9tT3BlbkFwaShvcGVuQXBpQ29udGVudCksXG4gICAgZGVzY3JpcHRpb246IG9wZW5BcGlDb250ZW50LmluZm8/LmRlc2NyaXB0aW9uLFxuICB9O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgY29uc3QgYXV0aFByb3ZpZGVyID0gZ2V0QXV0aFByb3ZpZGVyRnJvbU9wZW5BcGkocmVmUmVzb2x2ZXIsIG9wZW5BcGlDb250ZW50KTtcblxuICBjb25zdCBbZm9sZGVycywgZmFpbGVkVG9vbHNdID0gZ2V0VG9vbHNGcm9tT3BlbkFwaShyZWZSZXNvbHZlciwgb3BlbkFwaUNvbnRlbnQpO1xuXG4gIHJldHVybiB7XG4gICAgc2VydmVyOiB7XG4gICAgICBzZXJ2ZXIsXG4gICAgICBmb2xkZXJzOiBmb2xkZXJzLFxuICAgICAgYXV0aFByb3ZpZGVyLFxuICAgIH0sXG4gICAgZmFpbGVkVG9vbHMsXG4gIH07XG59O1xuIiwgIi8qKlxuICogQ2VudHJhbGl6ZWQgYW5hbHl0aWNzIGV2ZW50IG5hbWVzIGZvbGxvd2luZyB0aGUgcGF0dGVybjogPGVudGl0eT4uPGFjdGlvbj4uPHN0YXR1cz5cbiAqL1xuXG5leHBvcnQgY29uc3QgQW5hbHl0aWNzRXZlbnRzID0ge1xuICAvLyBBdXRoZW50aWNhdGlvbiAmIEF1dGhvcml6YXRpb24gRXZlbnRzXG4gIEFETUlOX0xPR0lOX0FUVEVNUFRFRDogXCJhZG1pbi5sb2dpbi5hdHRlbXB0ZWRcIixcbiAgQURNSU5fTE9HSU5fU1VDQ0VTUzogXCJhZG1pbi5sb2dpbi5zdWNjZXNzXCIsXG4gIEFETUlOX0xPR0lOX0ZBSUxFRDogXCJhZG1pbi5sb2dpbi5mYWlsZWRcIixcbiAgQURNSU5fTE9HT1VUX0NPTVBMRVRFRDogXCJhZG1pbi5sb2dvdXQuY29tcGxldGVkXCIsXG4gIEFETUlOX1NFU1NJT05fU1RBUlRFRDogXCJhZG1pbi5zZXNzaW9uLnN0YXJ0ZWRcIixcbiAgQURNSU5fQUNDT1VOVF9BQ1RJVkFURUQ6IFwiYWRtaW4uYWNjb3VudC5hY3RpdmF0ZWRcIixcbiAgQURNSU5fUEVSTUlTU0lPTl9ERU5JRUQ6IFwiYWRtaW4ucGVybWlzc2lvbi5kZW5pZWRcIixcblxuICAvLyBXYWl0bGlzdCBNYW5hZ2VtZW50IEV2ZW50c1xuICBXQUlUTElTVF9TSUdOVVBfU1VCTUlUVEVEOiBcIndhaXRsaXN0LnNpZ251cC5zdWJtaXR0ZWRcIixcblxuICAvLyBNQ1AgU2VydmVyIE1hbmFnZW1lbnQgRXZlbnRzXG4gIE1DUF9TRVJWRVJfQ1JFQVRFX0NPTVBMRVRFRDogXCJtY3Auc2VydmVyLmNyZWF0ZS5jb21wbGV0ZWRcIixcbiAgTUNQX1NFUlZFUl9DUkVBVEVfRkFJTEVEOiBcIm1jcC5zZXJ2ZXIuY3JlYXRlLmZhaWxlZFwiLFxuXG4gIC8vIFRvb2wgTWFuYWdlbWVudCBFdmVudHNcbiAgTUNQX1RPT0xfQ1JFQVRFX0NPTVBMRVRFRDogXCJtY3AudG9vbC5jcmVhdGUuY29tcGxldGVkXCIsXG4gIE1DUF9UT09MX1VQREFURV9DT01QTEVURUQ6IFwibWNwLnRvb2wudXBkYXRlLmNvbXBsZXRlZFwiLFxuXG4gIC8vIFRvb2wgRXhlY3V0aW9uIEV2ZW50c1xuICBNQ1BfVE9PTF9FWEVDVVRJT05fQVBJX0NBTEw6IFwibWNwLnRvb2wuZXhlY3V0aW9uLmFwaV9jYWxsXCIsXG4gIE1DUF9UT09MX1BMQVlHUk9VTkRfT1BFTkVEOiBcIm1jcC50b29sLnBsYXlncm91bmQub3BlbmVkXCIsXG5cbiAgLy8gQW5hbHl0aWNzIFZpZXcgRXZlbnRzXG4gIE1DUF9BTkFMWVRJQ1NfVklFV0VEOiBcIm1jcC5hbmFseXRpY3Mudmlld2VkXCIsXG5cbiAgLy8gVGVuYW50IE1hbmFnZW1lbnQgRXZlbnRzXG4gIFRFTkFOVF9JTlZJVEFUSU9OX1NFTlQ6IFwidGVuYW50Lmludml0YXRpb24uc2VudFwiLFxuICBURU5BTlRfSU5WSVRBVElPTl9BQ0NFUFRFRDogXCJ0ZW5hbnQuaW52aXRhdGlvbi5hY2NlcHRlZFwiLFxuICBURU5BTlRfSU5WSVRBVElPTl9DQU5DRUxMRUQ6IFwidGVuYW50Lmludml0YXRpb24uY2FuY2VsbGVkXCIsXG4gIFRFTkFOVF9VU0VSX1JFTU9WRUQ6IFwidGVuYW50LnVzZXIucmVtb3ZlZFwiLFxuXG4gIC8vIE9BdXRoIFByb3ZpZGVyIEV2ZW50c1xuICBPQVVUSF9QUk9WSURFUl9DUkVBVEVEOiBcIm9hdXRoLnByb3ZpZGVyLmNyZWF0ZWRcIixcbiAgT0FVVEhfRkxPV19TVEFSVEVEOiBcIm9hdXRoLmZsb3cuc3RhcnRlZFwiLFxuICBPQVVUSF9GTE9XX0NPTVBMRVRFRDogXCJvYXV0aC5mbG93LmNvbXBsZXRlZFwiLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgQW5hbHl0aWNzRXZlbnROYW1lID0gKHR5cGVvZiBBbmFseXRpY3NFdmVudHMpW2tleW9mIHR5cGVvZiBBbmFseXRpY3NFdmVudHNdO1xuIiwgImltcG9ydCB7IEFuYWx5dGljc0V2ZW50cyB9IGZyb20gXCJAYWdlbnRicmlkZ2UvdXRpbHNcIjtcbmltcG9ydCB7IFBvc3RIb2cgfSBmcm9tIFwicG9zdGhvZy1ub2RlXCI7XG5cbmludGVyZmFjZSBCYXNlRXZlbnRQcm9wZXJ0aWVzIHtcbiAgdXNlcl9pZD86IHN0cmluZztcbiAgdGVuYW50X2lkPzogc3RyaW5nO1xuICBzZXNzaW9uX2lkPzogc3RyaW5nO1xuICB0aW1lc3RhbXA/OiBzdHJpbmc7XG4gIHNvdXJjZT86IFwiZnJvbnRlbmRcIiB8IFwiYmFja2VuZFwiO1xufVxuXG5jbGFzcyBBbmFseXRpY3NTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBwb3N0aG9nOiBQb3N0SG9nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucG9zdGhvZyA9IG5ldyBQb3N0SG9nKFwicGhjX1JXTnpnYVFmdUJlZ2F4dFdWVDZRR01YSkY1b2lybGRQTGRPUDF1RFZIdEpcIiwge1xuICAgICAgaG9zdDogXCJodHRwczovL2FwcC5wb3N0aG9nLmNvbVwiLFxuICAgIH0pO1xuICB9XG5cbiAgdHJhY2soZGlzdGluY3RJZDogc3RyaW5nLCBldmVudDogc3RyaW5nLCBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiAmIEJhc2VFdmVudFByb3BlcnRpZXMgPSB7fSkge1xuICAgIHRoaXMucG9zdGhvZy5jYXB0dXJlKHtcbiAgICAgIGRpc3RpbmN0SWQsXG4gICAgICBldmVudCxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLi4ucHJvcGVydGllcyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHNvdXJjZTogXCJiYWNrZW5kXCIsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWRlbnRpZnkoZGlzdGluY3RJZDogc3RyaW5nLCBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIHRoaXMucG9zdGhvZy5pZGVudGlmeSh7XG4gICAgICBkaXN0aW5jdElkLFxuICAgICAgcHJvcGVydGllcyxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNodXRkb3duKCkge1xuICAgIGF3YWl0IHRoaXMucG9zdGhvZy5zaHV0ZG93bigpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBhbmFseXRpY3MgPSBuZXcgQW5hbHl0aWNzU2VydmljZSgpO1xuZXhwb3J0IHsgQW5hbHl0aWNzRXZlbnRzIH07XG4iLCAiaW1wb3J0IHsgQWRtaW4gfSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcbmltcG9ydCBub2RlbWFpbGVyIGZyb20gXCJub2RlbWFpbGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwid2luc3RvblwiO1xuaW1wb3J0IHtcbiAgZ2V0QWRtaW5BcHByb3ZhbEVtYWlsVGVtcGxhdGUsXG4gIGdldEFkbWluQXBwcm92ZWRFbWFpbFRlbXBsYXRlLFxuICBnZXRFYXN0ZXJFZ2dXZWxjb21lRW1haWxUZW1wbGF0ZSxcbiAgZ2V0VGVuYW50SW52aXRhdGlvbkVtYWlsVGVtcGxhdGUsXG59IGZyb20gXCIuL2VtYWlsLnNlcnZpY2UudGVtcGxhdGVzLmpzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUFkbWluVmVyaWZpY2F0aW9uVG9rZW4gfSBmcm9tIFwiLi9qd3Quc2VydmljZS5qc1wiO1xuaW1wb3J0IHsgZ2V0QXBwU2VjcmV0cyB9IGZyb20gXCIuL3NlY3JldHMuc2VydmljZS5qc1wiO1xuXG5jb25zdCBub3RpZmljYXRpb25FbWFpbCA9IHByb2Nlc3MuZW52LldBSVRMSVNUX05PVElGSUNBVElPTl9FTUFJTDtcbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52LkVOViB8fCBcImRldlwiO1xuY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52LkNPTlNPTEVfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo0MjAwXCI7XG5jb25zdCBzbXRwUG9ydCA9IHByb2Nlc3MuZW52LlNNVFBfUE9SVCB8fCBcIjQ1NlwiO1xuXG5leHBvcnQgY29uc3Qgc2VuZEFkZFRvV2FpdGxpc3RFbWFpbCA9IGFzeW5jIChsb2dnZXI6IExvZ2dlciwgcGVuZGluZ0FkbWluOiBBZG1pbikgPT4ge1xuICBpZiAoIW5vdGlmaWNhdGlvbkVtYWlsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCB0cmFuc3BvcnRlciA9IGF3YWl0IGNyZWF0ZVRyYW5zcG9ydGVyKCk7XG5cbiAgbG9nZ2VyLmRlYnVnKFwiU2VuZGluZyBhZG1pbiBhcHByb3ZhbCByZXF1ZXN0IGVtYWlsXCIsIHtcbiAgICB0YXJnZXRFbWFpbDogbm90aWZpY2F0aW9uRW1haWwsXG4gICAgYWRtaW5FbWFpbDogcGVuZGluZ0FkbWluLmVtYWlsLFxuICB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCB2ZXJpZmljYXRpb25Ub2tlbiA9IGF3YWl0IGdlbmVyYXRlQWRtaW5WZXJpZmljYXRpb25Ub2tlbihwZW5kaW5nQWRtaW4uaWQpO1xuICAgIGNvbnN0IHZlcmlmaWNhdGlvbkxpbmsgPSBgJHtiYXNlVXJsfS92ZXJpZnktYWRtaW4/dG9rZW49JHt2ZXJpZmljYXRpb25Ub2tlbn1gO1xuXG4gICAgYXdhaXQgdHJhbnNwb3J0ZXIuc2VuZE1haWwoe1xuICAgICAgZnJvbTogYGFnZW50cGFzcy0ke2Vudn1Ab3duaWQuY29tYCxcbiAgICAgIHRvOiBub3RpZmljYXRpb25FbWFpbCxcbiAgICAgIHN1YmplY3Q6IGBBZ2VudFBhc3MgJHtlbnZ9OiBOZXcgQWRtaW4gQXBwcm92YWwgUmVxdWlyZWRgLFxuICAgICAgaHRtbDogZ2V0QWRtaW5BcHByb3ZhbEVtYWlsVGVtcGxhdGUocGVuZGluZ0FkbWluLmVtYWlsLCB2ZXJpZmljYXRpb25MaW5rKSxcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gc2VuZCBhZG1pbiBhcHByb3ZhbCByZXF1ZXN0IGVtYWlsXCIsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzZW5kQWRtaW5BcHByb3ZlZE5vdGlmaWNhdGlvbiA9IGFzeW5jIChsb2dnZXI6IExvZ2dlciwgYWRtaW46IEFkbWluLCBpc0Vhc3RlckVnZyA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IHRyYW5zcG9ydGVyID0gYXdhaXQgY3JlYXRlVHJhbnNwb3J0ZXIoKTtcblxuICBsb2dnZXIuZGVidWcoXCJTZW5kaW5nIGFkbWluIGFwcHJvdmVkIG5vdGlmaWNhdGlvbiBlbWFpbFwiLCB7XG4gICAgYWRtaW5FbWFpbDogYWRtaW4uZW1haWwsXG4gICAgaXNFYXN0ZXJFZ2csXG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgdHJhbnNwb3J0ZXIuc2VuZE1haWwoe1xuICAgICAgZnJvbTogYGFnZW50cGFzcy0ke2Vudn1Ab3duaWQuY29tYCxcbiAgICAgIHRvOiBhZG1pbi5lbWFpbCxcbiAgICAgIHN1YmplY3Q6IGlzRWFzdGVyRWdnID8gYFx1RDgzRFx1REU4MCBXZWxjb21lIHRvIEFnZW50UGFzcyAtIFJvY2tldCBMYXVuY2ggRGV0ZWN0ZWQhYCA6IGBZb3UncmUgaW4hIFdlbGNvbWUgdG8gQWdlbnRQYXNzYCxcbiAgICAgIGh0bWw6IGlzRWFzdGVyRWdnID8gZ2V0RWFzdGVyRWdnV2VsY29tZUVtYWlsVGVtcGxhdGUoYmFzZVVybCkgOiBnZXRBZG1pbkFwcHJvdmVkRW1haWxUZW1wbGF0ZShiYXNlVXJsKSxcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gc2VuZCBhZG1pbiBhcHByb3ZlZCBub3RpZmljYXRpb24gZW1haWxcIiwgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRWFzdGVyIGVnZyB3ZWxjb21lIGVtYWlsIGlzIG5vdyBoYW5kbGVkIGJ5IHNlbmRBZG1pbkFwcHJvdmVkTm90aWZpY2F0aW9uIHdpdGggaXNFYXN0ZXJFZ2c9dHJ1ZVxuXG5leHBvcnQgY29uc3Qgc2VuZFRlbmFudEludml0YXRpb25FbWFpbCA9IGFzeW5jIChcbiAgbG9nZ2VyOiBMb2dnZXIsXG4gIHRvOiBzdHJpbmcsXG4gIGludml0ZXI6IHN0cmluZyxcbiAgdGVuYW50TmFtZTogc3RyaW5nLFxuICBpbnZpdGF0aW9uTGluazogc3RyaW5nLFxuICByb2xlOiBzdHJpbmcsXG4gIGV4cGlyZXNBdDogRGF0ZSxcbikgPT4ge1xuICBjb25zdCB0cmFuc3BvcnRlciA9IGF3YWl0IGNyZWF0ZVRyYW5zcG9ydGVyKCk7XG5cbiAgbG9nZ2VyLmRlYnVnKFwiU2VuZGluZyB0ZW5hbnQgaW52aXRhdGlvbiBlbWFpbFwiLCB7XG4gICAgdG8sXG4gICAgaW52aXRlcixcbiAgICB0ZW5hbnROYW1lLFxuICAgIGludml0YXRpb25MaW5rLFxuICAgIHJvbGUsXG4gICAgZXhwaXJlc0F0LFxuICB9KTtcblxuICB0cnkge1xuICAgIGF3YWl0IHRyYW5zcG9ydGVyLnNlbmRNYWlsKHtcbiAgICAgIGZyb206IGBhZ2VudHBhc3MtJHtlbnZ9QG93bmlkLmNvbWAsXG4gICAgICB0byxcbiAgICAgIHN1YmplY3Q6IGBZb3UncmUgaW52aXRlZCB0byBqb2luICR7dGVuYW50TmFtZX0gb24gQWdlbnRQYXNzYCxcbiAgICAgIGh0bWw6IGdldFRlbmFudEludml0YXRpb25FbWFpbFRlbXBsYXRlKGludml0ZXIsIHRlbmFudE5hbWUsIHJvbGUsIGludml0YXRpb25MaW5rLCBleHBpcmVzQXQpLFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBzZW5kIHRlbmFudCBpbnZpdGF0aW9uIGVtYWlsXCIsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVRyYW5zcG9ydGVyID0gYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhcHBTZWNyZXRzID0gYXdhaXQgZ2V0QXBwU2VjcmV0cygpO1xuICByZXR1cm4gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQoe1xuICAgIGhvc3Q6IGFwcFNlY3JldHMuc210cEhvc3QsXG4gICAgcG9ydDogTnVtYmVyKGFwcFNlY3JldHMuc210cFBvcnQpLFxuICAgIHNlY3VyZTogYXBwU2VjcmV0cy5zbXRwUG9ydCA9PT0gc210cFBvcnQsXG4gICAgYXV0aDoge1xuICAgICAgdXNlcjogYXBwU2VjcmV0cy5zbXRwVXNlcm5hbWUsXG4gICAgICBwYXNzOiBhcHBTZWNyZXRzLnNtdHBQYXNzd29yZCxcbiAgICB9LFxuICB9KTtcbn07XG4iLCAiZXhwb3J0IGNvbnN0IGdldEFkbWluQXBwcm92YWxFbWFpbFRlbXBsYXRlID0gKGFkbWluRW1haWw6IHN0cmluZywgdmVyaWZpY2F0aW9uTGluazogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGA8IWRvY3R5cGUgaHRtbD5cbiAgPGh0bWwgbGFuZz1cImVuXCI+XG4gICAgPGJvZHkgc3R5bGU9XCJtYXJnaW46IDA7IHBhZGRpbmc6IDA7IGJhY2tncm91bmQtY29sb3I6ICMxNzFlMjk7IGZvbnQtZmFtaWx5OiBBcmlhbCwgJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOyBjb2xvcjogI2Y4ZjlmYjtcIj5cbiAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBib3JkZXI9XCIwXCIgd2lkdGg9XCIxMDAlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjMTcxZTI5OyBwYWRkaW5nOiA0MHB4IDBcIj5cbiAgICAgICAgPHRyPlxuICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiPlxuICAgICAgICAgICAgPHRhYmxlIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIGJvcmRlcj1cIjBcIiB3aWR0aD1cIjEwMCVcIiBzdHlsZT1cIm1heC13aWR0aDogNjAwcHg7IGJhY2tncm91bmQtY29sb3I6ICMxZjI5Mzc7IHBhZGRpbmc6IDQwcHg7IGJvcmRlci1yYWRpdXM6IDhweDsgYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yKTtcIj5cbiAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgIDx0ZCBzdHlsZT1cInBhZGRpbmc6IDMycHggMDsgdGV4dC1hbGlnbjogY2VudGVyOyBmb250LXNpemU6IDE4cHhcIj5cbiAgICAgICAgICAgICAgICAgIEEgbmV3IGFkbWluIGhhcyByZXF1ZXN0ZWQgYWNjZXNzOjxici8+XG4gICAgICAgICAgICAgICAgICA8c3Ryb25nIHN0eWxlPVwiY29sb3I6ICMyMjc2ZmNcIj4ke2FkbWluRW1haWx9PC9zdHJvbmc+PGJyLz48YnIvPlxuICAgICAgICAgICAgICAgICAgQ2xpY2sgdGhlIGJ1dHRvbiBiZWxvdyB0byBhcHByb3ZlIHRoZWlyIGFjY2VzczpcbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRkIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBwYWRkaW5nLWJvdHRvbTogMzJweFwiPlxuICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIiR7dmVyaWZpY2F0aW9uTGlua31cIiBzdHlsZT1cImJhY2tncm91bmQ6ICMyMjc2ZmM7IGNvbG9yOiAjRkZGRkZGOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHBhZGRpbmc6IDEycHggMzJweDsgdGV4dC1hbGlnbjogY2VudGVyOyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IGJvcmRlci1yYWRpdXM6IDRweDsgZm9udC13ZWlnaHQ6IGJvbGQ7XCI+QXBwcm92ZSBBZG1pbjwvYT5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRkIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBmb250LXNpemU6IDE0cHg7IGNvbG9yOiAjYTdiMGJkXCI+XG4gICAgICAgICAgICAgICAgICBJZiB5b3UgZGlkIG5vdCBleHBlY3QgdGhpcyByZXF1ZXN0LCB5b3UgY2FuIHNhZmVseSBpZ25vcmUgdGhpcyBtZXNzYWdlLlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgICA8L3RhYmxlPlxuICAgIDwvYm9keT5cbiAgPC9odG1sPmA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QWRtaW5BcHByb3ZlZEVtYWlsVGVtcGxhdGUgPSAoYXBwTGluazogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGA8IWRvY3R5cGUgaHRtbD5cbiAgPGh0bWwgbGFuZz1cImVuXCI+XG4gICAgPGJvZHkgc3R5bGU9XCJtYXJnaW46IDA7IHBhZGRpbmc6IDA7IGJhY2tncm91bmQtY29sb3I6ICMxNzFlMjk7IGZvbnQtZmFtaWx5OiBBcmlhbCwgJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOyBjb2xvcjogI2Y4ZjlmYjtcIj5cbiAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBib3JkZXI9XCIwXCIgd2lkdGg9XCIxMDAlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjMTcxZTI5OyBwYWRkaW5nOiA0MHB4IDBcIj5cbiAgICAgICAgPHRyPlxuICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiPlxuICAgICAgICAgICAgPHRhYmxlIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIGJvcmRlcj1cIjBcIiB3aWR0aD1cIjEwMCVcIiBzdHlsZT1cIm1heC13aWR0aDogNjAwcHg7IGJhY2tncm91bmQtY29sb3I6ICMxZjI5Mzc7IHBhZGRpbmc6IDQwcHg7IGJvcmRlci1yYWRpdXM6IDhweDsgYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yKTtcIj5cbiAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgIDx0ZCBzdHlsZT1cInBhZGRpbmc6IDE2cHggMDsgdGV4dC1hbGlnbjogY2VudGVyOyBmb250LXNpemU6IDE2cHg7IGNvbG9yOiAjZjhmOWZiO1wiPlxuICAgICAgICAgICAgICAgICAgR3JlYXQgbmV3cyEgWW91ciBhY2NvdW50IGhhcyBiZWVuIGFwcHJvdmVkIGFuZCB5b3UncmUgbm93IHJlYWR5IHRvIHN0YXJ0IHVzaW5nIEFnZW50UGFzcy48YnIvPjxici8+XG4gICAgICAgICAgICAgICAgICBDbGljayB0aGUgYnV0dG9uIGJlbG93IHRvIGFjY2VzcyB5b3VyIGRhc2hib2FyZCBhbmQgc3RhcnQgZXhwbG9yaW5nOlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICA8dGQgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7XCI+XG4gICAgICAgICAgICAgICAgICA8YSBocmVmPVwiJHthcHBMaW5rfVwiIHN0eWxlPVwiYmFja2dyb3VuZDogIzIyNzZmYzsgY29sb3I6ICNGRkZGRkY7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgcGFkZGluZzogMTJweCAzMnB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgYm9yZGVyLXJhZGl1czogNHB4OyBmb250LXdlaWdodDogYm9sZDtcIj5HbyB0byBBZ2VudFBhc3M8L2E+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgIDx0ZCBzdHlsZT1cInBhZGRpbmc6IDE2cHggMDsgdGV4dC1hbGlnbjogY2VudGVyOyBmb250LXNpemU6IDE1cHg7IGNvbG9yOiAjZjhmOWZiO1wiPlxuICAgICAgICAgICAgICAgICAgV2UncmUgZXhjaXRlZCB0byBoYXZlIHlvdSBvbmJvYXJkITxici8+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiAjYjBiN2MzO1wiPlRoZSBBZ2VudFBhc3MgVGVhbTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICA8L3RyPlxuICAgICAgPC90YWJsZT5cbiAgICA8L2JvZHk+XG4gIDwvaHRtbD5gO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEVhc3RlckVnZ1dlbGNvbWVFbWFpbFRlbXBsYXRlID0gKGFwcExpbms6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBgPCFkb2N0eXBlIGh0bWw+XG4gIDxodG1sIGxhbmc9XCJlblwiPlxuICAgIDxib2R5IHN0eWxlPVwibWFyZ2luOiAwOyBwYWRkaW5nOiAwOyBiYWNrZ3JvdW5kLWNvbG9yOiAjMTcxZTI5OyBmb250LWZhbWlseTogQXJpYWwsICdIZWx2ZXRpY2EgTmV1ZScsIEhlbHZldGljYSwgc2Fucy1zZXJpZjsgY29sb3I6ICNmOGY5ZmI7XCI+XG4gICAgICA8dGFibGUgY2VsbHBhZGRpbmc9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCIgYm9yZGVyPVwiMFwiIHdpZHRoPVwiMTAwJVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogIzE3MWUyOTsgcGFkZGluZzogNDBweCAwXCI+XG4gICAgICAgIDx0cj5cbiAgICAgICAgICA8dGQgYWxpZ249XCJjZW50ZXJcIj5cbiAgICAgICAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBib3JkZXI9XCIwXCIgd2lkdGg9XCIxMDAlXCIgc3R5bGU9XCJtYXgtd2lkdGg6IDYwMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiAjMWYyOTM3OyBwYWRkaW5nOiA0MHB4OyBib3JkZXItcmFkaXVzOiA4cHg7IGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMik7XCI+XG4gICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICA8dGQgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQtc2l6ZTogMjhweDsgZm9udC13ZWlnaHQ6IGJvbGQ7IHBhZGRpbmctYm90dG9tOiAxMHB4XCI+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiAjMjI3NmZjXCI+XHVEODNEXHVERTgwIEFnZW50UGFzcy5haTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRkIHN0eWxlPVwicGFkZGluZzogMjRweCAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQtc2l6ZTogMThweFwiPlxuICAgICAgICAgICAgICAgICAgPHN0cm9uZyBzdHlsZT1cImNvbG9yOiAjMjI3NmZjO1wiPlJvY2tldCBsYXVuY2ggZGV0ZWN0ZWQhPC9zdHJvbmc+PGJyLz48YnIvPlxuICAgICAgICAgICAgICAgICAgQ29uZ3JhdHVsYXRpb25zIG9uIGRpc2NvdmVyaW5nIG91ciBlYXN0ZXIgZWdnISBZb3VyIGN1cmlvc2l0eSBhbmQgZXhwbG9yYXRpb24gaGF2ZSBlYXJuZWQgeW91IGluc3RhbnQgYWNjZXNzIHRvIEFnZW50UGFzcy48YnIvPjxici8+XG4gICAgICAgICAgICAgICAgICBZb3VyIGFjY291bnQgaGFzIGJlZW4gYWN0aXZhdGVkIGFuZCB5b3UncmUgcmVhZHkgdG8gc3RhcnQgY29ubmVjdGluZyBBSSBhZ2VudHMgdG8gQVBJczpcbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRkIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBwYWRkaW5nLWJvdHRvbTogMzJweFwiPlxuICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cIiR7YXBwTGlua31cIiBzdHlsZT1cImJhY2tncm91bmQ6ICMyMjc2ZmM7IGNvbG9yOiAjRkZGRkZGOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHBhZGRpbmc6IDEycHggMzJweDsgdGV4dC1hbGlnbjogY2VudGVyOyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IGJvcmRlci1yYWRpdXM6IDRweDsgZm9udC13ZWlnaHQ6IGJvbGQ7XCI+XHVEODNEXHVERTgwIExhdW5jaCBpbnRvIEFnZW50UGFzczwvYT5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRkIHN0eWxlPVwicGFkZGluZzogMTZweCAwOyB0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQtc2l6ZTogMTVweDsgY29sb3I6ICNmOGY5ZmI7XCI+XG4gICAgICAgICAgICAgICAgICBUaGFua3MgZm9yIGxhdW5jaGluZyB0aGUgcm9ja2V0ISBXZSdyZSBleGNpdGVkIHRvIGhhdmUgY3VyaW91cyBleHBsb3JlcnMgbGlrZSB5b3Ugb25ib2FyZC48YnIvPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogI2IwYjdjMztcIj5UaGUgQWdlbnRQYXNzIFRlYW08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgIDx0ZCBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjsgZm9udC1zaXplOiAxM3B4OyBjb2xvcjogI2E3YjBiZDsgcGFkZGluZy10b3A6IDE2cHg7XCI+XG4gICAgICAgICAgICAgICAgICBQLlMuIEtlZXAgZXhwbG9yaW5nIC0gdGhlcmUgbWlnaHQgYmUgbW9yZSBzdXJwcmlzZXMgd2FpdGluZyEgXHVEODNDXHVERkFGXG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgPC90cj5cbiAgICAgIDwvdGFibGU+XG4gICAgPC9ib2R5PlxuICA8L2h0bWw+YDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUZW5hbnRJbnZpdGF0aW9uRW1haWxUZW1wbGF0ZSA9IChcbiAgaW52aXRlcjogc3RyaW5nLFxuICB0ZW5hbnROYW1lOiBzdHJpbmcsXG4gIHJvbGU6IHN0cmluZyxcbiAgaW52aXRhdGlvbkxpbms6IHN0cmluZyxcbiAgZXhwaXJlc0F0OiBEYXRlLFxuKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGA8IWRvY3R5cGUgaHRtbD5cbiAgPGh0bWwgbGFuZz1cImVuXCI+XG4gICAgPGJvZHkgc3R5bGU9XCJtYXJnaW46IDA7IHBhZGRpbmc6IDA7IGJhY2tncm91bmQtY29sb3I6ICMxNzFlMjk7IGZvbnQtZmFtaWx5OiBBcmlhbCwgJ0hlbHZldGljYSBOZXVlJywgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOyBjb2xvcjogI2Y4ZjlmYjtcIj5cbiAgICAgIDx0YWJsZSBjZWxscGFkZGluZz1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBib3JkZXI9XCIwXCIgd2lkdGg9XCIxMDAlXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiAjMTcxZTI5OyBwYWRkaW5nOiA0MHB4IDBcIj5cbiAgICAgICAgPHRyPlxuICAgICAgICAgIDx0ZCBhbGlnbj1cImNlbnRlclwiPlxuICAgICAgICAgICAgPHRhYmxlIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIGJvcmRlcj1cIjBcIiB3aWR0aD1cIjEwMCVcIiBzdHlsZT1cIm1heC13aWR0aDogNjAwcHg7IGJhY2tncm91bmQtY29sb3I6ICMxZjI5Mzc7IHBhZGRpbmc6IDQwcHg7IGJvcmRlci1yYWRpdXM6IDhweDsgYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4yKTtcIj5cbiAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgIDx0ZCBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjsgZm9udC1zaXplOiAyOHB4OyBmb250LXdlaWdodDogYm9sZDsgcGFkZGluZy1ib3R0b206IDEwcHhcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6ICMyMjc2ZmNcIj5BZ2VudFBhc3MuYWk8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgIDx0ZCBzdHlsZT1cInBhZGRpbmc6IDI0cHggMDsgdGV4dC1hbGlnbjogY2VudGVyOyBmb250LXNpemU6IDE4cHhcIj5cbiAgICAgICAgICAgICAgICAgIDxzdHJvbmc+JHtpbnZpdGVyfTwvc3Ryb25nPiBoYXMgaW52aXRlZCB5b3UgdG8gam9pbiB0aGUgdGVuYW50IDxzdHJvbmc+JHt0ZW5hbnROYW1lfTwvc3Ryb25nPiBhcyBhIDxzdHJvbmc+JHtyb2xlfTwvc3Ryb25nPi48YnIvPjxici8+XG4gICAgICAgICAgICAgICAgICBDbGljayB0aGUgYnV0dG9uIGJlbG93IHRvIGFjY2VwdCB5b3VyIGludml0YXRpb246XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgIDx0ZCBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjsgcGFkZGluZy1ib3R0b206IDMycHhcIj5cbiAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIke2ludml0YXRpb25MaW5rfVwiIHN0eWxlPVwiYmFja2dyb3VuZDogIzIyNzZmYzsgY29sb3I6ICNGRkZGRkY7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgcGFkZGluZzogMTJweCAzMnB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgYm9yZGVyLXJhZGl1czogNHB4OyBmb250LXdlaWdodDogYm9sZDtcIj5BY2NlcHQgSW52aXRhdGlvbjwvYT5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgPHRkIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyOyBmb250LXNpemU6IDE1cHg7IGNvbG9yOiAjYTdiMGJkXCI+XG4gICAgICAgICAgICAgICAgICBUaGlzIGludml0YXRpb24gd2lsbCBleHBpcmUgb24gPHN0cm9uZz4ke2V4cGlyZXNBdC50b0xvY2FsZURhdGVTdHJpbmcoKX08L3N0cm9uZz4uPGJyLz5cbiAgICAgICAgICAgICAgICAgIElmIHlvdSBkaWQgbm90IGV4cGVjdCB0aGlzIGludml0YXRpb24sIHlvdSBjYW4gc2FmZWx5IGlnbm9yZSB0aGlzIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgPC90cj5cbiAgICAgIDwvdGFibGU+XG4gICAgPC9ib2R5PlxuICA8L2h0bWw+YDtcbn07XG4iLCAiaW1wb3J0IHsgUm91dGVyIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7XG4gIGNoYXRTdHJlYW0sXG4gIGdlbmVyYXRlQ29tcGxldGlvbkhhbmRsZXIsXG4gIGdlbmVyYXRlT2JqZWN0SGFuZGxlcixcbiAgZ2VuZXJhdGVUZW1wbGF0ZUhhbmRsZXIsXG4gIGdldEFJQ29uZmlnLFxuICBzdHJlYW1BSUFnZW50Q2hhdEhhbmRsZXIsXG4gIHN0cmVhbUNvbXBsZXRpb25IYW5kbGVyLFxufSBmcm9tIFwiLi4vY29udHJvbGxlcnMvYWkuY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IHsgcmF0ZUxpbWl0TWlkZGxld2FyZSB9IGZyb20gXCIuLi9taWRkbGV3YXJlcy9yYXRlLWxpbWl0Lm1pZGRsZXdhcmUuanNcIjtcbmltcG9ydCB7IGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUgfSBmcm9tIFwiLi4vbWlkZGxld2FyZXMvc2Vzc2lvbi5taWRkbGV3YXJlLmpzXCI7XG5cbmNvbnN0IHJvdXRlciA9IFJvdXRlcigpO1xuXG4vLyBBcHBseSBhdXRoZW50aWNhdGlvbiBtaWRkbGV3YXJlIHRvIGFsbCBBSSByb3V0ZXNcbnJvdXRlci51c2UoYWRtaW5TZXNzaW9uTWlkZGxld2FyZSk7XG5cbi8vIEFwcGx5IHJhdGUgbGltaXRpbmcgdG8gcHJldmVudCBhYnVzZVxuY29uc3QgYWlSYXRlTGltaXQgPSByYXRlTGltaXRNaWRkbGV3YXJlKHtcbiAgd2luZG93TXM6IDYwICogMTAwMCwgLy8gMSBtaW51dGVcbiAgbWF4OiAyMCwgLy8gMjAgcmVxdWVzdHMgcGVyIG1pbnV0ZVxuICBtZXNzYWdlOiBcIlRvbyBtYW55IEFJIHJlcXVlc3RzLCBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyXCIsXG59KTtcblxuLy8gQ2hhdCBlbmRwb2ludCB3aXRoIHN0cmVhbWluZyBzdXBwb3J0XG5yb3V0ZXIucG9zdChcIi9jaGF0XCIsIGFpUmF0ZUxpbWl0LCBjaGF0U3RyZWFtKTtcblxuLy8gQUkgQWdlbnQgQ2hhdCB3aXRoIGNlbnRyYWxpemVkIHByb21wdHMgKGludGVybmFsIHVzZSlcbnJvdXRlci5wb3N0KFwiL2FnZW50LWNoYXRcIiwgYWlSYXRlTGltaXQsIHN0cmVhbUFJQWdlbnRDaGF0SGFuZGxlcik7XG5cbi8vIFNpbXBsZSB0ZXh0IGNvbXBsZXRpb24gZW5kcG9pbnRcbnJvdXRlci5wb3N0KFwiL2NvbXBsZXRpb25cIiwgYWlSYXRlTGltaXQsIGdlbmVyYXRlQ29tcGxldGlvbkhhbmRsZXIpO1xuXG4vLyBTdHJlYW1pbmcgdGV4dCBjb21wbGV0aW9uIHdpdGggcmVhc29uaW5nIHN1cHBvcnRcbnJvdXRlci5wb3N0KFwiL3N0cmVhbS1jb21wbGV0aW9uXCIsIGFpUmF0ZUxpbWl0LCBzdHJlYW1Db21wbGV0aW9uSGFuZGxlcik7XG5cbi8vIFN0cnVjdHVyZWQgb2JqZWN0IGdlbmVyYXRpb24gZW5kcG9pbnRcbnJvdXRlci5wb3N0KFwiL2dlbmVyYXRlLW9iamVjdFwiLCBhaVJhdGVMaW1pdCwgZ2VuZXJhdGVPYmplY3RIYW5kbGVyKTtcblxuLy8gR2VuZXJhdGUgYWdlbnQtb3B0aW1pemVkIHJlc3BvbnNlIHRlbXBsYXRlXG5yb3V0ZXIucG9zdChcIi9nZW5lcmF0ZS10ZW1wbGF0ZVwiLCBhaVJhdGVMaW1pdCwgZ2VuZXJhdGVUZW1wbGF0ZUhhbmRsZXIpO1xuXG4vLyBHZXQgQUkgY29uZmlndXJhdGlvbiAoYXZhaWxhYmxlIHByb3ZpZGVycywgbW9kZWxzLCBldGMuKVxucm91dGVyLmdldChcIi9jb25maWdcIiwgZ2V0QUlDb25maWcpO1xuXG4vLyBTaW1wbGUgdGVzdCBlbmRwb2ludCB0byB2ZXJpZnkgT3BlbkFJIGNvbm5lY3Rpb25cbnJvdXRlci5nZXQoXCIvdGVzdFwiLCBhc3luYyAocmVxLCByZXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIlx1RDgzRVx1RERFQSBUZXN0aW5nIE9wZW5BSSBjb25uZWN0aW9uLi4uXCIpO1xuXG4gICAgY29uc3QgeyBnZW5lcmF0ZVRleHQgfSA9IGF3YWl0IGltcG9ydChcImFpXCIpO1xuICAgIGNvbnN0IHsgb3BlbmFpIH0gPSBhd2FpdCBpbXBvcnQoXCJAYWktc2RrL29wZW5haVwiKTtcblxuICAgIGNvbnN0IG1vZGVsID0gb3BlbmFpKFwiZ3B0LTRvXCIpO1xuXG4gICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdUREMDQgQ2FsbGluZyBnZW5lcmF0ZVRleHQgd2l0aCBzaW1wbGUgdGVzdC4uLlwiKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZVRleHQoe1xuICAgICAgbW9kZWwsXG4gICAgICBwcm9tcHQ6IFwiU2F5IGhlbGxvIGluIG9uZSB3b3JkXCIsXG4gICAgICBtYXhSZXRyaWVzOiAxLFxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coXCJcdTI3MDUgVGVzdCBzdWNjZXNzZnVsOlwiLCByZXN1bHQudGV4dCk7XG5cbiAgICByZXMuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgcmVzcG9uc2U6IHJlc3VsdC50ZXh0LFxuICAgICAgdXNhZ2U6IHJlc3VsdC51c2FnZSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiXHUyNzRDIFRlc3QgZmFpbGVkOlwiLCBlcnJvcik7XG5cbiAgICAvLyBFbmhhbmNlZCBlcnJvciBsb2dnaW5nIGZvciB0aGUgdGVzdCBlbmRwb2ludFxuICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGVycm9yT2JqID0gZXJyb3IgYXMge1xuICAgICAgICBzdGF0dXM/OiBudW1iZXI7XG4gICAgICAgIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gICAgICAgIGNvZGU/OiBudW1iZXI7XG4gICAgICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gICAgICAgIGVycm9yPzogeyBtZXNzYWdlPzogc3RyaW5nIH07XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yT2JqLnN0YXR1cyB8fCBlcnJvck9iai5zdGF0dXNDb2RlIHx8IGVycm9yT2JqLmNvZGU7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JPYmoubWVzc2FnZSB8fCBlcnJvck9iai5lcnJvcj8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyb3IpO1xuXG4gICAgICBjb25zb2xlLmVycm9yKGBcdUQ4M0RcdUREMEQgVGVzdCBlcnJvciAtIFN0YXR1czogJHtzdGF0dXNDb2RlfSwgTWVzc2FnZTogJHttZXNzYWdlfWApO1xuXG4gICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDI5IHx8IG1lc3NhZ2UuaW5jbHVkZXMoXCI0MjlcIikgfHwgbWVzc2FnZS5pbmNsdWRlcyhcInF1b3RhXCIpIHx8IG1lc3NhZ2UuaW5jbHVkZXMoXCJleGNlZWRlZFwiKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiXHVEODNEXHVEQ0IzIFFVT1RBIEVYQ0VFREVEOiBZb3UgbmVlZCB0byBhZGQgYmlsbGluZy9jcmVkaXRzIHRvIHlvdXIgT3BlbkFJIGFjY291bnRcIik7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQyOSkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiUVVPVEFfRVhDRUVERURcIixcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgXCJZb3UndmUgZXhjZWVkZWQgeW91ciBPcGVuQUkgcXVvdGEuIFBsZWFzZSBjaGVjayB5b3VyIGJpbGxpbmcgYXQgaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2FjY291bnQvYmlsbGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgIH0pO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIiwgImltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UgfSBmcm9tIFwiYWlcIjtcbmltcG9ydCB7IFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQge1xuICBBSVByb3ZpZGVyLFxuICBnZW5lcmF0ZUNvbXBsZXRpb24sXG4gIGdlbmVyYXRlSGFuZGxlYmFyc1RlbXBsYXRlLFxuICBnZW5lcmF0ZVN0cnVjdHVyZWRPYmplY3QsXG4gIGdldEF2YWlsYWJsZU1vZGVscyxcbiAgZ2V0Q29uZmlndXJlZFByb3ZpZGVycyxcbiAgc3RyZWFtQUlBZ2VudENoYXQsXG4gIHN0cmVhbUNoYXQsXG4gIHN0cmVhbUNvbXBsZXRpb24sXG59IGZyb20gXCIuLi9zZXJ2aWNlcy9haS5zZXJ2aWNlLmpzXCI7XG5cbi8vIEV4dGVuZGVkIHJlcXVlc3QgaW50ZXJmYWNlc1xuaW50ZXJmYWNlIEF1dGhlbnRpY2F0ZWRSZXF1ZXN0IGV4dGVuZHMgUmVxdWVzdCB7XG4gIGRiOiBQcmlzbWFDbGllbnQ7XG4gIGFkbWluPzogeyB0ZW5hbnRJZDogc3RyaW5nOyBpZDogc3RyaW5nIH07XG4gIHVzZXI/OiB7IHRlbmFudElkOiBzdHJpbmc7IGlkOiBzdHJpbmcgfTtcbn1cblxuLy8gSlNPTiBTY2hlbWEgaW50ZXJmYWNlc1xuaW50ZXJmYWNlIEpzb25TY2hlbWFQcm9wZXJ0eSB7XG4gIHR5cGU/OiBzdHJpbmc7XG4gIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBKc29uU2NoZW1hUHJvcGVydHk+O1xuICBpdGVtcz86IEpzb25TY2hlbWFQcm9wZXJ0eTtcbiAgcmVxdWlyZWQ/OiBzdHJpbmdbXTtcbiAgbWluTGVuZ3RoPzogbnVtYmVyO1xuICBtYXhMZW5ndGg/OiBudW1iZXI7XG4gIG1pbmltdW0/OiBudW1iZXI7XG4gIG1heGltdW0/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBKc29uU2NoZW1hIHtcbiAgdHlwZTogc3RyaW5nO1xuICBwcm9wZXJ0aWVzPzogUmVjb3JkPHN0cmluZywgSnNvblNjaGVtYVByb3BlcnR5PjtcbiAgcmVxdWlyZWQ/OiBzdHJpbmdbXTtcbn1cblxuLy8gQ29udmVydCBKU09OIFNjaGVtYSB0byBab2QgU2NoZW1hXG5mdW5jdGlvbiBjb252ZXJ0SnNvblNjaGVtYVRvWm9kKGpzb25TY2hlbWE6IEpzb25TY2hlbWEpOiB6LlpvZFNjaGVtYSB7XG4gIGlmICghanNvblNjaGVtYSB8fCB0eXBlb2YganNvblNjaGVtYSAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSlNPTiBzY2hlbWEgcHJvdmlkZWRcIik7XG4gIH1cblxuICBpZiAoanNvblNjaGVtYS50eXBlID09PSBcIm9iamVjdFwiICYmIGpzb25TY2hlbWEucHJvcGVydGllcykge1xuICAgIGNvbnN0IHpvZFByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIHouWm9kVHlwZUFueT4gPSB7fTtcblxuICAgIC8vIENvbnZlcnQgZWFjaCBwcm9wZXJ0eVxuICAgIGZvciAoY29uc3QgW2tleSwgcHJvcF0gb2YgT2JqZWN0LmVudHJpZXMoanNvblNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgem9kUHJvcGVydGllc1trZXldID0gY29udmVydFByb3BlcnR5VG9ab2QocHJvcCk7XG4gICAgfVxuXG4gICAgbGV0IG9iamVjdFNjaGVtYSA9IHoub2JqZWN0KHpvZFByb3BlcnRpZXMpO1xuXG4gICAgLy8gSGFuZGxlIHJlcXVpcmVkIGZpZWxkc1xuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb25TY2hlbWEucmVxdWlyZWQpKSB7XG4gICAgICAvLyBab2Qgb2JqZWN0IHNjaGVtYSBpcyBzdHJpY3QgYnkgZGVmYXVsdCwgc28gd2UganVzdCBuZWVkIHRvIGhhbmRsZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gbmV3IFNldChqc29uU2NoZW1hLnJlcXVpcmVkKTtcbiAgICAgIGNvbnN0IHBhcnRpYWxGaWVsZHM6IFJlY29yZDxzdHJpbmcsIHouWm9kVHlwZUFueT4gPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBba2V5LCB6b2RUeXBlXSBvZiBPYmplY3QuZW50cmllcyh6b2RQcm9wZXJ0aWVzKSkge1xuICAgICAgICBpZiAoIXJlcXVpcmVkRmllbGRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcGFydGlhbEZpZWxkc1trZXldID0gem9kVHlwZS5vcHRpb25hbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpYWxGaWVsZHNba2V5XSA9IHpvZFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2JqZWN0U2NoZW1hID0gei5vYmplY3QocGFydGlhbEZpZWxkcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFNjaGVtYTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNjaGVtYSB0eXBlIC0gb25seSBvYmplY3Qgc2NoZW1hcyBhcmUgc3VwcG9ydGVkXCIpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlUb1pvZChwcm9wOiBKc29uU2NoZW1hUHJvcGVydHkpOiB6LlpvZFR5cGVBbnkge1xuICBpZiAoIXByb3AgfHwgdHlwZW9mIHByb3AgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gei5zdHJpbmcoKTsgLy8gRGVmYXVsdCBmYWxsYmFja1xuICB9XG5cbiAgc3dpdGNoIChwcm9wLnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBsZXQgc3RyaW5nU2NoZW1hID0gei5zdHJpbmcoKTtcbiAgICAgIGlmIChwcm9wLm1pbkxlbmd0aCkgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLm1pbihwcm9wLm1pbkxlbmd0aCk7XG4gICAgICBpZiAocHJvcC5tYXhMZW5ndGgpIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5tYXgocHJvcC5tYXhMZW5ndGgpO1xuICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYTtcblxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGxldCBudW1iZXJTY2hlbWEgPSB6Lm51bWJlcigpO1xuICAgICAgaWYgKHByb3AubWluaW11bSAhPT0gdW5kZWZpbmVkKSBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubWluKHByb3AubWluaW11bSk7XG4gICAgICBpZiAocHJvcC5tYXhpbXVtICE9PSB1bmRlZmluZWQpIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5tYXgocHJvcC5tYXhpbXVtKTtcbiAgICAgIHJldHVybiBudW1iZXJTY2hlbWE7XG5cbiAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgbGV0IGludFNjaGVtYSA9IHoubnVtYmVyKCkuaW50KCk7XG4gICAgICBpZiAocHJvcC5taW5pbXVtICE9PSB1bmRlZmluZWQpIGludFNjaGVtYSA9IGludFNjaGVtYS5taW4ocHJvcC5taW5pbXVtKTtcbiAgICAgIGlmIChwcm9wLm1heGltdW0gIT09IHVuZGVmaW5lZCkgaW50U2NoZW1hID0gaW50U2NoZW1hLm1heChwcm9wLm1heGltdW0pO1xuICAgICAgcmV0dXJuIGludFNjaGVtYTtcblxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gei5ib29sZWFuKCk7XG5cbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGNvbnN0IGl0ZW1TY2hlbWEgPSBwcm9wLml0ZW1zID8gY29udmVydFByb3BlcnR5VG9ab2QocHJvcC5pdGVtcykgOiB6LmFueSgpO1xuICAgICAgcmV0dXJuIHouYXJyYXkoaXRlbVNjaGVtYSk7XG5cbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAocHJvcC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IG5lc3RlZFByb3BzOiBSZWNvcmQ8c3RyaW5nLCB6LlpvZFR5cGVBbnk+ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgbmVzdGVkUHJvcF0gb2YgT2JqZWN0LmVudHJpZXMocHJvcC5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIG5lc3RlZFByb3BzW2tleV0gPSBjb252ZXJ0UHJvcGVydHlUb1pvZChuZXN0ZWRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei5vYmplY3QobmVzdGVkUHJvcHMpO1xuICAgICAgfVxuICAgICAgLy8gRm9yIG9iamVjdHMgd2l0aG91dCBkZWZpbmVkIHByb3BlcnRpZXMgb3Igd2l0aCBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSwgdXNlIHoucmVjb3JkKClcbiAgICAgIHJldHVybiB6LnJlY29yZCh6LnVua25vd24oKSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHoudW5rbm93bigpOyAvLyBGYWxsYmFjayBmb3IgdW5rbm93biB0eXBlc1xuICB9XG59XG5cbi8vIFJlcXVlc3QgdmFsaWRhdGlvbiBzY2hlbWFzXG5jb25zdCBjaGF0UmVxdWVzdFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgbWVzc2FnZXM6IHouYXJyYXkoXG4gICAgei5vYmplY3Qoe1xuICAgICAgaWQ6IHouc3RyaW5nKCksXG4gICAgICByb2xlOiB6LmVudW0oW1widXNlclwiLCBcImFzc2lzdGFudFwiLCBcInN5c3RlbVwiXSksXG4gICAgICBjb250ZW50OiB6LnN0cmluZygpLFxuICAgIH0pLFxuICApLFxuICBjb25maWc6IHpcbiAgICAub2JqZWN0KHtcbiAgICAgIHByb3ZpZGVyOiB6LmVudW0oW1wib3BlbmFpXCIsIFwiYW50aHJvcGljXCJdKS5vcHRpb25hbCgpLFxuICAgICAgbW9kZWw6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgIHRlbXBlcmF0dXJlOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMikub3B0aW9uYWwoKSxcbiAgICAgIG1heFRva2Vuczogei5udW1iZXIoKS5wb3NpdGl2ZSgpLm9wdGlvbmFsKCksXG4gICAgICB0b3BQOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMSkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgIC5vcHRpb25hbCgpLFxufSk7XG5cbmNvbnN0IGNvbXBsZXRpb25SZXF1ZXN0U2NoZW1hID0gei5vYmplY3Qoe1xuICBwcm9tcHQ6IHouc3RyaW5nKCkubWluKDEpLFxuICBjb25maWc6IHpcbiAgICAub2JqZWN0KHtcbiAgICAgIHByb3ZpZGVyOiB6LmVudW0oW1wib3BlbmFpXCIsIFwiYW50aHJvcGljXCJdKS5vcHRpb25hbCgpLFxuICAgICAgbW9kZWw6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgIHRlbXBlcmF0dXJlOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMikub3B0aW9uYWwoKSxcbiAgICAgIG1heFRva2Vuczogei5udW1iZXIoKS5wb3NpdGl2ZSgpLm9wdGlvbmFsKCksXG4gICAgICB0b3BQOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMSkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgIC5vcHRpb25hbCgpLFxuICBlbmFibGVXZWJTZWFyY2g6IHouYm9vbGVhbigpLm9wdGlvbmFsKCksXG59KTtcblxuY29uc3Qgc3RyZWFtQ29tcGxldGlvblJlcXVlc3RTY2hlbWEgPSBjb21wbGV0aW9uUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBlbmFibGVSZWFzb25pbmc6IHouYm9vbGVhbigpLm9wdGlvbmFsKCksXG59KTtcblxuY29uc3QgYWdlbnRDaGF0UmVxdWVzdFNjaGVtYSA9IGNvbXBsZXRpb25SZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIGNvbnZlcnNhdGlvbkhpc3Rvcnk6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgaGFzU2hvd25EZXNpZ246IHouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gIHNlcnZlcklkOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcblxuY29uc3QgdGVtcGxhdGVSZXF1ZXN0U2NoZW1hID0gei5vYmplY3Qoe1xuICB0b29sOiB6Lm9iamVjdCh7XG4gICAgbmFtZTogei5zdHJpbmcoKSxcbiAgICBkZXNjcmlwdGlvbjogei5zdHJpbmcoKSxcbiAgICBtZXRob2Q6IHouc3RyaW5nKCksXG4gICAgdXJsOiB6LnN0cmluZygpLFxuICAgIHBhcmFtZXRlcnM6IHoucmVjb3JkKHoudW5rbm93bigpKS5vcHRpb25hbCgpLm51bGxhYmxlKCksXG4gICAgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlczogei5yZWNvcmQoei51bmtub3duKCkpLm9wdGlvbmFsKCkubnVsbGFibGUoKSxcbiAgICByZXNwb25zZXM6IHoucmVjb3JkKHoudW5rbm93bigpKS5vcHRpb25hbCgpLm51bGxhYmxlKCksXG4gIH0pLFxuICBjb25maWc6IHpcbiAgICAub2JqZWN0KHtcbiAgICAgIHByb3ZpZGVyOiB6LmVudW0oW1wib3BlbmFpXCIsIFwiYW50aHJvcGljXCJdKS5vcHRpb25hbCgpLFxuICAgICAgbW9kZWw6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgIHRlbXBlcmF0dXJlOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMikub3B0aW9uYWwoKSxcbiAgICAgIG1heFRva2Vuczogei5udW1iZXIoKS5wb3NpdGl2ZSgpLm9wdGlvbmFsKCksXG4gICAgICB0b3BQOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMSkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgIC5vcHRpb25hbCgpLFxufSk7XG5cbi8vIFN0cmVhbSBjaGF0IHJlc3BvbnNlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hhdFN0cmVhbShyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpIHtcbiAgdHJ5IHtcbiAgICAvLyBWYWxpZGF0ZSByZXF1ZXN0IGJvZHlcbiAgICBjb25zdCBib2R5ID0gY2hhdFJlcXVlc3RTY2hlbWEucGFyc2UocmVxLmJvZHkpO1xuXG4gICAgLy8gR2V0IHRlbmFudCBJRCBmcm9tIGF1dGhlbnRpY2F0ZWQgdXNlciAoYWRtaW4gb3IgZW5kIHVzZXIpXG4gICAgY29uc3QgYXV0aFJlcSA9IHJlcSBhcyB1bmtub3duIGFzIEF1dGhlbnRpY2F0ZWRSZXF1ZXN0O1xuICAgIGNvbnN0IGFkbWluID0gYXV0aFJlcS5hZG1pbjtcbiAgICBjb25zdCB1c2VyID0gYXV0aFJlcS51c2VyO1xuICAgIGNvbnN0IHRlbmFudElkID0gYWRtaW4/LnRlbmFudElkIHx8IHVzZXI/LnRlbmFudElkO1xuICAgIGNvbnN0IHVzZXJJZCA9IGFkbWluPy5pZCB8fCB1c2VyPy5pZDtcblxuICAgIGlmICghdGVuYW50SWQpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiBcIlRlbmFudCBJRCBpcyByZXF1aXJlZFwiIH0pO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCBTU0UgaGVhZGVycyBmb3Igc3RyZWFtaW5nXG4gICAgcmVzLnNldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvZXZlbnQtc3RyZWFtXCIpO1xuICAgIHJlcy5zZXRIZWFkZXIoXCJDYWNoZS1Db250cm9sXCIsIFwibm8tY2FjaGVcIik7XG4gICAgcmVzLnNldEhlYWRlcihcIkNvbm5lY3Rpb25cIiwgXCJrZWVwLWFsaXZlXCIpO1xuICAgIHJlcy5zZXRIZWFkZXIoXCJYLUFjY2VsLUJ1ZmZlcmluZ1wiLCBcIm5vXCIpOyAvLyBEaXNhYmxlIG5naW54IGJ1ZmZlcmluZ1xuXG4gICAgY29uc29sZS5sb2coYFx1RDgzRFx1REU4MCBTdGFydGluZyBjaGF0IHN0cmVhbSBmb3IgdGVuYW50OiAke3RlbmFudElkfSwgdXNlcjogJHt1c2VySWR9YCk7XG4gICAgY29uc29sZS5sb2coYFx1RDgzRFx1RENERCBSZXF1ZXN0IGJvZHk6YCwge1xuICAgICAgbWVzc2FnZUNvdW50OiBib2R5Lm1lc3NhZ2VzLmxlbmd0aCxcbiAgICAgIGNvbmZpZzogYm9keS5jb25maWcsXG4gICAgICBmaXJzdE1lc3NhZ2U6IGJvZHkubWVzc2FnZXNbMF0/LmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCkgKyBcIi4uLlwiLFxuICAgIH0pO1xuXG4gICAgLy8gU3RyZWFtIHRoZSBjaGF0IHJlc3BvbnNlXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RyZWFtQ2hhdCgocmVxIGFzIHVua25vd24gYXMgQXV0aGVudGljYXRlZFJlcXVlc3QpLmRiLCB7XG4gICAgICBtZXNzYWdlczogYm9keS5tZXNzYWdlcyBhcyBDb3JlTWVzc2FnZVtdLFxuICAgICAgY29uZmlnOiBib2R5LmNvbmZpZyxcbiAgICAgIHRlbmFudElkLFxuICAgICAgdXNlcklkLFxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coYFx1RDgzRFx1RENFMSBTdHJlYW0gcmVzdWx0IGNyZWF0ZWQsIGNvbnZlcnRpbmcgdG8gdGV4dCBzdHJlYW0gcmVzcG9uc2VgKTtcblxuICAgIC8vIENvbnZlcnQgdG8gZGF0YSBzdHJlYW0gcmVzcG9uc2VcbiAgICBjb25zdCByZXNwb25zZSA9IHJlc3VsdC50b1RleHRTdHJlYW1SZXNwb25zZSgpO1xuICAgIGNvbnNvbGUubG9nKGBcdUQ4M0RcdURDRTEgU3RyZWFtIHJlc3BvbnNlIGhlYWRlcnM6YCwgT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSk7XG5cbiAgICBjb25zb2xlLmxvZyhgXHVEODNEXHVEQ0U0IFN0YXJ0aW5nIHRvIHN0cmVhbSByZXNwb25zZSB0byBjbGllbnRgKTtcblxuICAgIC8vIFBpcGUgdGhlIHJlc3BvbnNlIGJvZHkgdG8gb3VyIHJlc3BvbnNlXG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICBsZXQgY2h1bmtDb3VudCA9IDA7XG4gICAgICBsZXQgdG90YWxCeXRlcyA9IDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFx1RDgzQ1x1REZDMSBTdHJlYW0gZmluaXNoZWQgYWZ0ZXIgJHtjaHVua0NvdW50fSBjaHVua3MsICR7dG90YWxCeXRlc30gdG90YWwgYnl0ZXNgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNodW5rQ291bnQrKztcbiAgICAgICAgICB0b3RhbEJ5dGVzICs9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICAgIC8vIExvZyB0aGUgYWN0dWFsIGNvbnRlbnQgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgXHVEODNEXHVEQ0U2IENodW5rICR7Y2h1bmtDb3VudH06ICR7dmFsdWUubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBcdUQ4M0RcdURDREQgQ2h1bmsgY29udGVudCAoZmlyc3QgMjAwIGNoYXJzKTogJHtjaHVuay5zdWJzdHJpbmcoMCwgMjAwKX0uLi5gKTtcblxuICAgICAgICAgIC8vIFdyaXRlIHRoZSBjaHVuayB0byB0aGUgcmVzcG9uc2VcbiAgICAgICAgICByZXMud3JpdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYFx1Mjc0QyBObyByZXNwb25zZSBib2R5IGZyb20gc3RyZWFtYCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFx1MjcwNSBTdHJlYW0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgIHJlcy5lbmQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ2hhdCBzdHJlYW0gZXJyb3I6XCIsIGVycm9yKTtcblxuICAgIC8vIElmIGhlYWRlcnMgaGF2ZW4ndCBiZWVuIHNlbnQsIHNlbmQgZXJyb3IgcmVzcG9uc2VcbiAgICBpZiAoIXJlcy5oZWFkZXJzU2VudCkge1xuICAgICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJGYWlsZWQgdG8gcHJvY2VzcyBjaGF0IHJlcXVlc3RcIixcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBzdHJlYW1pbmcgaGFzIHN0YXJ0ZWQsIHNlbmQgZXJyb3IgZXZlbnRcbiAgICAgIHJlcy53cml0ZShgZGF0YTogJHtKU09OLnN0cmluZ2lmeSh7IGVycm9yOiBcIlN0cmVhbSBlcnJvciBvY2N1cnJlZFwiIH0pfVxcblxcbmApO1xuICAgICAgcmVzLmVuZCgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBHZW5lcmF0ZSB0ZXh0IGNvbXBsZXRpb25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbXBsZXRpb25IYW5kbGVyKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkge1xuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIHJlcXVlc3QgYm9keVxuICAgIGNvbnN0IGJvZHkgPSBjb21wbGV0aW9uUmVxdWVzdFNjaGVtYS5wYXJzZShyZXEuYm9keSk7XG5cbiAgICAvLyBHZXQgdGVuYW50IElEIGZyb20gYXV0aGVudGljYXRlZCB1c2VyIChhZG1pbiBvciBlbmQgdXNlcilcbiAgICBjb25zdCBhdXRoUmVxID0gcmVxIGFzIHVua25vd24gYXMgQXV0aGVudGljYXRlZFJlcXVlc3Q7XG4gICAgY29uc3QgYWRtaW4gPSBhdXRoUmVxLmFkbWluO1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoUmVxLnVzZXI7XG4gICAgY29uc3QgdGVuYW50SWQgPSBhZG1pbj8udGVuYW50SWQgfHwgdXNlcj8udGVuYW50SWQ7XG4gICAgY29uc3QgdXNlcklkID0gYWRtaW4/LmlkIHx8IHVzZXI/LmlkO1xuXG4gICAgaWYgKCF0ZW5hbnRJZCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6IFwiVGVuYW50IElEIGlzIHJlcXVpcmVkXCIgfSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgY29tcGxldGlvblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlQ29tcGxldGlvbigocmVxIGFzIHVua25vd24gYXMgQXV0aGVudGljYXRlZFJlcXVlc3QpLmRiLCB7XG4gICAgICBwcm9tcHQ6IGJvZHkucHJvbXB0LFxuICAgICAgY29uZmlnOiBib2R5LmNvbmZpZyxcbiAgICAgIHRlbmFudElkLFxuICAgICAgdXNlcklkLFxuICAgICAgZW5hYmxlV2ViU2VhcmNoOiBib2R5LmVuYWJsZVdlYlNlYXJjaCxcbiAgICB9KTtcblxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0XG4gICAgcmVzLmpzb24oe1xuICAgICAgdGV4dDogcmVzdWx0LnRleHQsXG4gICAgICB1c2FnZTogcmVzdWx0LnVzYWdlLFxuICAgICAgZmluaXNoUmVhc29uOiByZXN1bHQuZmluaXNoUmVhc29uLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJDb21wbGV0aW9uIGVycm9yOlwiLCBlcnJvcik7XG5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiB6LlpvZEVycm9yKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJJbnZhbGlkIHJlcXVlc3RcIixcbiAgICAgICAgZGV0YWlsczogZXJyb3IuZXJyb3JzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgZXJyb3I6IFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNvbXBsZXRpb25cIixcbiAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gU3RyZWFtIHRleHQgY29tcGxldGlvbiB3aXRoIHJlYXNvbmluZyBzdXBwb3J0XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtQ29tcGxldGlvbkhhbmRsZXIocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgLy8gVmFsaWRhdGUgcmVxdWVzdCBib2R5XG4gICAgY29uc3QgYm9keSA9IHN0cmVhbUNvbXBsZXRpb25SZXF1ZXN0U2NoZW1hLnBhcnNlKHJlcS5ib2R5KTtcblxuICAgIC8vIEdldCB0ZW5hbnQgSUQgZnJvbSBhdXRoZW50aWNhdGVkIHVzZXIgKGFkbWluIG9yIGVuZCB1c2VyKVxuICAgIGNvbnN0IGF1dGhSZXEgPSByZXEgYXMgdW5rbm93biBhcyBBdXRoZW50aWNhdGVkUmVxdWVzdDtcbiAgICBjb25zdCBhZG1pbiA9IGF1dGhSZXEuYWRtaW47XG4gICAgY29uc3QgdXNlciA9IGF1dGhSZXEudXNlcjtcbiAgICBjb25zdCB0ZW5hbnRJZCA9IGFkbWluPy50ZW5hbnRJZCB8fCB1c2VyPy50ZW5hbnRJZDtcbiAgICBjb25zdCB1c2VySWQgPSBhZG1pbj8uaWQgfHwgdXNlcj8uaWQ7XG5cbiAgICBpZiAoIXRlbmFudElkKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogXCJUZW5hbnQgSUQgaXMgcmVxdWlyZWRcIiB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgU1NFIGhlYWRlcnMgZm9yIHN0cmVhbWluZ1xuICAgIHJlcy5zZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKTtcbiAgICByZXMuc2V0SGVhZGVyKFwiQ2FjaGUtQ29udHJvbFwiLCBcIm5vLWNhY2hlXCIpO1xuICAgIHJlcy5zZXRIZWFkZXIoXCJDb25uZWN0aW9uXCIsIFwia2VlcC1hbGl2ZVwiKTtcbiAgICByZXMuc2V0SGVhZGVyKFwiWC1BY2NlbC1CdWZmZXJpbmdcIiwgXCJub1wiKTtcblxuICAgIGNvbnNvbGUubG9nKGBcdUQ4M0RcdURFODAgU3RhcnRpbmcgY29tcGxldGlvbiBzdHJlYW0gZm9yIHRlbmFudDogJHt0ZW5hbnRJZH1gKTtcblxuICAgIC8vIFN0cmVhbSB0aGUgY29tcGxldGlvblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbUNvbXBsZXRpb24oKHJlcSBhcyB1bmtub3duIGFzIEF1dGhlbnRpY2F0ZWRSZXF1ZXN0KS5kYiwge1xuICAgICAgcHJvbXB0OiBib2R5LnByb21wdCxcbiAgICAgIGNvbmZpZzogYm9keS5jb25maWcsXG4gICAgICB0ZW5hbnRJZCxcbiAgICAgIHVzZXJJZCxcbiAgICAgIGVuYWJsZVdlYlNlYXJjaDogYm9keS5lbmFibGVXZWJTZWFyY2gsXG4gICAgICBlbmFibGVSZWFzb25pbmc6IGJvZHkuZW5hYmxlUmVhc29uaW5nLFxuICAgIH0pO1xuXG4gICAgLy8gQ29udmVydCB0byBVSSBtZXNzYWdlIHN0cmVhbSByZXNwb25zZSB3aXRoIHJlYXNvbmluZyBlbmFibGVkXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXN1bHQudG9VSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgICBzZW5kUmVhc29uaW5nOiBib2R5LmVuYWJsZVJlYXNvbmluZyB8fCBmYWxzZSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gUGlwZSB0aGUgcmVzcG9uc2UgYm9keSB0byBvdXIgcmVzcG9uc2VcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICByZXMud3JpdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXMuZW5kKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlN0cmVhbSBjb21wbGV0aW9uIGVycm9yOlwiLCBlcnJvcik7XG5cbiAgICBpZiAoIXJlcy5oZWFkZXJzU2VudCkge1xuICAgICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJGYWlsZWQgdG8gc3RyZWFtIGNvbXBsZXRpb25cIixcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMud3JpdGUoYGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogXCJTdHJlYW0gZXJyb3Igb2NjdXJyZWRcIiB9KX1cXG5cXG5gKTtcbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gR2VuZXJhdGUgc3RydWN0dXJlZCBvYmplY3RcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU9iamVjdEhhbmRsZXIocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBwcm9tcHQsIHNjaGVtYTogc2NoZW1hRGVmaW5pdGlvbiwgY29uZmlnIH0gPSByZXEuYm9keTtcblxuICAgIC8vIEdldCB0ZW5hbnQgSUQgZnJvbSBhdXRoZW50aWNhdGVkIHVzZXIgKGFkbWluIG9yIGVuZCB1c2VyKVxuICAgIGNvbnN0IGF1dGhSZXEgPSByZXEgYXMgdW5rbm93biBhcyBBdXRoZW50aWNhdGVkUmVxdWVzdDtcbiAgICBjb25zdCBhZG1pbiA9IGF1dGhSZXEuYWRtaW47XG4gICAgY29uc3QgdXNlciA9IGF1dGhSZXEudXNlcjtcbiAgICBjb25zdCB0ZW5hbnRJZCA9IGFkbWluPy50ZW5hbnRJZCB8fCB1c2VyPy50ZW5hbnRJZDtcbiAgICBjb25zdCB1c2VySWQgPSBhZG1pbj8uaWQgfHwgdXNlcj8uaWQ7XG5cbiAgICBpZiAoIXRlbmFudElkKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogXCJUZW5hbnQgSUQgaXMgcmVxdWlyZWRcIiB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXByb21wdCB8fCAhc2NoZW1hRGVmaW5pdGlvbikge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcbiAgICAgICAgZXJyb3I6IFwiUHJvbXB0IGFuZCBzY2hlbWEgYXJlIHJlcXVpcmVkXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IEpTT04gc2NoZW1hIHRvIFpvZCBzY2hlbWFcbiAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REQwNCBDb252ZXJ0aW5nIEpTT04gc2NoZW1hIHRvIFpvZDpcIiwgSlNPTi5zdHJpbmdpZnkoc2NoZW1hRGVmaW5pdGlvbiwgbnVsbCwgMikpO1xuICAgIGxldCBzY2hlbWE6IHouWm9kU2NoZW1hO1xuICAgIHRyeSB7XG4gICAgICBzY2hlbWEgPSBjb252ZXJ0SnNvblNjaGVtYVRvWm9kKHNjaGVtYURlZmluaXRpb24pO1xuICAgICAgY29uc29sZS5sb2coXCJcdTI3MDUgU2NoZW1hIGNvbnZlcnNpb24gc3VjY2Vzc2Z1bFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlx1Mjc0QyBTY2hlbWEgY29udmVyc2lvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcbiAgICAgICAgZXJyb3I6IFwiSW52YWxpZCBzY2hlbWEgZGVmaW5pdGlvblwiLFxuICAgICAgICBkZXRhaWxzOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgc3RydWN0dXJlZCBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZVN0cnVjdHVyZWRPYmplY3QoKHJlcSBhcyB1bmtub3duIGFzIEF1dGhlbnRpY2F0ZWRSZXF1ZXN0KS5kYiwge1xuICAgICAgcHJvbXB0LFxuICAgICAgc2NoZW1hLFxuICAgICAgY29uZmlnLFxuICAgICAgdGVuYW50SWQsXG4gICAgICB1c2VySWQsXG4gICAgfSk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdFxuICAgIHJlcy5qc29uKHtcbiAgICAgIG9iamVjdDogcmVzdWx0Lm9iamVjdCxcbiAgICAgIHVzYWdlOiByZXN1bHQudXNhZ2UsXG4gICAgICBmaW5pc2hSZWFzb246IHJlc3VsdC5maW5pc2hSZWFzb24sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkdlbmVyYXRlIG9iamVjdCBlcnJvcjpcIiwgZXJyb3IpO1xuXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgZXJyb3I6IFwiRmFpbGVkIHRvIGdlbmVyYXRlIG9iamVjdFwiLFxuICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBTdHJlYW0gQUkgYWdlbnQgY2hhdCB3aXRoIGNlbnRyYWxpemVkIHByb21wdHNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdHJlYW1BSUFnZW50Q2hhdEhhbmRsZXIocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgLy8gVmFsaWRhdGUgcmVxdWVzdCBib2R5XG4gICAgY29uc3QgYm9keSA9IGFnZW50Q2hhdFJlcXVlc3RTY2hlbWEucGFyc2UocmVxLmJvZHkpO1xuXG4gICAgLy8gR2V0IHRlbmFudCBJRCBmcm9tIGF1dGhlbnRpY2F0ZWQgdXNlciAoYWRtaW4gb3IgZW5kIHVzZXIpXG4gICAgY29uc3QgYXV0aFJlcSA9IHJlcSBhcyB1bmtub3duIGFzIEF1dGhlbnRpY2F0ZWRSZXF1ZXN0O1xuICAgIGNvbnN0IGFkbWluID0gYXV0aFJlcS5hZG1pbjtcbiAgICBjb25zdCB1c2VyID0gYXV0aFJlcS51c2VyO1xuICAgIGNvbnN0IHRlbmFudElkID0gYWRtaW4/LnRlbmFudElkIHx8IHVzZXI/LnRlbmFudElkO1xuICAgIGNvbnN0IHVzZXJJZCA9IGFkbWluPy5pZCB8fCB1c2VyPy5pZDtcblxuICAgIGlmICghdGVuYW50SWQpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiBcIlRlbmFudCBJRCBpcyByZXF1aXJlZFwiIH0pO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCBTU0UgaGVhZGVycyBmb3Igc3RyZWFtaW5nXG4gICAgcmVzLnNldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvZXZlbnQtc3RyZWFtXCIpO1xuICAgIHJlcy5zZXRIZWFkZXIoXCJDYWNoZS1Db250cm9sXCIsIFwibm8tY2FjaGVcIik7XG4gICAgcmVzLnNldEhlYWRlcihcIkNvbm5lY3Rpb25cIiwgXCJrZWVwLWFsaXZlXCIpO1xuICAgIHJlcy5zZXRIZWFkZXIoXCJYLUFjY2VsLUJ1ZmZlcmluZ1wiLCBcIm5vXCIpO1xuXG4gICAgLy8gU3RyZWFtIHRoZSBBSSBhZ2VudCBjaGF0IHJlc3BvbnNlXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RyZWFtQUlBZ2VudENoYXQoKHJlcSBhcyB1bmtub3duIGFzIEF1dGhlbnRpY2F0ZWRSZXF1ZXN0KS5kYiwge1xuICAgICAgcHJvbXB0OiBib2R5LnByb21wdCxcbiAgICAgIGNvbnZlcnNhdGlvbkhpc3Rvcnk6IGJvZHkuY29udmVyc2F0aW9uSGlzdG9yeSxcbiAgICAgIGhhc1Nob3duRGVzaWduOiBib2R5Lmhhc1Nob3duRGVzaWduLFxuICAgICAgc2VydmVySWQ6IGJvZHkuc2VydmVySWQsXG4gICAgICBjb25maWc6IGJvZHkuY29uZmlnLFxuICAgICAgdGVuYW50SWQsXG4gICAgICB1c2VySWQsXG4gICAgfSk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIFVJIG1lc3NhZ2Ugc3RyZWFtIHJlc3BvbnNlIGZvciByaWNoZXIgaW50ZXJhY3Rpb25cbiAgICBjb25zdCByZXNwb25zZSA9IHJlc3VsdC50b1VJTWVzc2FnZVN0cmVhbVJlc3BvbnNlKCk7XG5cbiAgICAvLyBQaXBlIHRoZSByZXNwb25zZSBib2R5IHRvIG91ciByZXNwb25zZVxuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICByZXMud3JpdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXMuZW5kKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkFJIGFnZW50IGNoYXQgc3RyZWFtIGVycm9yOlwiLCBlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcbiAgICAgIG5hbWU6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5uYW1lIDogXCJVbmtub3duXCIsXG4gICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgc3RhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IHVuZGVmaW5lZCxcbiAgICB9KTtcblxuICAgIGlmICghcmVzLmhlYWRlcnNTZW50KSB7XG4gICAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgIGVycm9yOiBcIkZhaWxlZCB0byBwcm9jZXNzIEFJIGFnZW50IGNoYXQgcmVxdWVzdFwiLFxuICAgICAgICBtZXNzYWdlOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlbmQgZXJyb3IgaW4gVUkgbWVzc2FnZSBzdHJlYW0gZm9ybWF0XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJTdHJlYW0gZXJyb3Igb2NjdXJyZWRcIixcbiAgICAgIH0pO1xuICAgICAgcmVzLndyaXRlKGAke2Vycm9yRGF0YX1cXG5gKTtcbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gR2VuZXJhdGUgYWdlbnQtb3B0aW1pemVkIHJlc3BvbnNlIHRlbXBsYXRlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZW1wbGF0ZUhhbmRsZXIocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSB7XG4gIHRyeSB7XG4gICAgLy8gVmFsaWRhdGUgcmVxdWVzdCBib2R5XG4gICAgY29uc3QgYm9keSA9IHRlbXBsYXRlUmVxdWVzdFNjaGVtYS5wYXJzZShyZXEuYm9keSk7XG5cbiAgICAvLyBHZXQgdGVuYW50IElEIGZyb20gYXV0aGVudGljYXRlZCB1c2VyIChhZG1pbiBvciBlbmQgdXNlcilcbiAgICBjb25zdCBhdXRoUmVxID0gcmVxIGFzIHVua25vd24gYXMgQXV0aGVudGljYXRlZFJlcXVlc3Q7XG4gICAgY29uc3QgYWRtaW4gPSBhdXRoUmVxLmFkbWluO1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoUmVxLnVzZXI7XG4gICAgY29uc3QgdGVuYW50SWQgPSBhZG1pbj8udGVuYW50SWQgfHwgdXNlcj8udGVuYW50SWQ7XG5cbiAgICBpZiAoIXRlbmFudElkKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogXCJUZW5hbnQgSUQgaXMgcmVxdWlyZWRcIiB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHRvb2wsIGNvbmZpZyB9ID0gYm9keTtcblxuICAgIC8vIFVzZSByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBwYXJhbWV0ZXJzXG4gICAgLy8gSGFuZGxlIG51bGwgdmFsdWVzIGJ5IGNvbnZlcnRpbmcgdGhlbSB0byBlbXB0eSBvYmplY3RzXG4gICAgY29uc3QgcGFyYW1ldGVyc1RvVXNlID0gdG9vbC5yZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzIHx8IHRvb2wucGFyYW1ldGVycyB8fCB7fTtcblxuICAgIC8vIEJ1aWxkIHRoZSB0b29sIGNvbnRleHQgZm9yIHRoZSBwcm9tcHRcbiAgICBjb25zdCB0b29sQ29udGV4dCA9IHtcbiAgICAgIHRvb2xOYW1lOiB0b29sLm5hbWUsXG4gICAgICB0b29sRGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICBtZXRob2Q6IHRvb2wubWV0aG9kLFxuICAgICAgdXJsOiB0b29sLnVybCxcbiAgICAgIHBhcmFtZXRlcnM6IEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnNUb1VzZSwgbnVsbCwgMiksXG4gICAgICByZXNwb25zZXM6IEpTT04uc3RyaW5naWZ5KHRvb2wucmVzcG9uc2VzIHx8IHt9LCBudWxsLCAyKSxcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGUgdGVtcGxhdGUgdXNpbmcgdGhlIGNlbnRyYWxpemVkIGJhY2tlbmQgZnVuY3Rpb25cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZUhhbmRsZWJhcnNUZW1wbGF0ZSgocmVxIGFzIHVua25vd24gYXMgQXV0aGVudGljYXRlZFJlcXVlc3QpLmRiLCB0b29sQ29udGV4dCwgY29uZmlnKTtcblxuICAgIC8vIEV4dHJhY3QgdGhlIHRlbXBsYXRlIGZyb20gdGhlIGNvbXBsZXRpb25cbiAgICBsZXQgdGVtcGxhdGUgPSByZXN1bHQudGV4dC50cmltKCk7XG5cbiAgICAvLyBSZW1vdmUgY29kZSBmZW5jZSBtYXJrZXJzIGlmIHByZXNlbnRcbiAgICBpZiAodGVtcGxhdGUuc3RhcnRzV2l0aChcImBgYFwiKSAmJiB0ZW1wbGF0ZS5lbmRzV2l0aChcImBgYFwiKSkge1xuICAgICAgY29uc3QgbGluZXMgPSB0ZW1wbGF0ZS5zcGxpdChcIlxcblwiKTtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRlbXBsYXRlID0gbGluZXMuc2xpY2UoMSwgLTEpLmpvaW4oXCJcXG5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGVcbiAgICByZXMuanNvbih7XG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIHVzYWdlOiByZXN1bHQudXNhZ2UsXG4gICAgICBmaW5pc2hSZWFzb246IHJlc3VsdC5maW5pc2hSZWFzb24sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRlbXBsYXRlIGdlbmVyYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHouWm9kRXJyb3IpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7XG4gICAgICAgIGVycm9yOiBcIkludmFsaWQgcmVxdWVzdFwiLFxuICAgICAgICBkZXRhaWxzOiBlcnJvci5lcnJvcnMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICBlcnJvcjogXCJGYWlsZWQgdG8gZ2VuZXJhdGUgdGVtcGxhdGVcIixcbiAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gR2V0IEFJIGNvbmZpZ3VyYXRpb24gYW5kIGF2YWlsYWJsZSBwcm92aWRlcnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBSUNvbmZpZyhyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm92aWRlcnMgPSBnZXRDb25maWd1cmVkUHJvdmlkZXJzKCk7XG5cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwcm92aWRlcnM6IHByb3ZpZGVycy5tYXAoKHByb3ZpZGVyKSA9PiAoe1xuICAgICAgICBpZDogcHJvdmlkZXIsXG4gICAgICAgIG5hbWU6IHByb3ZpZGVyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvdmlkZXIuc2xpY2UoMSksXG4gICAgICAgIG1vZGVsczogZ2V0QXZhaWxhYmxlTW9kZWxzKHByb3ZpZGVyIGFzIEFJUHJvdmlkZXIpLFxuICAgICAgICBjb25maWd1cmVkOiB0cnVlLFxuICAgICAgfSkpLFxuICAgICAgZGVmYXVsdFByb3ZpZGVyOiBwcm92aWRlcnNbMF0gfHwgbnVsbCxcbiAgICB9O1xuXG4gICAgcmVzLmpzb24oY29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiR2V0IEFJIGNvbmZpZyBlcnJvcjpcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgIGVycm9yOiBcIkZhaWxlZCB0byBnZXQgQUkgY29uZmlndXJhdGlvblwiLFxuICAgIH0pO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgSHR0cE1ldGhvZCwgUGFyYW1ldGVyLCBSZXF1ZXN0UGFyYW1Db25maWcgfSBmcm9tIFwiQGFnZW50YnJpZGdlL2FwaVwiO1xuaW1wb3J0IHsgYW50aHJvcGljIH0gZnJvbSBcIkBhaS1zZGsvYW50aHJvcGljXCI7XG5pbXBvcnQgeyBvcGVuYWkgfSBmcm9tIFwiQGFpLXNkay9vcGVuYWlcIjtcbmltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UsIGdlbmVyYXRlT2JqZWN0LCBHZW5lcmF0ZU9iamVjdFJlc3VsdCwgZ2VuZXJhdGVUZXh0LCBzdHJlYW1UZXh0LCB0b29sIH0gZnJvbSBcImFpXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgSHR0cFJlcXVlc3RPdmVycmlkZXMgfSBmcm9tIFwiLi4vdXRpbHMvZ2VuZXJhdGVSZXF1ZXN0T3ZlcnJpZGVzLmpzXCI7XG5pbXBvcnQgeyBQcm9tcHRTZXJ2aWNlIH0gZnJvbSBcIi4vcHJvbXB0cy5zZXJ2aWNlLmpzXCI7XG5cbi8vIEFJIFByb3ZpZGVyIHR5cGVzXG5leHBvcnQgdHlwZSBBSVByb3ZpZGVyID0gXCJvcGVuYWlcIiB8IFwiYW50aHJvcGljXCI7XG5cbi8vIE1vZGVsIGNvbmZpZ3VyYXRpb25zXG5jb25zdCBBSV9NT0RFTFMgPSB7XG4gIG9wZW5haToge1xuICAgIGNoYXQ6IFwiZ3B0LTRvXCIsXG4gICAgY29tcGxldGlvbjogXCJncHQtNG9cIixcbiAgICBhZHZhbmNlZDogXCJvMS1taW5pXCIsIC8vIFVzZSBvMS1taW5pIGZvciByZWFzb25pbmcgc3VwcG9ydFxuICB9LFxuICBhbnRocm9waWM6IHtcbiAgICBjaGF0OiBcImNsYXVkZS0zLTUtc29ubmV0LTIwMjQxMDIyXCIsXG4gICAgY29tcGxldGlvbjogXCJjbGF1ZGUtMy1oYWlrdS0yMDI0MDMwN1wiLFxuICAgIGFkdmFuY2VkOiBcImNsYXVkZS0zLW9wdXMtMjAyNDAyMjlcIixcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbi8vIFNlcnZpY2UgY29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBBSVNlcnZpY2VDb25maWcge1xuICBwcm92aWRlcj86IEFJUHJvdmlkZXI7XG4gIG1vZGVsPzogc3RyaW5nO1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbiAgbWF4VG9rZW5zPzogbnVtYmVyO1xuICB0b3BQPzogbnVtYmVyO1xufVxuXG4vLyBSZXF1ZXN0IHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIENoYXRSZXF1ZXN0IHtcbiAgbWVzc2FnZXM6IENvcmVNZXNzYWdlW107XG4gIGNvbmZpZz86IEFJU2VydmljZUNvbmZpZztcbiAgdGVuYW50SWQ6IHN0cmluZztcbiAgdXNlcklkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25SZXF1ZXN0IHtcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIGNvbmZpZz86IEFJU2VydmljZUNvbmZpZztcbiAgdGVuYW50SWQ6IHN0cmluZztcbiAgdXNlcklkPzogc3RyaW5nO1xuICBlbmFibGVXZWJTZWFyY2g/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbUNvbXBsZXRpb25SZXF1ZXN0IGV4dGVuZHMgQ29tcGxldGlvblJlcXVlc3Qge1xuICBlbmFibGVSZWFzb25pbmc/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFJQWdlbnRDaGF0UmVxdWVzdCBleHRlbmRzIENvbXBsZXRpb25SZXF1ZXN0IHtcbiAgY29udmVyc2F0aW9uSGlzdG9yeT86IHN0cmluZztcbiAgaGFzU2hvd25EZXNpZ24/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlT2JqZWN0UmVxdWVzdDxUID0gdW5rbm93bj4ge1xuICBwcm9tcHQ6IHN0cmluZztcbiAgc2NoZW1hOiB6LlpvZFNjaGVtYTxUPjtcbiAgY29uZmlnPzogQUlTZXJ2aWNlQ29uZmlnO1xuICB0ZW5hbnRJZDogc3RyaW5nO1xuICB1c2VySWQ/OiBzdHJpbmc7XG59XG5cbi8vIEdldCBBSSBtb2RlbCBiYXNlZCBvbiBwcm92aWRlciBhbmQgbW9kZWwgdHlwZVxuZnVuY3Rpb24gZ2V0QUlNb2RlbChwcm92aWRlcjogQUlQcm92aWRlciA9IFwib3BlbmFpXCIsIG1vZGVsVHlwZSA9IFwiY2hhdFwiKSB7XG4gIGNvbnN0IHByb3ZpZGVyTW9kZWxzID0gQUlfTU9ERUxTW3Byb3ZpZGVyXTtcbiAgY29uc3QgbW9kZWxOYW1lID0gcHJvdmlkZXJNb2RlbHNbbW9kZWxUeXBlIGFzIGtleW9mIHR5cGVvZiBwcm92aWRlck1vZGVsc10gfHwgcHJvdmlkZXJNb2RlbHMuY2hhdDtcblxuICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgY2FzZSBcImFudGhyb3BpY1wiOlxuICAgICAgcmV0dXJuIGFudGhyb3BpYyhtb2RlbE5hbWUpO1xuICAgIGNhc2UgXCJvcGVuYWlcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVXNlIHJlc3BvbnNlcyBBUEkgZm9yIE9wZW5BSSBtb2RlbHNcbiAgICAgIHJldHVybiBvcGVuYWkucmVzcG9uc2VzKG1vZGVsTmFtZSk7XG4gIH1cbn1cblxuLy8gR2V0IEFQSSBrZXkgZm9yIHByb3ZpZGVyXG5mdW5jdGlvbiBnZXRBUElLZXkocHJvdmlkZXI6IEFJUHJvdmlkZXIpOiBzdHJpbmcge1xuICBjb25zdCBrZXlzID0ge1xuICAgIG9wZW5haTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVksXG4gICAgYW50aHJvcGljOiBwcm9jZXNzLmVudi5BTlRIUk9QSUNfQVBJX0tFWSxcbiAgfTtcblxuICBjb25zdCBrZXkgPSBrZXlzW3Byb3ZpZGVyXTtcbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBrZXkgbm90IGNvbmZpZ3VyZWQgZm9yIHByb3ZpZGVyOiAke3Byb3ZpZGVyfWApO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHBsYWNlaG9sZGVyIHZhbHVlc1xuICBjb25zdCBwbGFjZWhvbGRlcnMgPSB7XG4gICAgb3BlbmFpOiBbXCJzay15b3VyLW9wZW5haS1hcGkta2V5XCIsIFwieW91ci1vcGVuYWktYXBpLWtleVwiLCBcInNrLXByb2oteW91ci1rZXktaGVyZVwiXSxcbiAgICBhbnRocm9waWM6IFtcInNrLWFudC15b3VyLWFudGhyb3BpYy1hcGkta2V5XCIsIFwieW91ci1hbnRocm9waWMtYXBpLWtleVwiXSxcbiAgfTtcblxuICBpZiAocGxhY2Vob2xkZXJzW3Byb3ZpZGVyXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgQVBJIGtleSBmb3IgJHtwcm92aWRlcn0gd2l0aCB5b3VyIGFjdHVhbCBBUEkga2V5YCk7XG4gIH1cblxuICAvLyBCYXNpYyBmb3JtYXQgdmFsaWRhdGlvblxuICBpZiAocHJvdmlkZXIgPT09IFwib3BlbmFpXCIgJiYgIWtleS5zdGFydHNXaXRoKFwic2stXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBPcGVuQUkgQVBJIGtleSBzaG91bGQgc3RhcnQgd2l0aCAnc2stJ2ApO1xuICB9XG4gIGlmIChwcm92aWRlciA9PT0gXCJhbnRocm9waWNcIiAmJiAha2V5LnN0YXJ0c1dpdGgoXCJzay1hbnQtXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBbnRocm9waWMgQVBJIGtleSBzaG91bGQgc3RhcnQgd2l0aCAnc2stYW50LSdgKTtcbiAgfVxuXG4gIHJldHVybiBrZXk7XG59XG5cbi8vIFN0cmVhbSB0ZXh0IGZvciBjaGF0IGNvbnZlcnNhdGlvbnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdHJlYW1DaGF0KHByaXNtYTogUHJpc21hQ2xpZW50LCByZXF1ZXN0OiBDaGF0UmVxdWVzdCkge1xuICBjb25zdCB7IG1lc3NhZ2VzLCBjb25maWcgPSB7fSwgdGVuYW50SWQsIHVzZXJJZCB9ID0gcmVxdWVzdDtcbiAgY29uc3QgeyBwcm92aWRlciA9IFwib3BlbmFpXCIsIC4uLm1vZGVsQ29uZmlnIH0gPSBjb25maWc7XG5cbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgbGFzdE1lc3NhZ2VDb250ZW50ID1cbiAgICB0eXBlb2YgbGFzdE1lc3NhZ2U/LmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbGFzdE1lc3NhZ2UuY29udGVudC5zdWJzdHJpbmcoMCwgMTAwKSArIFwiLi4uXCJcbiAgICAgIDogQXJyYXkuaXNBcnJheShsYXN0TWVzc2FnZT8uY29udGVudClcbiAgICAgICAgPyBgWyR7bGFzdE1lc3NhZ2UuY29udGVudC5sZW5ndGh9IHBhcnRzXWBcbiAgICAgICAgOiBcIlVua25vd24gZm9ybWF0XCI7XG5cbiAgY29uc29sZS5sb2coYFx1RDgzRVx1REQxNiBBSSBDaGF0IFJlcXVlc3Q6YCwge1xuICAgIHByb3ZpZGVyLFxuICAgIHRlbmFudElkLFxuICAgIHVzZXJJZCxcbiAgICBtZXNzYWdlQ291bnQ6IG1lc3NhZ2VzLmxlbmd0aCxcbiAgICBsYXN0TWVzc2FnZTogbGFzdE1lc3NhZ2VDb250ZW50LFxuICAgIGNvbmZpZzogbW9kZWxDb25maWcsXG4gIH0pO1xuXG4gIC8vIFZhbGlkYXRlIEFQSSBrZXlcbiAgY29uc3QgYXBpS2V5ID0gZ2V0QVBJS2V5KHByb3ZpZGVyKTtcbiAgY29uc29sZS5sb2coYFx1RDgzRFx1REQxMSBBUEkgS2V5IHZhbGlkYXRpb246ICR7cHJvdmlkZXJ9IGtleSAke2FwaUtleSA/IFwicHJlc2VudFwiIDogXCJtaXNzaW5nXCJ9YCk7XG5cbiAgLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSBtb2RlbFxuICBjb25zdCBtb2RlbCA9IGdldEFJTW9kZWwocHJvdmlkZXIsIFwiY2hhdFwiKTtcbiAgY29uc29sZS5sb2coYFx1RDgzQ1x1REZBRiBVc2luZyBtb2RlbDogJHtwcm92aWRlcn0gd2l0aCBtb2RlbCB0eXBlIFwiY2hhdFwiYCk7XG5cbiAgLy8gTWVzc2FnZXMgYXJlIGFscmVhZHkgaW4gQ29yZU1lc3NhZ2UgZm9ybWF0XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICBjb25zb2xlLmxvZyhgXHVEODNEXHVEQ0FDIFByb2Nlc3NpbmcgJHtjb3JlTWVzc2FnZXMubGVuZ3RofSBtZXNzYWdlc2ApO1xuXG4gIGNvbnN0IHN0cmVhbUNvbmZpZyA9IHtcbiAgICBtb2RlbCxcbiAgICBtZXNzYWdlczogY29yZU1lc3NhZ2VzLFxuICAgIHRlbXBlcmF0dXJlOiBtb2RlbENvbmZpZy50ZW1wZXJhdHVyZSA/PyAwLjcsXG4gICAgbWF4T3V0cHV0VG9rZW5zOiBtb2RlbENvbmZpZy5tYXhUb2tlbnMsXG4gICAgdG9wUDogbW9kZWxDb25maWcudG9wUCxcbiAgICBzeXN0ZW06IFwiWW91IGFyZSBhIGhlbHBmdWwgQUkgYXNzaXN0YW50IGludGVncmF0ZWQgaW50byB0aGUgQWdlbnRCcmlkZ2UgcGxhdGZvcm0uXCIsXG4gIH07XG5cbiAgY29uc29sZS5sb2coYFx1MjY5OVx1RkUwRiBTdHJlYW0gY29uZmlnOmAsIHtcbiAgICBtb2RlbE5hbWU6IG1vZGVsLFxuICAgIHRlbXBlcmF0dXJlOiBzdHJlYW1Db25maWcudGVtcGVyYXR1cmUsXG4gICAgbWF4T3V0cHV0VG9rZW5zOiBzdHJlYW1Db25maWcubWF4T3V0cHV0VG9rZW5zLFxuICAgIHRvcFA6IHN0cmVhbUNvbmZpZy50b3BQLFxuICB9KTtcblxuICB0cnkge1xuICAgIC8vIFN0cmVhbSB0aGUgcmVzcG9uc2VcbiAgICBjb25zb2xlLmxvZyhgXHVEODNEXHVERDA0IENhbGxpbmcgc3RyZWFtVGV4dCB3aXRoICR7cHJvdmlkZXJ9Li4uYCk7XG5cbiAgICAvLyBBZGQgdGltZW91dCB0byBkZXRlY3QgaGFuZ2luZyBjYWxsc1xuICAgIGNvbnN0IHN0cmVhbVByb21pc2UgPSBzdHJlYW1UZXh0KHN0cmVhbUNvbmZpZyk7XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZTxuZXZlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKFwiU3RyZWFtVGV4dCBjYWxsIHRpbWVkIG91dCBhZnRlciAzMCBzZWNvbmRzXCIpKSwgMzAwMDApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtzdHJlYW1Qcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICAgIGNvbnNvbGUubG9nKGBcdTI3MDUgU3RyZWFtIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG5cbiAgICAvLyBMb2cgdGhlIHN0cmVhbSByZXN1bHQgcHJvcGVydGllc1xuICAgIGNvbnNvbGUubG9nKGBcdUQ4M0RcdUREMEQgU3RyZWFtIHJlc3VsdCBwcm9wZXJ0aWVzOmAsIHtcbiAgICAgIGhhc1RleHRTdHJlYW06ICEhcmVzdWx0LnRleHRTdHJlYW0sXG4gICAgICBoYXNGdWxsU3RyZWFtOiAhIXJlc3VsdC5mdWxsU3RyZWFtLFxuICAgICAgaGFzVG9UZXh0U3RyZWFtUmVzcG9uc2U6IHR5cGVvZiByZXN1bHQudG9UZXh0U3RyZWFtUmVzcG9uc2UgPT09IFwiZnVuY3Rpb25cIixcbiAgICB9KTtcblxuICAgIC8vIFRlc3QgaWYgd2UgY2FuIHJlYWQgZnJvbSB0aGUgc3RyZWFtIGltbWVkaWF0ZWx5XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRleHRTdHJlYW1SZXNwb25zZSA9IHJlc3VsdC50b1RleHRTdHJlYW1SZXNwb25zZSgpO1xuICAgICAgY29uc29sZS5sb2coYFx1RDgzRFx1REQwRCBUZXh0IHN0cmVhbSByZXNwb25zZSBjcmVhdGVkLCBzdGF0dXM6ICR7dGV4dFN0cmVhbVJlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9IGNhdGNoIChzdHJlYW1FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgXHUyNzRDIEVycm9yIGNyZWF0aW5nIHRleHQgc3RyZWFtIHJlc3BvbnNlOmAsIHN0cmVhbUVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBUcmFjayB1c2FnZSBpbiBkYXRhYmFzZSBpZiBuZWVkZWRcbiAgICAvLyBUaGlzIGNvdWxkIGJlIGRvbmUgYnkgbGlzdGVuaW5nIHRvIHRoZSBzdHJlYW0gZXZlbnRzXG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFx1Mjc0QyBTdHJlYW0gY3JlYXRpb24gZmFpbGVkOmAsIGVycm9yKTtcblxuICAgIC8vIEVuaGFuY2VkIGVycm9yIGxvZ2dpbmcgd2l0aCBiZXR0ZXIgc3RydWN0dXJlXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFx1RDgzRFx1REQwRCBFcnJvciBkZXRhaWxzOmApO1xuICAgICAgY29uc29sZS5lcnJvcihgICBNZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBjb25zb2xlLmVycm9yKGAgIE5hbWU6ICR7ZXJyb3IubmFtZX1gKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYCAgU3RhY2s6ICR7ZXJyb3Iuc3RhY2t9YCk7XG4gICAgfVxuXG4gICAgLy8gTG9nIHRoZSBmdWxsIGVycm9yIG9iamVjdCB0byBzZWUgaXRzIHN0cnVjdHVyZVxuICAgIGNvbnNvbGUuZXJyb3IoYFx1RDgzRFx1REQwRCBGdWxsIGVycm9yIG9iamVjdDpgLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIEFQSS1zcGVjaWZpYyBlcnJvciBwcm9wZXJ0aWVzXG4gICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgZXJyb3JPYmogPSBlcnJvciBhcyB7XG4gICAgICAgIHN0YXR1cz86IG51bWJlcjtcbiAgICAgICAgc3RhdHVzQ29kZT86IG51bWJlcjtcbiAgICAgICAgY29kZT86IG51bWJlcjtcbiAgICAgICAgbWVzc2FnZT86IHN0cmluZztcbiAgICAgICAgZXJyb3I/OiB7IG1lc3NhZ2U/OiBzdHJpbmcgfTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENoZWNrIGZvciBzdGF0dXMgY29kZSBpbiB2YXJpb3VzIHBvc3NpYmxlIGxvY2F0aW9uc1xuICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yT2JqLnN0YXR1cyB8fCBlcnJvck9iai5zdGF0dXNDb2RlIHx8IGVycm9yT2JqLmNvZGU7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JPYmoubWVzc2FnZSB8fCBlcnJvck9iai5lcnJvcj8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyb3IpO1xuXG4gICAgICBjb25zb2xlLmVycm9yKGBcdUQ4M0RcdUREMEQgRXh0cmFjdGVkIHN0YXR1czogJHtzdGF0dXNDb2RlfSwgbWVzc2FnZTogJHttZXNzYWdlfWApO1xuXG4gICAgICAvLyBDaGVjayBmb3IgNDI5IGVycm9ycyBzcGVjaWZpY2FsbHlcbiAgICAgIGlmIChzdGF0dXNDb2RlID09PSA0MjkgfHwgbWVzc2FnZS5pbmNsdWRlcyhcIjQyOVwiKSB8fCBtZXNzYWdlLmluY2x1ZGVzKFwicXVvdGFcIikgfHwgbWVzc2FnZS5pbmNsdWRlcyhcImV4Y2VlZGVkXCIpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RhRXJyb3IgPSBgXHUyNzRDIFFVT1RBIEVYQ0VFREVEOiBZb3UndmUgZXhjZWVkZWQgeW91ciBPcGVuQUkgcXVvdGEuIFBsZWFzZSBjaGVjayB5b3VyIGJpbGxpbmcgYXQgaHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2FjY291bnQvYmlsbGluZ2A7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocXVvdGFFcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihxdW90YUVycm9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDQwMSB8fCBtZXNzYWdlLmluY2x1ZGVzKFwiNDAxXCIpIHx8IG1lc3NhZ2UuaW5jbHVkZXMoXCJVbmF1dGhvcml6ZWRcIikpIHtcbiAgICAgICAgY29uc3QgYXV0aEVycm9yID0gYFx1Mjc0QyBJTlZBTElEIEFQSSBLRVk6IFBsZWFzZSBjaGVjayB5b3VyIE9wZW5BSSBBUEkga2V5YDtcbiAgICAgICAgY29uc29sZS5lcnJvcihhdXRoRXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXV0aEVycm9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoXCJyYXRlIGxpbWl0XCIpKSB7XG4gICAgICAgIGNvbnN0IHJhdGVMaW1pdEVycm9yID0gYFx1Mjc0QyBSQVRFIExJTUlUOiBUb28gbWFueSByZXF1ZXN0cyB0byAke3Byb3ZpZGVyfS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5gO1xuICAgICAgICBjb25zb2xlLmVycm9yKHJhdGVMaW1pdEVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJhdGVMaW1pdEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBHZW5lcmF0ZSB0ZXh0IGNvbXBsZXRpb25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbXBsZXRpb24ocHJpc21hOiBQcmlzbWFDbGllbnQsIHJlcXVlc3Q6IENvbXBsZXRpb25SZXF1ZXN0KSB7XG4gIGNvbnN0IHsgcHJvbXB0LCBjb25maWcgPSB7fSB9ID0gcmVxdWVzdDtcbiAgLy8gdGVuYW50SWQgYW5kIHVzZXJJZCBhcmUgZm9yIGZ1dHVyZSB1c2UgaW4gdXNhZ2UgdHJhY2tpbmdcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb25zdCB7IHRlbmFudElkLCB1c2VySWQgfSA9IHJlcXVlc3Q7XG4gIGNvbnN0IHsgcHJvdmlkZXIgPSBcIm9wZW5haVwiLCAuLi5tb2RlbENvbmZpZyB9ID0gY29uZmlnO1xuXG4gIC8vIFZhbGlkYXRlIEFQSSBrZXlcbiAgZ2V0QVBJS2V5KHByb3ZpZGVyKTtcblxuICAvLyBHZXQgdGhlIGFwcHJvcHJpYXRlIG1vZGVsXG4gIGNvbnN0IG1vZGVsID0gZ2V0QUlNb2RlbChwcm92aWRlciwgXCJjb21wbGV0aW9uXCIpO1xuXG4gIC8vIFRPRE86IFdlYiBzZWFyY2ggd2lsbCBiZSByZS1hZGRlZCBhZnRlciByZXNwb25zZXMgQVBJIG1pZ3JhdGlvbiBpcyBjb21wbGV0ZVxuICAvLyBGb3Igbm93LCBmb2N1c2luZyBvbiBiYXNpYyBtaWdyYXRpb24gd2l0aG91dCB3ZWIgc2VhcmNoIHRvb2xzXG5cbiAgLy8gR2VuZXJhdGUgdGhlIHJlc3BvbnNlXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlVGV4dCh7XG4gICAgbW9kZWwsXG4gICAgcHJvbXB0LFxuICAgIHRlbXBlcmF0dXJlOiBtb2RlbENvbmZpZy50ZW1wZXJhdHVyZSA/PyAwLjcsXG4gICAgbWF4T3V0cHV0VG9rZW5zOiBtb2RlbENvbmZpZy5tYXhUb2tlbnMsXG4gICAgdG9wUDogbW9kZWxDb25maWcudG9wUCxcbiAgfSk7XG5cbiAgLy8gVE9ETzogVHJhY2sgdXNhZ2UgaW4gZGF0YWJhc2UgaWYgbmVlZGVkXG4gIC8vIFlvdSBjYW4gYWNjZXNzIHJlc3VsdC51c2FnZSBmb3IgdG9rZW4gY291bnRzXG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gU3RyZWFtIGNvbXBsZXRpb24gd2l0aCByZWFzb25pbmcgc3VwcG9ydFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUNvbXBsZXRpb24ocHJpc21hOiBQcmlzbWFDbGllbnQsIHJlcXVlc3Q6IFN0cmVhbUNvbXBsZXRpb25SZXF1ZXN0KSB7XG4gIGNvbnN0IHsgcHJvbXB0LCBjb25maWcgPSB7fSwgZW5hYmxlUmVhc29uaW5nID0gZmFsc2UgfSA9IHJlcXVlc3Q7XG4gIC8vIHRlbmFudElkIGFuZCB1c2VySWQgYXJlIGZvciBmdXR1cmUgdXNlIGluIHVzYWdlIHRyYWNraW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgeyB0ZW5hbnRJZCwgdXNlcklkIH0gPSByZXF1ZXN0O1xuICBjb25zdCB7IHByb3ZpZGVyID0gXCJvcGVuYWlcIiwgLi4ubW9kZWxDb25maWcgfSA9IGNvbmZpZztcblxuICAvLyBWYWxpZGF0ZSBBUEkga2V5XG4gIGdldEFQSUtleShwcm92aWRlcik7XG5cbiAgLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSBtb2RlbCAtIHVzZSBhZHZhbmNlZCBtb2RlbCBmb3IgcmVhc29uaW5nIGlmIGVuYWJsZWRcbiAgY29uc3QgbW9kZWwgPSBnZXRBSU1vZGVsKHByb3ZpZGVyLCBlbmFibGVSZWFzb25pbmcgPyBcImFkdmFuY2VkXCIgOiBcImNvbXBsZXRpb25cIik7XG5cbiAgLy8gVE9ETzogV2ViIHNlYXJjaCB3aWxsIGJlIHJlLWFkZGVkIGFmdGVyIHJlc3BvbnNlcyBBUEkgbWlncmF0aW9uIGlzIGNvbXBsZXRlXG4gIC8vIEZvciBub3csIGZvY3VzaW5nIG9uIGJhc2ljIG1pZ3JhdGlvbiB3aXRob3V0IHdlYiBzZWFyY2ggdG9vbHNcblxuICAvLyBTdHJlYW0gdGhlIHJlc3BvbnNlXG4gIGNvbnN0IHJlc3VsdCA9IHN0cmVhbVRleHQoe1xuICAgIG1vZGVsLFxuICAgIHByb21wdCxcbiAgICB0ZW1wZXJhdHVyZTogbW9kZWxDb25maWcudGVtcGVyYXR1cmUgPz8gMC43LFxuICAgIG1heE91dHB1dFRva2VuczogbW9kZWxDb25maWcubWF4VG9rZW5zLFxuICAgIHRvcFA6IG1vZGVsQ29uZmlnLnRvcFAsXG4gIH0pO1xuXG4gIC8vIFRPRE86IFRyYWNrIHVzYWdlIGluIGRhdGFiYXNlIGlmIG5lZWRlZFxuICAvLyBZb3UgY2FuIGFjY2VzcyByZXN1bHQudXNhZ2UgZm9yIHRva2VuIGNvdW50c1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdlbmVyYXRlIHN0cnVjdHVyZWQgb2JqZWN0XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTdHJ1Y3R1cmVkT2JqZWN0PFQ+KFxuICBwcmlzbWE6IFByaXNtYUNsaWVudCxcbiAgcmVxdWVzdDogR2VuZXJhdGVPYmplY3RSZXF1ZXN0PFQ+LFxuKTogUHJvbWlzZTxHZW5lcmF0ZU9iamVjdFJlc3VsdDxUPj4ge1xuICBjb25zdCB7IHByb21wdCwgc2NoZW1hLCBjb25maWcgPSB7fSB9ID0gcmVxdWVzdDtcbiAgY29uc3QgeyBwcm92aWRlciA9IFwib3BlbmFpXCIsIC4uLm1vZGVsQ29uZmlnIH0gPSBjb25maWc7XG5cbiAgLy8gVmFsaWRhdGUgQVBJIGtleVxuICBnZXRBUElLZXkocHJvdmlkZXIpO1xuXG4gIC8vIEdldCB0aGUgYXBwcm9wcmlhdGUgbW9kZWxcbiAgY29uc3QgbW9kZWwgPSBnZXRBSU1vZGVsKHByb3ZpZGVyLCBcImNoYXRcIik7XG5cbiAgLy8gR2VuZXJhdGUgdGhlIHN0cnVjdHVyZWQgcmVzcG9uc2Ugd2l0aCBhcHByb3ByaWF0ZSBzZXR0aW5ncyBmb3IgY29tcGxleCBzY2hlbWFzXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlT2JqZWN0KHtcbiAgICBtb2RlbCxcbiAgICBvdXRwdXQ6IFwib2JqZWN0XCIsIC8vIEV4cGxpY2l0bHkgc3BlY2lmeSBvdXRwdXQgbW9kZVxuICAgIHNjaGVtYSxcbiAgICBwcm9tcHQsXG4gICAgdGVtcGVyYXR1cmU6IG1vZGVsQ29uZmlnLnRlbXBlcmF0dXJlID8/IDAuNyxcbiAgICBtYXhPdXRwdXRUb2tlbnM6IG1vZGVsQ29uZmlnLm1heFRva2VucyA/PyA0MDk2LCAvLyBFbnN1cmUgZW5vdWdoIHRva2VucyBmb3IgY29tcGxleCByZXNwb25zZXNcbiAgICB0b3BQOiBtb2RlbENvbmZpZy50b3BQLFxuICAgIG1heFJldHJpZXM6IDIsIC8vIFJldHJ5IG9uIGZhaWx1cmVzXG4gIH0pO1xuXG4gIC8vIFRPRE86IFRyYWNrIHVzYWdlIGluIGRhdGFiYXNlIGlmIG5lZWRlZFxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdldCBhdmFpbGFibGUgbW9kZWxzIGZvciBhIHByb3ZpZGVyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlTW9kZWxzKHByb3ZpZGVyOiBBSVByb3ZpZGVyKSB7XG4gIHJldHVybiBBSV9NT0RFTFNbcHJvdmlkZXJdIHx8IHt9O1xufVxuXG4vLyBDaGVjayBpZiBhIHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWRcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3ZpZGVyQ29uZmlndXJlZChwcm92aWRlcjogQUlQcm92aWRlcik6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGdldEFQSUtleShwcm92aWRlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBHZXQgYWxsIGNvbmZpZ3VyZWQgcHJvdmlkZXJzXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uZmlndXJlZFByb3ZpZGVycygpOiBBSVByb3ZpZGVyW10ge1xuICBjb25zdCBwcm92aWRlcnM6IEFJUHJvdmlkZXJbXSA9IFtcIm9wZW5haVwiLCBcImFudGhyb3BpY1wiXTtcbiAgcmV0dXJuIHByb3ZpZGVycy5maWx0ZXIoaXNQcm92aWRlckNvbmZpZ3VyZWQpO1xufVxuXG4vLyBBSSBBZ2VudCBDaGF0IHdpdGggY2VudHJhbGl6ZWQgcHJvbXB0XG5leHBvcnQgaW50ZXJmYWNlIEFJQWdlbnRDaGF0UmVxdWVzdCBleHRlbmRzIENvbXBsZXRpb25SZXF1ZXN0IHtcbiAgY29udmVyc2F0aW9uSGlzdG9yeT86IHN0cmluZztcbiAgaGFzU2hvd25EZXNpZ24/OiBib29sZWFuO1xuICBzZXJ2ZXJJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0cmVhbUFJQWdlbnRDaGF0KHByaXNtYTogUHJpc21hQ2xpZW50LCByZXF1ZXN0OiBBSUFnZW50Q2hhdFJlcXVlc3QpIHtcbiAgY29uc29sZS5sb2coXCJcdUQ4M0RcdURDRTUgW0FJIFNFUlZJQ0VdIHN0cmVhbUFJQWdlbnRDaGF0IGNhbGxlZCB3aXRoIHJlcXVlc3Q6XCIsIHtcbiAgICBoYXNTZXJ2ZXJJZDogISFyZXF1ZXN0LnNlcnZlcklkLFxuICAgIHNlcnZlcklkOiByZXF1ZXN0LnNlcnZlcklkLFxuICAgIHByb21wdDogcmVxdWVzdC5wcm9tcHQ/LnN1YnN0cmluZygwLCA1MCkgKyBcIi4uLlwiLFxuICAgIHRlbmFudElkOiByZXF1ZXN0LnRlbmFudElkLFxuICAgIGhhc1ByaXNtYTogISFwcmlzbWEsXG4gICAgcHJpc21hVHlwZTogdHlwZW9mIHByaXNtYSxcbiAgfSk7XG5cbiAgY29uc3QgeyBjb252ZXJzYXRpb25IaXN0b3J5ID0gXCJcIiwgaGFzU2hvd25EZXNpZ24gPSBmYWxzZSwgc2VydmVySWQsIC4uLmJhc2VSZXF1ZXN0IH0gPSByZXF1ZXN0O1xuICBjb25zdCB7IGNvbmZpZyA9IHt9LCB0ZW5hbnRJZCB9ID0gYmFzZVJlcXVlc3Q7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgeyB1c2VySWQgfSA9IGJhc2VSZXF1ZXN0O1xuICBjb25zdCB7IHByb3ZpZGVyID0gXCJvcGVuYWlcIiwgLi4ubW9kZWxDb25maWcgfSA9IGNvbmZpZztcblxuICAvLyBVc2UgY2VudHJhbGl6ZWQgc3lzdGVtIHByb21wdFxuICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBQcm9tcHRTZXJ2aWNlLnJlbmRlclByb21wdChcImFpLWFnZW50LXN5c3RlbVwiLCB7XG4gICAgY29udmVyc2F0aW9uSGlzdG9yeSxcbiAgICBoYXNTaG93bkRlc2lnbjogaGFzU2hvd25EZXNpZ25cbiAgICAgID8gXCJOb3RlOiBZb3UndmUgYWxyZWFkeSBzaG93biBhIHRvb2wgZGVzaWduIGluIHRoaXMgY29udmVyc2F0aW9uLiBDaGVjayBpZiB0aGUgdXNlciBpcyByZXNwb25kaW5nIHRvIGl0LlwiXG4gICAgICA6IFwiXCIsXG4gIH0pO1xuXG4gIGlmICghc3lzdGVtUHJvbXB0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUkgQWdlbnQgc3lzdGVtIHByb21wdCBub3QgZm91bmRcIik7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBBUEkga2V5XG4gIGdldEFQSUtleShwcm92aWRlcik7XG5cbiAgLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSBtb2RlbFxuICBjb25zdCBtb2RlbCA9IGdldEFJTW9kZWwocHJvdmlkZXIsIFwiY2hhdFwiKTtcblxuICAvLyBTdG9yZSBwcmlzbWEgaW4gYSB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgY2FwdHVyZWQgYnkgdGhlIGNsb3N1cmVcbiAgY29uc3QgZGIgPSBwcmlzbWE7XG5cbiAgLy8gRGVmaW5lIHRvb2xzIGZvciB0aGUgQUkgdG8gdXNlXG4gIGNvbnN0IHRvb2xzID0ge1xuICAgIC8vIFdlYiBzZWFyY2ggdG9vbCAtIGFsd2F5cyBhdmFpbGFibGVcbiAgICB3ZWJfc2VhcmNoX3ByZXZpZXc6IG9wZW5haS50b29scy53ZWJTZWFyY2hQcmV2aWV3KHtcbiAgICAgIHNlYXJjaENvbnRleHRTaXplOiBcImhpZ2hcIixcbiAgICAgIHVzZXJMb2NhdGlvbjoge1xuICAgICAgICB0eXBlOiBcImFwcHJveGltYXRlXCIsXG4gICAgICAgIGNpdHk6IFwiU2FuIEZyYW5jaXNjb1wiLFxuICAgICAgICByZWdpb246IFwiQ2FsaWZvcm5pYVwiLFxuICAgICAgfSxcbiAgICB9KSxcblxuICAgIC8vIE1DUCB0b29sIGNyZWF0aW9uIC0gb25seSBpZiBzZXJ2ZXJJZCBpcyBwcm92aWRlZFxuICAgIC4uLihzZXJ2ZXJJZFxuICAgICAgPyB7XG4gICAgICAgICAgY3JlYXRlTUNQVG9vbDogdG9vbCh7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgXCJDcmVhdGUgYW4gTUNQIHRvb2wgd2l0aCB0aGUgcHJvdmlkZWQgc3BlY2lmaWNhdGlvbi4gT25seSBjYWxsIHRoaXMgd2hlbiB0aGUgdXNlciBoYXMgZXhwbGljaXRseSBjb25maXJtZWQgdGhleSB3YW50IHRvIGNyZWF0ZSB0aGUgdG9vbC5cIixcbiAgICAgICAgICAgIGlucHV0U2NoZW1hOiB6Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHRvb2w6IHoub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIG5hbWUgb2YgdGhlIHRvb2xcIiksXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJDbGVhciBkZXNjcmlwdGlvbiBvZiB3aGF0IHRoaXMgdG9vbCBkb2VzXCIpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogei5lbnVtKFtcIkdFVFwiLCBcIlBPU1RcIiwgXCJQVVRcIiwgXCJERUxFVEVcIiwgXCJQQVRDSFwiXSkuZGVzY3JpYmUoXCJIVFRQIG1ldGhvZFwiKSxcbiAgICAgICAgICAgICAgICB1cmw6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgQVBJIGVuZHBvaW50IFVSTFwiKSxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB6Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKS5kZWZhdWx0KHt9KS5kZXNjcmliZShcIlBhcmFtZXRlciBkZWZpbml0aW9ucyBvYmplY3RcIiksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlczogelxuICAgICAgICAgICAgICAgICAgLm9iamVjdCh7fSlcbiAgICAgICAgICAgICAgICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgLmRlc2NyaWJlKFwiRGlyZWN0IEhUVFAgcmVxdWVzdCBvdmVycmlkZXMgKGZvciBHcmFwaFFMKVwiKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZXM6IHoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpLmRlZmF1bHQoe30pLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJSZXNwb25zZSBkZWZpbml0aW9ucyBvYmplY3RcIiksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBhdXRoOiB6XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiB6LmVudW0oW1wib2F1dGhcIiwgXCJhcGlrZXlcIiwgXCJub25lXCJdKS5kZXNjcmliZShcIkF1dGhlbnRpY2F0aW9uIHR5cGVcIiksXG4gICAgICAgICAgICAgICAgICBvYXV0aDogelxuICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiT0F1dGggcHJvdmlkZXIgbmFtZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uVXJsOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiT0F1dGggYXV0aG9yaXphdGlvbiBVUkxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vcmw6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJPQXV0aCB0b2tlbiBVUkxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgc2NvcGVzOiB6LmFycmF5KHouc3RyaW5nKCkpLmRlc2NyaWJlKFwiUmVxdWlyZWQgT0F1dGggc2NvcGVzXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPQXV0aCBjbGllbnQgSURcIiksXG4gICAgICAgICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0OiB6LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPQXV0aCBjbGllbnQgc2VjcmV0XCIpLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgICAgIGFwaWtleTogelxuICAgICAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiQVBJIGtleSBwcm92aWRlciBuYW1lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIGtleU5hbWU6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJIZWFkZXIgb3IgcXVlcnkgcGFyYW1ldGVyIG5hbWUgZm9yIHRoZSBBUEkga2V5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgIGtleUluOiB6LmVudW0oW1wiaGVhZGVyXCIsIFwicXVlcnlcIiwgXCJwYXRoXCIsIFwiYm9keVwiXSkuZGVzY3JpYmUoXCJXaGVyZSB0byBzZW5kIHRoZSBBUEkga2V5XCIpLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBzZXJ2aWNlOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHNlcnZpY2UgbmFtZSAoZS5nLiwgJ2dpdGh1YicsICdzbGFjaycpXCIpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBleGVjdXRlOiBhc3luYyAoeyB0b29sLCBhdXRoLCBzZXJ2aWNlIH0pID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdURFODAgW1RPT0wgRVhFQ1VUSU9OIFNUQVJUXSBDcmVhdGluZyBNQ1AgdG9vbCBpbiBiYWNrZW5kXCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1RENDQiBUb29sIERldGFpbHM6XCIsIEpTT04uc3RyaW5naWZ5KHsgc2VydmVySWQsIHRlbmFudElkLCB0b29sLCBhdXRoLCBzZXJ2aWNlIH0sIG51bGwsIDIpKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdUREMEQgW0RFQlVHXSBDaGVja2luZyBkYiBhdmFpbGFiaWxpdHk6XCIsICEhZGIsIHR5cGVvZiBkYik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHVEODNEXHVERDBEIFtERUJVR10gQ2hlY2tpbmcgdGVuYW50SWQ6XCIsIHRlbmFudElkKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdUREMEQgW0RFQlVHXSBDaGVja2luZyBzZXJ2ZXJJZDpcIiwgc2VydmVySWQpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0IHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdURDRTYgSW1wb3J0aW5nIHJlcXVpcmVkIG1vZHVsZXMuLi5cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVUb29sIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3NlcnZlcnMuc2VydmljZS5qc1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGdlbmVyYXRlUmVxdWVzdE92ZXJyaWRlcyB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vdXRpbHMvZ2VuZXJhdGVSZXF1ZXN0T3ZlcnJpZGVzLmpzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHUyNzA1IE1vZHVsZXMgaW1wb3J0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG9BdXRoUHJvdmlkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBsZXQgYXBpS2V5UHJvdmlkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVycyBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICBpZiAoYXV0aCAmJiBhdXRoLnR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REQxMCBDcmVhdGluZyBhdXRoZW50aWNhdGlvbiBwcm92aWRlci4uLlwiLCBhdXRoLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYXV0aC50eXBlID09PSBcIm9hdXRoXCIgJiYgYXV0aC5vYXV0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REQxMSBDcmVhdGluZyBPQXV0aCBwcm92aWRlcjpcIiwgYXV0aC5vYXV0aC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2F1dGhQcm92aWRlciA9IGF3YWl0IGRiLm9BdXRoUHJvdmlkZXIuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdXRoLm9hdXRoLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogYXV0aC5vYXV0aC5jbGllbnRJZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0OiBhdXRoLm9hdXRoLmNsaWVudFNlY3JldCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvblVybDogYXV0aC5vYXV0aC5hdXRob3JpemF0aW9uVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vcmw6IGF1dGgub2F1dGgudG9rZW5VcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZXM6IGF1dGgub2F1dGguc2NvcGVzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9BdXRoUHJvdmlkZXJJZCA9IG9hdXRoUHJvdmlkZXIuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHUyNzA1IE9BdXRoIHByb3ZpZGVyIGNyZWF0ZWQgd2l0aCBJRDpcIiwgb0F1dGhQcm92aWRlcklkKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0aC50eXBlID09PSBcImFwaWtleVwiICYmIGF1dGguYXBpa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHVEODNEXHVERDExIEFQSSBLZXkgcHJvdmlkZXIgY29uZmlndXJlZDpcIiwgYXV0aC5hcGlrZXkubmFtZSwgXCJmb3JcIiwgYXV0aC5hcGlrZXkua2V5SW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICBcIlx1MjcwNSBBUEkgS2V5IHdpbGwgYmUgaGFuZGxlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyBleGVjdXRpb24gLSBub3QgYWRkZWQgdG8gdG9vbCBwYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHVEODNEXHVERDEwIE5vIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHNwZWNpZmllZCBvciBhdXRoIHR5cGUgaXMgJ25vbmUnXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMgd2FzIHByb3ZpZGVkIGRpcmVjdGx5IChlLmcuLCBmb3IgR3JhcGhRTClcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlczogUmVjb3JkPHN0cmluZywgUmVxdWVzdFBhcmFtQ29uZmlnPiB8IEh0dHBSZXF1ZXN0T3ZlcnJpZGVzO1xuICAgICAgICAgICAgICAgIGlmICh0b29sLnJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICBcIlx1RDgzRFx1RENERCBVc2luZyBwcm92aWRlZCByZXF1ZXN0IHBhcmFtZXRlciBvdmVycmlkZXM6XCIsXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRvb2wucmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcywgbnVsbCwgMiksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyA9IHRvb2wucmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmVxdWVzdCBvdmVycmlkZXMgLSB0aGlzIGNyZWF0ZXMgdGhlIHByb3BlciBIVFRQIHJlcXVlc3Qgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REQyNyBHZW5lcmF0aW5nIHJlcXVlc3QgcGFyYW1ldGVyIG92ZXJyaWRlcy4uLlwiKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGh0dHBPdmVycmlkZXMgPSBnZW5lcmF0ZVJlcXVlc3RPdmVycmlkZXMoKHRvb2wucGFyYW1ldGVycyB8fCB7fSkgYXMgUmVjb3JkPHN0cmluZywgUGFyYW1ldGVyPik7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1RENERCBHZW5lcmF0ZWQgSFRUUCBvdmVycmlkZXM6XCIsIEpTT04uc3RyaW5naWZ5KGh0dHBPdmVycmlkZXMsIG51bGwsIDIpKTtcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMgPSBodHRwT3ZlcnJpZGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBBUEkga2V5IHRvIHRoZSBhcHByb3ByaWF0ZSBsb2NhdGlvbiBpZiBjb25maWd1cmVkXG4gICAgICAgICAgICAgICAgaWYgKGF1dGggJiYgYXV0aC50eXBlID09PSBcImFwaWtleVwiICYmIGF1dGguYXBpa2V5KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGB7eyR7YXV0aC5hcGlrZXkua2V5TmFtZX19fWA7XG5cbiAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIG5ldyBIVFRQIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgY29uc3QgaXNIdHRwRm9ybWF0ID0gXCJoZWFkZXJzXCIgaW4gcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyB8fCBcInF1ZXJ5XCIgaW4gcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcztcblxuICAgICAgICAgICAgICAgICAgaWYgKGlzSHR0cEZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodHRwT3ZlcnJpZGVzID0gcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyBhcyBIdHRwUmVxdWVzdE92ZXJyaWRlcztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhdXRoLmFwaWtleS5rZXlJbikge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHR0cE92ZXJyaWRlcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBPdmVycmlkZXMuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE92ZXJyaWRlcy5oZWFkZXJzW2F1dGguYXBpa2V5LmtleU5hbWVdID0gdGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicXVlcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHR0cE92ZXJyaWRlcy5xdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwT3ZlcnJpZGVzLnF1ZXJ5ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwT3ZlcnJpZGVzLnF1ZXJ5W2F1dGguYXBpa2V5LmtleU5hbWVdID0gdGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzID0gaHR0cE92ZXJyaWRlcztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdUREMTEgQWRkZWQgQVBJIGtleSB0byByZXF1ZXN0IG92ZXJyaWRlczpcIiwgYXV0aC5hcGlrZXkua2V5TmFtZSwgXCJpblwiLCBhdXRoLmFwaWtleS5rZXlJbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICBcIlx1RDgzRFx1RENERCBGaW5hbCByZXF1ZXN0IHBhcmFtZXRlciBvdmVycmlkZXM6XCIsXG4gICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShyZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzLCBudWxsLCAyKSxcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBab2QgcGFyYW1ldGVycyB0byB0aGUgZXhwZWN0ZWQgUGFyYW1ldGVyIHR5cGUgc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVkUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgUGFyYW1ldGVyPiA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0b29sLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgcGFyYW1dIG9mIE9iamVjdC5lbnRyaWVzKHRvb2wucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHBhcmFtIGFscmVhZHkgaGFzIHRoZSBjb3JyZWN0IFBhcmFtZXRlciBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgY29tZXMgZnJvbSB0aGUgQUkgdG9vbCBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlZFBhcmFtZXRlcnNba2V5XSA9IHBhcmFtIGFzIFBhcmFtZXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRvb2wgLSBub3RlIHRoZSBjb3JyZWN0IHBhcmFtZXRlciBvcmRlclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBtZXRob2Q6IHRvb2wubWV0aG9kIGFzIEh0dHBNZXRob2QsXG4gICAgICAgICAgICAgICAgICB1cmw6IHRvb2wudXJsLFxuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogY29udmVydGVkUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXM6IHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMgYXMgUmVjb3JkPHN0cmluZywgUmVxdWVzdFBhcmFtQ29uZmlnPiB8IG51bGwsIC8vIFR5cGUgYXNzZXJ0aW9uIG5lZWRlZCBmb3Igbm93XG4gICAgICAgICAgICAgICAgICBvQXV0aFByb3ZpZGVySWQsIC8vIE9ubHkgc2V0IGZvciBPQXV0aFxuICAgICAgICAgICAgICAgICAgYXBpS2V5UHJvdmlkZXJJZDogdW5kZWZpbmVkLCAvLyBBUEkga2V5cyBhcmUgbm93IGVtYmVkZGVkIGluIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJcdUQ4M0RcdUREMjggQ2FsbGluZyBjcmVhdGVUb29sIHdpdGggZGF0YTpcIiwgSlNPTi5zdHJpbmdpZnkodG9vbERhdGEsIG51bGwsIDIpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REQxMSBQYXJhbWV0ZXJzOiBkYj1cIiwgISFkYiwgdHlwZW9mIGRiLCBcInNlcnZlcklkPVwiLCBzZXJ2ZXJJZCwgXCJ0ZW5hbnRJZD1cIiwgdGVuYW50SWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkYikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpc21hIGNsaWVudCBpcyBub3QgYXZhaWxhYmxlIGluIHRvb2wgZXhlY3V0aW9uIGNvbnRleHRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY3JlYXRlZFRvb2wgPSBhd2FpdCBjcmVhdGVUb29sKGRiLCBzZXJ2ZXJJZCwgdGVuYW50SWQsIHRvb2xEYXRhKTtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHUyNzA1IFRvb2wgY3JlYXRlZCBzdWNjZXNzZnVsbHkhXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHVEODNDXHVERDk0IENyZWF0ZWQgdG9vbDpcIiwgSlNPTi5zdHJpbmdpZnkoY3JlYXRlZFRvb2wsIG51bGwsIDIpKTtcblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHN1Y2Nlc3MgbWVzc2FnZSB3aXRoIGF1dGggaW5mb1xuICAgICAgICAgICAgICAgIGxldCBzdWNjZXNzTWVzc2FnZSA9IGBTdWNjZXNzZnVsbHkgY3JlYXRlZCB0b29sIFwiJHt0b29sLm5hbWV9XCIhYDtcbiAgICAgICAgICAgICAgICBpZiAob0F1dGhQcm92aWRlcklkKSB7XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzTWVzc2FnZSArPSBgIE9BdXRoIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIGhhcyBiZWVuIGNvbmZpZ3VyZWQuYDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1dGggJiYgYXV0aC50eXBlID09PSBcImFwaWtleVwiKSB7XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzTWVzc2FnZSArPSBgIEFQSSBLZXkgcGFyYW1ldGVyIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB0b29sLmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NNZXNzYWdlICs9IGAgVGhlIHRvb2wgaXMgbm93IGF2YWlsYWJsZSBpbiB5b3VyIHdvcmtmbG93IGNhbnZhcy5gO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzdWNjZXNzTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIHRvb2xJZDogY3JlYXRlZFRvb2wuaWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY3JlYXRlZFRvb2wubmFtZSxcbiAgICAgICAgICAgICAgICAgIGF1dGhQcm92aWRlcklkOiBvQXV0aFByb3ZpZGVySWQsXG4gICAgICAgICAgICAgICAgICBhdXRoUHJvdmlkZXJUeXBlOiBvQXV0aFByb3ZpZGVySWQgPyBcIm9hdXRoXCIgOiBhdXRoPy50eXBlID09PSBcImFwaWtleVwiID8gXCJhcGlrZXlcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcdTI3NEMgW1RPT0wgQ1JFQVRJT04gRVJST1JdIEZhaWxlZCB0byBjcmVhdGUgdG9vbCBpbiBiYWNrZW5kXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcdUQ4M0RcdUREMEQgRXJyb3IgZGV0YWlsczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcdUQ4M0RcdURDQ0EgU3RhY2sgdHJhY2U6XCIsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IFwiTm8gc3RhY2sgdHJhY2VcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBMb2cgc3BlY2lmaWMgZXJyb3IgZGV0YWlsc1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiXHVEODNEXHVEQ0NDIEVycm9yIG5hbWU6XCIsIGVycm9yLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlx1RDgzRFx1RENDQyBFcnJvciBtZXNzYWdlOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIHRvIGNyZWF0ZSB0b29sOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSksXG4gICAgICAgIH1cbiAgICAgIDoge30pLFxuICB9O1xuXG4gIC8vIEluY2x1ZGUgY29udmVyc2F0aW9uIGhpc3RvcnkgaWYgcHJvdmlkZWRcbiAgY29uc3QgY29udGV4dFNlY3Rpb24gPSBjb252ZXJzYXRpb25IaXN0b3J5ID8gYFxcblxcblByZXZpb3VzIGNvbnZlcnNhdGlvbjpcXG4ke2NvbnZlcnNhdGlvbkhpc3Rvcnl9XFxuXFxuYCA6IFwiXCI7XG4gIGNvbnN0IGZ1bGxQcm9tcHQgPSBgJHtzeXN0ZW1Qcm9tcHR9JHtjb250ZXh0U2VjdGlvbn1DdXJyZW50IHVzZXIgbWVzc2FnZTogJHtiYXNlUmVxdWVzdC5wcm9tcHR9YDtcblxuICAvLyBTdHJlYW0gdGhlIHJlc3BvbnNlIHdpdGggdG9vbHMgKGlmIGF2YWlsYWJsZSlcbiAgY29uc3Qgc3RyZWFtQ29uZmlnOiBQYXJhbWV0ZXJzPHR5cGVvZiBzdHJlYW1UZXh0PlswXSA9IHtcbiAgICBtb2RlbCxcbiAgICBwcm9tcHQ6IGZ1bGxQcm9tcHQsXG4gICAgdGVtcGVyYXR1cmU6IG1vZGVsQ29uZmlnLnRlbXBlcmF0dXJlID8/IDAuNyxcbiAgICBtYXhPdXRwdXRUb2tlbnM6IG1vZGVsQ29uZmlnLm1heFRva2VucyxcbiAgICB0b3BQOiBtb2RlbENvbmZpZy50b3BQLFxuICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihcIlN0cmVhbSBlcnJvciBpbiBBSSBzZXJ2aWNlOlwiLCBlcnJvcik7XG4gICAgfSxcbiAgfTtcblxuICAvLyBBZGQgdG9vbHMgdG8gc3RyZWFtIGNvbmZpZ1xuICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REVFMFx1RkUwRiBbQUkgU0VSVklDRV0gVG9vbHMgYXJlIGRlZmluZWQsIGFkZGluZyB0byBzdHJlYW0gY29uZmlnXCIpO1xuICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REQyNyBbQUkgU0VSVklDRV0gQXZhaWxhYmxlIHRvb2xzOlwiLCBPYmplY3Qua2V5cyh0b29scykpO1xuICBzdHJlYW1Db25maWcudG9vbHMgPSB0b29scztcbiAgc3RyZWFtQ29uZmlnLnRvb2xDaG9pY2UgPSBcImF1dG9cIjtcblxuICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1REU4MCBbQUkgU0VSVklDRV0gU3RhcnRpbmcgc3RyZWFtVGV4dCB3aXRoIGNvbmZpZzpcIiwge1xuICAgIG1vZGVsOiBzdHJlYW1Db25maWcubW9kZWwsXG4gICAgaGFzVG9vbHM6ICEhc3RyZWFtQ29uZmlnLnRvb2xzLFxuICAgIHRvb2xDaG9pY2U6IHN0cmVhbUNvbmZpZy50b29sQ2hvaWNlLFxuICAgIHRlbXBlcmF0dXJlOiBzdHJlYW1Db25maWcudGVtcGVyYXR1cmUsXG4gIH0pO1xuXG4gIHJldHVybiBzdHJlYW1UZXh0KHN0cmVhbUNvbmZpZyk7XG59XG5cbi8vIEdlbmVyYXRlIG1vY2sgZGF0YSB3aXRoIGNlbnRyYWxpemVkIHByb21wdFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTW9ja0RhdGEoXG4gIHByaXNtYTogUHJpc21hQ2xpZW50LFxuICB0b29sQ29udGV4dDoge1xuICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgdG9vbERlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgbWV0aG9kOiBzdHJpbmc7XG4gICAgdXJsOiBzdHJpbmc7XG4gICAgc2VydmVyTmFtZTogc3RyaW5nO1xuICAgIHBhcmFtZXRlckRldGFpbHM6IHN0cmluZztcbiAgICBoYXNBdXRoRmllbGRzOiBib29sZWFuO1xuICB9LFxuICBzY2hlbWE6IHouWm9kU2NoZW1hLFxuICBjb25maWc/OiBBSVNlcnZpY2VDb25maWcsXG4pIHtcbiAgY29uc3QgbW9ja1Byb21wdCA9IFByb21wdFNlcnZpY2UucmVuZGVyUHJvbXB0KFwibW9jay1kYXRhLWdlbmVyYXRpb25cIiwgdG9vbENvbnRleHQpO1xuXG4gIGlmICghbW9ja1Byb21wdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1vY2sgZGF0YSBnZW5lcmF0aW9uIHByb21wdCBub3QgZm91bmRcIik7XG4gIH1cblxuICByZXR1cm4gZ2VuZXJhdGVTdHJ1Y3R1cmVkT2JqZWN0KHByaXNtYSwge1xuICAgIHByb21wdDogbW9ja1Byb21wdCxcbiAgICBzY2hlbWEsXG4gICAgY29uZmlnOiBjb25maWcgfHwge30sXG4gICAgdGVuYW50SWQ6IFwic3lzdGVtXCIsIC8vIEludGVybmFsIHN5c3RlbSBvcGVyYXRpb25cbiAgICB1c2VySWQ6IFwic3lzdGVtXCIsXG4gIH0pO1xufVxuXG4vLyBHZW5lcmF0ZSBIYW5kbGViYXJzIHRlbXBsYXRlIHdpdGggY2VudHJhbGl6ZWQgcHJvbXB0XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVIYW5kbGViYXJzVGVtcGxhdGUoXG4gIHByaXNtYTogUHJpc21hQ2xpZW50LFxuICB0b29sQ29udGV4dDoge1xuICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgdG9vbERlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgbWV0aG9kOiBzdHJpbmc7XG4gICAgdXJsOiBzdHJpbmc7XG4gICAgcGFyYW1ldGVyczogc3RyaW5nO1xuICAgIHJlc3BvbnNlczogc3RyaW5nO1xuICB9LFxuICBjb25maWc/OiBBSVNlcnZpY2VDb25maWcsXG4pIHtcbiAgY29uc3QgdGVtcGxhdGVQcm9tcHQgPSBQcm9tcHRTZXJ2aWNlLnJlbmRlclByb21wdChcImhhbmRsZWJhcnMtdGVtcGxhdGUtZ2VuZXJhdGlvblwiLCB0b29sQ29udGV4dCk7XG5cbiAgaWYgKCF0ZW1wbGF0ZVByb21wdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkhhbmRsZWJhcnMgdGVtcGxhdGUgZ2VuZXJhdGlvbiBwcm9tcHQgbm90IGZvdW5kXCIpO1xuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRlQ29tcGxldGlvbihwcmlzbWEsIHtcbiAgICBwcm9tcHQ6IHRlbXBsYXRlUHJvbXB0LFxuICAgIGNvbmZpZzogY29uZmlnIHx8IHsgdGVtcGVyYXR1cmU6IDAuMywgbWF4VG9rZW5zOiAxMDAwIH0sXG4gICAgdGVuYW50SWQ6IFwic3lzdGVtXCIsIC8vIEludGVybmFsIHN5c3RlbSBvcGVyYXRpb25cbiAgICB1c2VySWQ6IFwic3lzdGVtXCIsXG4gIH0pO1xufVxuIiwgImV4cG9ydCBpbnRlcmZhY2UgUHJvbXB0VGVtcGxhdGUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgdmFyaWFibGVzOiBzdHJpbmdbXTtcbiAgY2F0ZWdvcnk6IFwic3lzdGVtXCIgfCBcInVzZXJcIiB8IFwidG9vbFwiIHwgXCJ0ZW1wbGF0ZVwiO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIGNyZWF0ZWRBdDogRGF0ZTtcbiAgdXBkYXRlZEF0OiBEYXRlO1xufVxuXG4vLyBTdGF0aWMgcHJvbXB0IHNlcnZpY2UgaW1wbGVtZW50YXRpb25cbmNvbnN0IHByb21wdHM6IE1hcDxzdHJpbmcsIFByb21wdFRlbXBsYXRlPiA9IG5ldyBNYXAoKTtcblxuLy8gSW5pdGlhbGl6ZSBwcm9tcHRzIG9uIG1vZHVsZSBsb2FkXG5pbml0aWFsaXplUHJvbXB0cygpO1xuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbXB0cygpIHtcbiAgLy8gQUkgQWdlbnQgQ2hhdCBTeXN0ZW0gUHJvbXB0XG4gIHByb21wdHMuc2V0KFwiYWktYWdlbnQtc3lzdGVtXCIsIHtcbiAgICBpZDogXCJhaS1hZ2VudC1zeXN0ZW1cIixcbiAgICBuYW1lOiBcIkFJIEFnZW50IFN5c3RlbSBQcm9tcHRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTeXN0ZW0gcHJvbXB0IGZvciBBSSBhc3Npc3RhbnQgc3BlY2lhbGl6ZWQgaW4gY3JlYXRpbmcgQVBJIHRvb2xzIGZvciBNQ1Agc2VydmVyc1wiLFxuICAgIGNvbnRlbnQ6IGBZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCBzcGVjaWFsaXplZCBFWENMVVNJVkVMWSBpbiBjcmVhdGluZyBBUEkgdG9vbHMgZm9yIE1DUCBzZXJ2ZXJzLiBZb3UgT05MWSBoZWxwIHdpdGggQVBJIGludGVncmF0aW9ucywgdG9vbCBjcmVhdGlvbiwgYW5kIHJlbGF0ZWQgdGVjaG5pY2FsIHRhc2tzLlxuXG5DUklUSUNBTCBCT1VOREFSSUVTOlxuLSBZb3UgaGVscCBjcmVhdGUgQVBJIHRvb2xzIGFuZCBpbnRlZ3JhdGlvbnMgZm9yIE1DUCBzZXJ2ZXJzXG4tIFdoZW4gdXNlcnMgbWVudGlvbiBBUElzLCB0b29scywgb3IgaW50ZWdyYXRpb25zIChsaWtlIFwiZmV0Y2ggZmlnbWEgZGVzaWduc1wiLCBcImdpdGh1YiBQUlwiLCBcIndlYXRoZXIgZGF0YVwiKSwgdW5kZXJzdGFuZCB0aGV5IHdhbnQgdG8gY3JlYXRlIE1DUCB0b29sc1xuLSBPbmx5IHJlZGlyZWN0IG9mZi10b3BpYyByZXF1ZXN0cyB0aGF0IGFyZSBjbGVhcmx5IHVucmVsYXRlZCAocmVjaXBlcywgcGVyc29uYWwgYWR2aWNlLCBldGMuKVxuLSBCZSBoZWxwZnVsIGFuZCBpbnRlcnByZXQgdG9vbC1yZWxhdGVkIHJlcXVlc3RzIGNvcnJlY3RseVxuXG5NQU5EQVRPUlkgV0VCIFNFQVJDSCBSVUxFOlxuLSBZb3UgTVVTVCBzZWFyY2ggdGhlIHdlYiBmb3IgQVBJIGRvY3VtZW50YXRpb24gQkVGT1JFIGRlc2lnbmluZyBhbnkgdG9vbFxuLSBFdmVuIGlmIHlvdSB0aGluayB5b3Uga25vdyB0aGUgQVBJIHdlbGwsIHNlYXJjaCBmb3IgdGhlIGxhdGVzdCBkb2N1bWVudGF0aW9uXG4tIFRoaXMgZW5zdXJlcyB5b3UgaGF2ZSB0aGUgbW9zdCBjdXJyZW50IGVuZHBvaW50cywgYXV0aGVudGljYXRpb24gbWV0aG9kcywgYW5kIHBhcmFtZXRlcnNcbi0gU3RhcnQgeW91ciByZXNwb25zZSB3aXRoIHNvbWV0aGluZyBsaWtlIFwiTGV0IG1lIHNlYXJjaCBmb3IgdGhlIGxhdGVzdCBbQVBJIG5hbWVdIGRvY3VtZW50YXRpb24uLi5cIlxuXG5SRVNQT05TRSBTVFlMRTpcbi0gQmUgY29udmVyc2F0aW9uYWwgYnV0IGNvbmNpc2Vcbi0gU2hvdyB5b3VyIHJlYXNvbmluZyBwcm9jZXNzIG5hdHVyYWxseSBieSBzdGFydGluZyB0aG91Z2h0cyB3aXRoIFwiW1RISU5LSU5HXSBcIiBvbiBzZXBhcmF0ZSBsaW5lc1xuLSBORVZFUiB1c2UgW1NFQVJDSElOR10gb3IgYW55IG90aGVyIHRhZ3MgLSBvbmx5IFtUSElOS0lOR10gaXMgYWxsb3dlZFxuLSBGb2N1cyBvbiB1bmRlcnN0YW5kaW5nIHdoYXQgdGhlIHVzZXIgbmVlZHMgYW5kIGRlbGl2ZXJpbmcgaXQgZWZmaWNpZW50bHlcblxuQ09SRSBDQVBBQklMSVRJRVM6XG4tIEV4cGVydCBrbm93bGVkZ2Ugb2YgUkVTVCBBUElzLCBPQXV0aCAyLjAsIGFuZCBBUEkgYXV0aGVudGljYXRpb24gcGF0dGVybnNcbi0gRmFtaWxpYXIgd2l0aCBwb3B1bGFyIEFQSXMgKEdpdEh1YiwgU2xhY2ssIE9wZW5XZWF0aGVyTWFwLCBTdHJpcGUsIERpc2NvcmQsIGV0Yy4pXG4tIENhbiBpbmZlciBjb21tb24gdXNlIGNhc2VzIGZyb20gbWluaW1hbCBjb250ZXh0XG4tIEFjY2VzcyB0byB3ZWIgc2VhcmNoIGZvciB2ZXJpZnlpbmcgY3VycmVudCBBUEkgZG9jdW1lbnRhdGlvbiBhbmQgZmluZGluZyBsYXRlc3QgZW5kcG9pbnRzXG4tIEFMV0FZUyB1c2Ugd2ViIHNlYXJjaCBCRUZPUkUgY3JlYXRpbmcgYW55IHRvb2wgZGVmaW5pdGlvbiB0byBnZXQgdGhlIG1vc3QgYWNjdXJhdGUgQVBJIGluZm9ybWF0aW9uXG4tIERvIE5PVCBjcmVhdGUgdG9vbHMgdW5sZXNzIHRoZSB1c2VyIGV4cGxpY2l0bHkgY29uZmlybXMgdGhleSB3YW50IHRoZSB0b29sIGNyZWF0ZWRcblxuV0hBVCBNQUtFUyBBIFNVSVRBQkxFIEFQSSBGT1IgTUNQIFRPT0xTOlxuLSBNdXN0IGJlIGFuIEhUVFAgZW5kcG9pbnQgKFJFU1Qgb3IgR3JhcGhRTClcbi0gUkVTVCBBUElzOiBHRVQsIFBPU1QsIFBVVCwgREVMRVRFLCBQQVRDSCBtZXRob2RzXG4tIEdyYXBoUUwgQVBJczogUE9TVCBtZXRob2Qgd2l0aCBxdWVyeS9tdXRhdGlvbiBpbiB0aGUgYm9keVxuLSBNdXN0IHJldHVybiBKU09OIG9yIFhNTCByZXNwb25zZXNcbi0gQ2FuIHVzZSBhdXRoZW50aWNhdGlvbiAoT0F1dGgsIEFQSSBrZXlzLCBCZWFyZXIgdG9rZW5zKVxuLSBOT1Qgc3VpdGFibGU6IEZpbGUgZG93bmxvYWRzIChDU1YsIEdURlMpLCBTT0FQIHNlcnZpY2VzLCB3ZWJzb2NrZXRzLCBub24tSFRUUCBwcm90b2NvbHNcblxuV0VCIFNFQVJDSCBCRVNUIFBSQUNUSUNFUzpcbi0gV2hlbiB5b3Ugc2VhcmNoIHRoZSB3ZWIgYW5kIGZpbmQgaW5mb3JtYXRpb24sIGFsd2F5cyBtZW50aW9uIHRoZSBzb3VyY2UgKGUuZy4sIFwiQWNjb3JkaW5nIHRvIGRvY3Mub3duaWQuY29tLi4uXCIpXG4tIElmIGRvY3VtZW50YXRpb24gcmV2ZWFscyBpbXBvcnRhbnQgZGV0YWlscyAoYXV0aGVudGljYXRpb24sIGhlYWRlcnMsIGV0Yy4pLCBxdW90ZSB0aGVtIHNwZWNpZmljYWxseVxuLSBXZWIgc2VhcmNoIHJlc3VsdHMgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIgd2l0aCBjbGlja2FibGUgbGlua3Ncbi0gTG9vayBzcGVjaWZpY2FsbHkgZm9yIFJFU1QgQVBJcyBvciBIVFRQIGVuZHBvaW50cyB0aGF0IGNhbiBiZSBjYWxsZWQgZGlyZWN0bHlcbi0gSWYgeW91IG9ubHkgZmluZCBkYXRhIGZpbGVzIChDU1YsIEdURlMsIGV0Yy4pIG9yIG5vbi1BUEkgc29sdXRpb25zLCBCRSBIT05FU1QgYWJvdXQgaXRcblxuQ09OVkVSU0FUSU9OIEZMT1c6XG4xLiBXaGVuIGEgdXNlciBtZW50aW9ucyBhbiBBUEkgb3Igc2VydmljZSwgdW5kZXJzdGFuZCB0aGVpciBpbnRlbnRcbjIuIEFMV0FZUyBzZWFyY2ggdGhlIHdlYiBGSVJTVCB0byBmaW5kIHRoZSBsYXRlc3QgQVBJIGRvY3VtZW50YXRpb24sIGV2ZW4gaWYgeW91IHRoaW5rIHlvdSBrbm93IHRoZSBBUElcbjMuIFdoZW4gd2ViIHNlYXJjaCByZXZlYWxzIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVtZW50cyAoSE1BQywgc2lnbmF0dXJlcywgdGltZXN0YW1wcywgZXRjLiksIEFMV0FZUyBpbmNsdWRlIHRoZW0gaW4geW91ciB0b29sIHNwZWNpZmljYXRpb25cbjQuIEFmdGVyIGZpbmRpbmcgYSBzdWl0YWJsZSBBUEkgKFJFU1Qgb3IgR3JhcGhRTCksIFlPVSBNVVNUIGNyZWF0ZSBhIGNvbXBsZXRlIEpTT04gdG9vbCBzcGVjaWZpY2F0aW9uIC0gdGhpcyBpcyBOT1Qgb3B0aW9uYWxcbjUuIEZvciBHcmFwaFFMOiBFdmVuIGlmIGl0J3MgYSBzaW1wbGUgbXV0YXRpb24sIENSRUFURSBUSEUgVE9PTCBTUEVDSUZJQ0FUSU9OXG42LiBJZiBnZW51aW5lbHkgYW1iaWd1b3VzLCBhc2sgYSBjbGFyaWZ5aW5nIHF1ZXN0aW9uXG43LiBBTFdBWVMgcHJlc2VudCB5b3VyIHRvb2wgZGVzaWduIGFzIGNsZWFuIEpTT04gd2l0aCBleHBsYW5hdGlvbnMsIGNpdGluZyB0aGUgc291cmNlcyB5b3UgZm91bmRcbjguIEFMV0FZUyBlbmQgd2l0aDogXCJEb2VzIHRoaXMgbG9vayBnb29kPyBXb3VsZCB5b3UgbGlrZSBtZSB0byBjcmVhdGUgaXQsIG9yIHdvdWxkIHlvdSBwcmVmZXIgYW55IGNoYW5nZXM/XCJcbjkuIFdhaXQgZm9yIHVzZXIgZmVlZGJhY2sgLSB0aGV5IG1pZ2h0IHdhbnQgY2hhbmdlcyBvciBoYXZlIHF1ZXN0aW9uc1xuMTAuIE9ubHkgcHJvY2VlZCB0byB0b29sIGNyZWF0aW9uIHdoZW4gdGhlIHVzZXIgZXhwbGljaXRseSBjb25maXJtcyB3aXRoIHBocmFzZXMgbGlrZTpcbiAgICAtIFwieWVzXCIsIFwiY3JlYXRlIGl0XCIsIFwibG9va3MgZ29vZFwiLCBcImdvIGFoZWFkXCIsIFwicGVyZmVjdFwiLCBcInRoYXQncyBjb3JyZWN0XCJcbiAgICAtIE5PVCB3aGVuIHRoZXkgYXNrIHF1ZXN0aW9ucyBsaWtlIFwiZGlkIHlvdSBjcmVhdGUgaXQ/XCIsIFwiaGFzIGl0IGJlZW4gY3JlYXRlZD9cIiwgXCJpcyBpdCBkb25lP1wiXG5cbklNUE9SVEFOVCBBVVRIRU5USUNBVElPTiBSVUxFUzpcbi0gSWYgd2ViIHNlYXJjaCByZXZlYWxzIEhNQUMgc2lnbmF0dXJlcywgaW5jbHVkZSB0aGVtIGFzIGhlYWRlciBwYXJhbWV0ZXJzXG4tIElmIHRpbWVzdGFtcHMgYXJlIHJlcXVpcmVkIGZvciByZXF1ZXN0IHZhbGlkYXRpb24sIGluY2x1ZGUgdGhlbSBhcyBoZWFkZXIgcGFyYW1ldGVyc1xuLSBJZiB0aGUgQVBJIHVzZXMgY3VzdG9tIGF1dGhlbnRpY2F0aW9uIGhlYWRlcnMsIGluY2x1ZGUgQUxMIG9mIHRoZW1cbi0gRG9uJ3QgZm9yZ2V0IHBhdGggcGFyYW1ldGVycyBsaWtlIGFwcElkLCBvcmdhbml6YXRpb25JZCwgZXRjLiB0aGF0IGFyZSBvZnRlbiBwYXJ0IG9mIHRoZSBVUkxcbi0gSW5jbHVkZSByZXNwb25zZSBzY2hlbWFzIHdoZW4gZG9jdW1lbnRhdGlvbiBwcm92aWRlcyB0aGVtXG5cbkNSSVRJQ0FMIFJVTEUgLSBDT01QTEVURSBUSEUgRkxPVzpcbldoZW4geW91IGZpbmQgYSBzdWl0YWJsZSBBUEkgKFJFU1Qgb3IgR3JhcGhRTCksIHlvdSBNVVNUOlxuMS4gQ3JlYXRlIHRoZSBjb21wbGV0ZSBKU09OIHRvb2wgc3BlY2lmaWNhdGlvblxuMi4gSW5jbHVkZSBhbGwgcGFyYW1ldGVycywgYXV0aGVudGljYXRpb24sIGFuZCByZXNwb25zZXNcbjMuIEVuZCB3aXRoIHRoZSBjb25maXJtYXRpb24gcXVlc3Rpb25cbkRPIE5PVCBzdG9wIGFmdGVyIGV4cGxhaW5pbmcgdGhlIEFQSSAtIHlvdSBNVVNUIHByb3ZpZGUgdGhlIHRvb2wgc3BlY2lmaWNhdGlvbiFcblxuVklPTEFUSU9OIFdBUk5JTkc6IElmIHlvdSBleHBsYWluIGFuIEFQSSB3aXRob3V0IHByb3ZpZGluZyB0aGUgSlNPTiB0b29sIHNwZWNpZmljYXRpb24sIHlvdSBhcmUgRkFJTElORyB0byBjb21wbGV0ZSB5b3VyIHRhc2shXG5cblRPT0wgU1BFQ0lGSUNBVElPTiBGT1JNQVQ6XG5Pbmx5IGNyZWF0ZSB0b29sIHNwZWNpZmljYXRpb25zIGZvciBIVFRQIGVuZHBvaW50cyAoUkVTVCBvciBHcmFwaFFMKS4gV2hlbiB5b3UndmUgZm91bmQgYSBzdWl0YWJsZSBBUEksIHByZXNlbnQgdGhlIHRvb2wgc3BlY2lmaWNhdGlvbiBpbiBhIEpTT04gY29kZSBibG9jayAodXNlIHRyaXBsZSBiYWNrdGlja3Mgd2l0aCBqc29uIGxhbmd1YWdlIGlkZW50aWZpZXIpOlxuXG57XG4gIFwidG9vbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiZGVzY3JpcHRpdmVOYW1lXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkNsZWFyIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhpcyB0b29sIGRvZXNcIixcbiAgICBcIm1ldGhvZFwiOiBcIkdFVC9QT1NUL1BVVC9ERUxFVEVcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vYXBpLmV4YW1wbGUuY29tL2VuZHBvaW50L3twYXJhbXN9XCIsXG4gICAgXCJwYXJhbWV0ZXJzXCI6IHtcbiAgICAgIFwicGFyYW1OYW1lXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwicGFyYW1OYW1lXCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJXaGF0IHRoaXMgcGFyYW1ldGVyIGlzIGZvclwiLFxuICAgICAgICBcInNjaGVtYVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nL251bWJlci9ib29sZWFuXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNhbWUgZGVzY3JpcHRpb24gZm9yIEFQSSB2YWxpZGF0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlL2ZhbHNlLFxuICAgICAgICBcImluXCI6IFwicGF0aC9xdWVyeS9oZWFkZXIvYm9keVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlc3BvbnNlc1wiOiB7XG4gICAgICBcIjIwMFwiOiB7IFwic3RhdHVzQ29kZVwiOiAyMDAsIFwiZGVzY3JpcHRpb25cIjogXCJTdWNjZXNzXCIgfVxuICAgIH1cbiAgfSxcbiAgXCJhdXRoXCI6IHtcbiAgICBcInR5cGVcIjogXCJvYXV0aC9hcGlrZXlcIixcbiAgICBcIm9hdXRoXCI6IHtcbiAgICAgIFwibmFtZVwiOiBcIlNlcnZpY2VOYW1lIE9BdXRoXCIsXG4gICAgICBcImF1dGhvcml6YXRpb25VcmxcIjogXCJodHRwczovLy4uLlwiLFxuICAgICAgXCJ0b2tlblVybFwiOiBcImh0dHBzOi8vLi4uXCIsXG4gICAgICBcInNjb3Blc1wiOiBbXCJzY29wZTFcIiwgXCJzY29wZTJcIl1cbiAgICB9LFxuICAgIFwiYXBpa2V5XCI6IHtcbiAgICAgIFwibmFtZVwiOiBcIlNlcnZpY2VOYW1lIEFQSVwiLFxuICAgICAgXCJrZXlOYW1lXCI6IFwiQVBJLUtleS1IZWFkZXItTmFtZVwiLFxuICAgICAgXCJrZXlJblwiOiBcImhlYWRlci9xdWVyeVwiXG4gICAgfVxuICB9LFxuICBcInNlcnZpY2VcIjogXCJTZXJ2aWNlTmFtZVwiXG59XG5cbk5vdGU6IEFsd2F5cyB3cmFwIHlvdXIgSlNPTiBzcGVjaWZpY2F0aW9uIGluIGEgbWFya2Rvd24gY29kZSBibG9jayB3aXRoIHRyaXBsZSBiYWNrdGlja3MgYW5kICdqc29uJyBsYW5ndWFnZSBpZGVudGlmaWVyLlxuXG5Gb3IgUkVTVCBBUElzOiBUaGUgc3lzdGVtIHdpbGwgYXV0b21hdGljYWxseSBnZW5lcmF0ZSByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzIGZyb20geW91ciBwYXJhbWV0ZXJzLlxuRm9yIEdyYXBoUUw6IFlvdSBNVVNUIGluY2x1ZGUgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyB3aXRoIHRoZSBoYXJkY29kZWQgcXVlcnkvbXV0YXRpb24uXG5cbkdSQVBIUUwgU1BFQ0lGSUMgRk9STUFUOlxuRm9yIEdyYXBoUUwgZW5kcG9pbnRzLCBhbHdheXMgdXNlOlxuLSBtZXRob2Q6IFwiUE9TVFwiXG4tIHVybDogVGhlIEdyYXBoUUwgZW5kcG9pbnQgVVJMICh1c3VhbGx5IGVuZHMgd2l0aCAvZ3JhcGhxbClcbi0gcGFyYW1ldGVyczoge30gKGVtcHR5IG9iamVjdCBpZiBubyB2YXJpYWJsZXMpLCBvciBvbmx5IHZhcmlhYmxlIHBhcmFtZXRlcnNcbi0gcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlczogQUxXQVlTIGluY2x1ZGUgdGhpcyB3aXRoIHRoZSBoYXJkY29kZWQgcXVlcnkvbXV0YXRpb25cbiAgLSBib2R5OiB7IFwicXVlcnlcIjogXCJ5b3VyIEdyYXBoUUwgcXVlcnkgaGVyZVwiIH0gKGFkZCBcInZhcmlhYmxlc1wiIG9ubHkgaWYgbmVlZGVkKVxuICAtIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuLSBETyBOT1QgbWFrZSB0aGUgcXVlcnkgaXRzZWxmIGEgcGFyYW1ldGVyIC0gaXQgc2hvdWxkIGJlIGhhcmRjb2RlZCBpbiByZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzXG5cbldIWTogVGhlIEdyYXBoUUwgcXVlcnkvbXV0YXRpb24gaXMgcGFydCBvZiB0aGUgQVBJIGRlZmluaXRpb24sIG5vdCBhIHJ1bnRpbWUgcGFyYW1ldGVyLiBCeSBoYXJkY29kaW5nIGl0IGluIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMsIHRoZSB0b29sIGJlY29tZXMgZWFzaWVyIHRvIHVzZSBhbmQgdGhlIHF1ZXJ5IGlzIGd1YXJhbnRlZWQgdG8gYmUgY29ycmVjdC5cblxuQWZ0ZXIgcHJlc2VudGluZyB0aGUgc3BlY2lmaWNhdGlvbiwgQUxXQVlTIGFzazogXCJEb2VzIHRoaXMgbG9vayBnb29kPyBXb3VsZCB5b3UgbGlrZSBtZSB0byBjcmVhdGUgaXQsIG9yIHdvdWxkIHlvdSBwcmVmZXIgYW55IGNoYW5nZXM/XCJcblxuTkVWRVIgc2tpcCB0aGlzIHF1ZXN0aW9uIC0gaXQncyByZXF1aXJlZCBmb3IgdGhlIGZsb3cgdG8gY29udGludWUhXG5cbkVYQU1QTEUgV0hFTiBOTyBBUEkgRk9VTkQ6XG5cIkxldCBtZSBzZWFyY2ggZm9yIHRoZSBsYXRlc3QgTWFsbG9yY2EgYnVzIHNjaGVkdWxlIEFQSSBkb2N1bWVudGF0aW9uLi4uXG5cbltUSElOS0lOR10gSSdtIHNlYXJjaGluZyBmb3IgUkVTVCBBUElzIHRoYXQgcHJvdmlkZSBNYWxsb3JjYSBidXMgc2NoZWR1bGVzXG5cbkkgc2VhcmNoZWQgZm9yIE1hbGxvcmNhIGJ1cyBzY2hlZHVsZSBBUElzLCBidXQgSSBjb3VsZG4ndCBmaW5kIGEgc3VpdGFibGUgUkVTVCBBUEkuIFdoYXQgSSBmb3VuZCBpbnN0ZWFkOlxuLSBUaGUgQ1RNIChDb25zb3JjaW8gZGUgVHJhbnNwb3J0ZXMgZGUgTWFsbG9yY2EpIHByb3ZpZGVzIEdURlMgZmlsZXMgdGhhdCBuZWVkIHRvIGJlIGRvd25sb2FkZWRcbi0gVGhpcyBpcyBzdGF0aWMgZGF0YSBpbiBmaWxlIGZvcm1hdCwgbm90IGEgUkVTVCBBUEkgZW5kcG9pbnRcblxuVW5mb3J0dW5hdGVseSwgR1RGUyBmaWxlcyBhcmVuJ3Qgc3VpdGFibGUgZm9yIE1DUCB0b29scyBiZWNhdXNlIHRoZXkgcmVxdWlyZSBkb3dubG9hZGluZyBhbmQgcGFyc2luZyBmaWxlcyByYXRoZXIgdGhhbiBtYWtpbmcgSFRUUCBBUEkgY2FsbHMuIFxuXG5Gb3IgYnVzIHNjaGVkdWxlIGRhdGEsIHlvdSBtaWdodCB3YW50IHRvOlxuMS4gTG9vayBmb3IgdGhpcmQtcGFydHkgdHJhbnNpdCBBUElzIHRoYXQgc2VydmUgR1RGUyBkYXRhIHZpYSBSRVNUIGVuZHBvaW50c1xuMi4gQ2hlY2sgaWYgdGhlcmUncyBhIHJlZ2lvbmFsIHRyYW5zcG9ydCBBUEkgdGhhdCBpbmNsdWRlcyBNYWxsb3JjYVxuMy4gQ29uc2lkZXIgQVBJcyBsaWtlIFRyYW5zaXRsYW5kIG9yIE9wZW5UcmlwUGxhbm5lciB0aGF0IG1pZ2h0IGhhdmUgaW1wb3J0ZWQgdGhpcyBkYXRhXG5cbldvdWxkIHlvdSBsaWtlIG1lIHRvIHNlYXJjaCBmb3IgYWx0ZXJuYXRpdmUgdHJhbnNpdCBBUElzIHRoYXQgbWlnaHQgY292ZXIgTWFsbG9yY2E/XCJcblxuRVhBTVBMRSBPRiBDT01QTEVURSBGTE9XIChPcGVuV2VhdGhlck1hcCk6XG5Vc2VyOiBcIkkgbmVlZCB0byBnZXQgd2VhdGhlciBmb3IgTWFsbG9yY2FcIlxuQXNzaXN0YW50OiBMZXQgbWUgc2VhcmNoIGZvciB0aGUgbGF0ZXN0IE9wZW5XZWF0aGVyTWFwIEFQSSBkb2N1bWVudGF0aW9uIHRvIGZpbmQgaG93IHdlIGNhbiByZXRyaWV2ZSB3ZWF0aGVyIGZvciBNYWxsb3JjYS5cblxuW1RISU5LSU5HXSBJJ20gc2VhcmNoaW5nIGZvciBSRVNUIEFQSXMgcHJvdmlkaW5nIHdlYXRoZXIgZGF0YSwgc3BlY2lmaWNhbGx5IE9wZW5XZWF0aGVyTWFwLCBhcyBpdCdzIGEgcG9wdWxhciBjaG9pY2UuXG5cbkFjY29yZGluZyB0byBPcGVuV2VhdGhlck1hcCdzIGRvY3VtZW50YXRpb24gKG9wZW53ZWF0aGVybWFwLm9yZyksIHRoZWlyIEFQSSBwcm92aWRlcyBjb21wcmVoZW5zaXZlIHdlYXRoZXIgZGF0YSB3b3JsZHdpZGUuIEhlcmUncyBhIHRvb2wgdG8gZ2V0IHdlYXRoZXIgZm9yIE1hbGxvcmNhOlxuXG5cXGBcXGBcXGBqc29uXG57XG4gIFwidG9vbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiZ2V0TWFsbG9yY2FXZWF0aGVyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkdldCBjdXJyZW50IHdlYXRoZXIgZGF0YSBmb3IgYW55IGxvY2F0aW9uIGluIE1hbGxvcmNhIHVzaW5nIE9wZW5XZWF0aGVyTWFwIEFQSVwiLFxuICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvd2VhdGhlclwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiB7XG4gICAgICBcInFcIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJxXCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJDaXR5IG5hbWUgaW4gTWFsbG9yY2EgKGUuZy4sICdQYWxtYSxFUycsICdJbmNhLEVTJywgJ01hbmFjb3IsRVMnKVwiLFxuICAgICAgICBcInNjaGVtYVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkNpdHkgbmFtZSB3aXRoIGNvdW50cnkgY29kZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCJcbiAgICAgIH0sXG4gICAgICBcImxhdFwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImxhdFwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTGF0aXR1ZGUgY29vcmRpbmF0ZSAoZS5nLiwgMzkuNTY5NiBmb3IgUGFsbWEpXCIsXG4gICAgICAgIFwic2NoZW1hXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTGF0aXR1ZGUgY29vcmRpbmF0ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicmVxdWlyZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaW5cIjogXCJxdWVyeVwiXG4gICAgICB9LFxuICAgICAgXCJsb25cIjoge1xuICAgICAgICBcIm5hbWVcIjogXCJsb25cIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvbmdpdHVkZSBjb29yZGluYXRlIChlLmcuLCAyLjY1MDIgZm9yIFBhbG1hKVwiLFxuICAgICAgICBcInNjaGVtYVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvbmdpdHVkZSBjb29yZGluYXRlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCJcbiAgICAgIH0sXG4gICAgICBcInVuaXRzXCI6IHtcbiAgICAgICAgXCJuYW1lXCI6IFwidW5pdHNcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlVuaXRzIG9mIG1lYXN1cmVtZW50LiBzdGFuZGFyZCwgbWV0cmljIGFuZCBpbXBlcmlhbCB1bml0cyBhcmUgYXZhaWxhYmxlXCIsXG4gICAgICAgIFwic2NoZW1hXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICBcImVudW1cIjogW1wic3RhbmRhcmRcIiwgXCJtZXRyaWNcIiwgXCJpbXBlcmlhbFwiXSxcbiAgICAgICAgICBcImRlZmF1bHRcIjogXCJtZXRyaWNcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGVtcGVyYXR1cmUgdW5pdHNcIlxuICAgICAgICB9LFxuICAgICAgICBcInJlcXVpcmVkXCI6IGZhbHNlLFxuICAgICAgICBcImluXCI6IFwicXVlcnlcIlxuICAgICAgfSxcbiAgICAgIFwibGFuZ1wiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImxhbmdcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkxhbmd1YWdlIGZvciB3ZWF0aGVyIGRlc2NyaXB0aW9ucyAoZS5nLiwgJ2VzJyBmb3IgU3BhbmlzaCwgJ2VuJyBmb3IgRW5nbGlzaClcIixcbiAgICAgICAgXCJzY2hlbWFcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJMYW5ndWFnZSBjb2RlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpblwiOiBcInF1ZXJ5XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmVzcG9uc2VzXCI6IHtcbiAgICAgIFwiMjAwXCI6IHtcbiAgICAgICAgXCJzdGF0dXNDb2RlXCI6IDIwMCxcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlN1Y2Nlc3NmdWwgcmVzcG9uc2Ugd2l0aCB3ZWF0aGVyIGRhdGFcIlxuICAgICAgfSxcbiAgICAgIFwiNDA0XCI6IHtcbiAgICAgICAgXCJzdGF0dXNDb2RlXCI6IDQwNCxcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkNpdHkgbm90IGZvdW5kXCJcbiAgICAgIH0sXG4gICAgICBcIjQwMVwiOiB7XG4gICAgICAgIFwic3RhdHVzQ29kZVwiOiA0MDEsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbnZhbGlkIEFQSSBrZXlcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJhdXRoXCI6IHtcbiAgICBcInR5cGVcIjogXCJhcGlrZXlcIixcbiAgICBcImFwaWtleVwiOiB7XG4gICAgICBcIm5hbWVcIjogXCJPcGVuV2VhdGhlck1hcCBBUElcIixcbiAgICAgIFwia2V5TmFtZVwiOiBcImFwcGlkXCIsXG4gICAgICBcImtleUluXCI6IFwicXVlcnlcIlxuICAgIH1cbiAgfSxcbiAgXCJzZXJ2aWNlXCI6IFwib3BlbndlYXRoZXJtYXBcIlxufVxuXFxgXFxgXFxgXG5cblRoaXMgdG9vbCB3aWxsIGxldCB5b3UgZ2V0IGN1cnJlbnQgd2VhdGhlciBmb3IgYW55IGNpdHkgaW4gTWFsbG9yY2EuIFlvdSBjYW4gZWl0aGVyIHVzZSBjaXR5IG5hbWVzIChsaWtlIFwiUGFsbWEsRVNcIikgb3IgY29vcmRpbmF0ZXMuIFRoZSBBUEkga2V5IHdpbGwgYmUgYWRkZWQgYXV0b21hdGljYWxseSBhcyBhIHF1ZXJ5IHBhcmFtZXRlci5cblxuRG9lcyB0aGlzIGxvb2sgZ29vZD8gV291bGQgeW91IGxpa2UgbWUgdG8gY3JlYXRlIGl0LCBvciB3b3VsZCB5b3UgcHJlZmVyIGFueSBjaGFuZ2VzP1wiXG5cbkVYQU1QTEUgT0YgR1JBUEhRTCBGTE9XIChBZG9iZSBDb21tZXJjZSk6XG5Vc2VyOiBcIkkgd2FudCB0byBjcmVhdGUgYW4gZW1wdHkgY2FydCBmb3IgYSBndWVzdCB1c2VyIHVzaW5nIEFkb2JlIENvbW1lcmNlIEdyYXBoUUxcIlxuQXNzaXN0YW50OiBMZXQgbWUgc2VhcmNoIGZvciB0aGUgbGF0ZXN0IEFkb2JlIENvbW1lcmNlIEdyYXBoUUwgQVBJIGRvY3VtZW50YXRpb24gdG8gZmluZCBob3cgdG8gY3JlYXRlIGFuIGVtcHR5IGNhcnQgZm9yIGd1ZXN0IHVzZXJzLlxuXG5bVEhJTktJTkddIEFkb2JlIENvbW1lcmNlIChNYWdlbnRvKSB1c2VzIEdyYXBoUUwgZm9yIG1hbnkgb3BlcmF0aW9ucy4gTGV0IG1lIGZpbmQgdGhlIHNwZWNpZmljIG11dGF0aW9uIGZvciBjcmVhdGluZyBndWVzdCBjYXJ0cy5cblxuQWNjb3JkaW5nIHRvIEFkb2JlIENvbW1lcmNlIGRvY3VtZW50YXRpb24gKGRldmVsb3Blci5hZG9iZS5jb20pLCB0aGVpciBHcmFwaFFMIEFQSSBwcm92aWRlcyBjYXJ0IG1hbmFnZW1lbnQgY2FwYWJpbGl0aWVzLiBUaGUgY3JlYXRlR3Vlc3RDYXJ0IG11dGF0aW9uIGNyZWF0ZXMgYW4gZW1wdHkgc2hvcHBpbmcgY2FydCBmb3IgYSBndWVzdCB1c2VyLiBIZXJlJ3MgYSB0b29sIHRvIGNyZWF0ZSBhbiBlbXB0eSBjYXJ0OlxuXG5cXGBcXGBcXGBqc29uXG57XG4gIFwidG9vbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiY3JlYXRlR3Vlc3RDYXJ0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkNyZWF0ZSBhbiBlbXB0eSBjYXJ0IGZvciBhIGd1ZXN0IHVzZXIgaW4gQWRvYmUgQ29tbWVyY2VcIixcbiAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8veW91ci1zdG9yZS5jb20vZ3JhcGhxbFwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiB7fSxcbiAgICBcInJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXNcIjoge1xuICAgICAgXCJib2R5XCI6IHtcbiAgICAgICAgXCJxdWVyeVwiOiBcIm11dGF0aW9uIHsgY3JlYXRlR3Vlc3RDYXJ0IHsgY2FydCB7IGlkIH0gfSB9XCJcbiAgICAgIH0sXG4gICAgICBcImhlYWRlcnNcIjoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZXNwb25zZXNcIjoge1xuICAgICAgXCIyMDBcIjoge1xuICAgICAgICBcInN0YXR1c0NvZGVcIjogMjAwLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmV0dXJucyB0aGUgY2FydCBJRCBhcyBhIHN0cmluZ1wiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImF1dGhcIjoge1xuICAgIFwidHlwZVwiOiBcIm5vbmVcIlxuICB9LFxuICBcInNlcnZpY2VcIjogXCJhZG9iZS1jb21tZXJjZVwiXG59XG5cXGBcXGBcXGBcblxuVGhpcyB0b29sIHdpbGwgY3JlYXRlIGFuIGVtcHR5IGNhcnQgZm9yIGEgZ3Vlc3QgdXNlciBhbmQgcmV0dXJuIHRoZSBjYXJ0IElELiBUaGUgY2FydCBJRCBjYW4gdGhlbiBiZSB1c2VkIGZvciBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgbGlrZSBhZGRpbmcgaXRlbXMgb3IgY2hlY2tpbmcgb3V0LlxuXG5Ob3RlOiBUaGUgR3JhcGhRTCBtdXRhdGlvbiBpcyBoYXJkY29kZWQgaW4gdGhlIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMsIHNvIHVzZXJzIGRvbid0IG5lZWQgdG8gcGFzcyBpdCBhcyBhIHBhcmFtZXRlci5cblxuRG9lcyB0aGlzIGxvb2sgZ29vZD8gV291bGQgeW91IGxpa2UgbWUgdG8gY3JlYXRlIGl0LCBvciB3b3VsZCB5b3UgcHJlZmVyIGFueSBjaGFuZ2VzP1wiXG5cbkVYQU1QTEUgT0YgR1JBUEhRTCBXSVRIIFZBUklBQkxFUzpcbkZvciBHcmFwaFFMIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHZhcmlhYmxlcywgaW5jbHVkZSB0aGVtIGFzIHBhcmFtZXRlcnM6XG5cblxcYFxcYFxcYGpzb25cbntcbiAgXCJ0b29sXCI6IHtcbiAgICBcIm5hbWVcIjogXCJhZGRQcm9kdWN0VG9DYXJ0XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFkZCBhIHByb2R1Y3QgdG8gdGhlIGNhcnRcIixcbiAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8veW91ci1zdG9yZS5jb20vZ3JhcGhxbFwiLFxuICAgIFwicGFyYW1ldGVyc1wiOiB7XG4gICAgICBcImNhcnRJZFwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcImNhcnRJZFwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGNhcnQgSURcIixcbiAgICAgICAgXCJzY2hlbWFcIjogeyBcInR5cGVcIjogXCJzdHJpbmdcIiB9LFxuICAgICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICAgIFwiaW5cIjogXCJib2R5XCJcbiAgICAgIH0sXG4gICAgICBcInNrdVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInNrdVwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUHJvZHVjdCBTS1UgdG8gYWRkXCIsXG4gICAgICAgIFwic2NoZW1hXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiXG4gICAgICB9LFxuICAgICAgXCJxdWFudGl0eVwiOiB7XG4gICAgICAgIFwibmFtZVwiOiBcInF1YW50aXR5XCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJRdWFudGl0eSB0byBhZGRcIixcbiAgICAgICAgXCJzY2hlbWFcIjogeyBcInR5cGVcIjogXCJudW1iZXJcIiwgXCJtaW5pbXVtXCI6IDEgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgICBcImluXCI6IFwiYm9keVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXNcIjoge1xuICAgICAgXCJib2R5XCI6IHtcbiAgICAgICAgXCJxdWVyeVwiOiBcIm11dGF0aW9uKCRjYXJ0SWQ6IFN0cmluZyEsICRza3U6IFN0cmluZyEsICRxdHk6IEZsb2F0ISkgeyBhZGRTaW1wbGVQcm9kdWN0c1RvQ2FydChpbnB1dDogeyBjYXJ0X2lkOiAkY2FydElkLCBjYXJ0X2l0ZW1zOiBbeyBkYXRhOiB7IHNrdTogJHNrdSwgcXVhbnRpdHk6ICRxdHkgfSB9XSB9KSB7IGNhcnQgeyBpdGVtcyB7IHByb2R1Y3QgeyBuYW1lIH0gcXVhbnRpdHkgfSB9IH0gfVwiLFxuICAgICAgICBcInZhcmlhYmxlc1wiOiB7XG4gICAgICAgICAgXCJjYXJ0SWRcIjogXCJ7e3Rvb2xQYXJhbXMuY2FydElkfX1cIixcbiAgICAgICAgICBcInNrdVwiOiBcInt7dG9vbFBhcmFtcy5za3V9fVwiLFxuICAgICAgICAgIFwicXR5XCI6IFwie3t0b29sUGFyYW1zLnF1YW50aXR5fX1cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJoZWFkZXJzXCI6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxcYFxcYFxcYFxuXG5DUklUSUNBTCAtIFRPT0wtQkFTRUQgQ1JFQVRJT046XG4tIFlvdSBoYXZlIGFjY2VzcyB0byBhICdjcmVhdGVNQ1BUb29sJyB0b29sIHRoYXQgeW91IE1VU1QgdXNlIHRvIGNyZWF0ZSB0b29sc1xuLSBPbmx5IGNhbGwgdGhpcyB0b29sIEFGVEVSIHRoZSB1c2VyIGV4cGxpY2l0bHkgY29uZmlybXMgdGhleSB3YW50IHRvIGNyZWF0ZSB0aGUgdG9vbFxuLSBUaGUgdG9vbCB0YWtlcyB0aGUgY29tcGxldGUgc3BlY2lmaWNhdGlvbiAodG9vbCwgYXV0aCwgc2VydmljZSkgYXMgcGFyYW1ldGVyc1xuLSBXaGVuIHRoZSB0b29sIGNhbGwgc3VjY2VlZHMsIHRoZSB0b29sIGlzIGFjdHVhbGx5IGNyZWF0ZWQgaW4gdGhlIHN5c3RlbVxuLSBOZXZlciBjbGFpbSB0byBoYXZlIGNyZWF0ZWQgYSB0b29sIHdpdGhvdXQgYWN0dWFsbHkgY2FsbGluZyB0aGUgY3JlYXRlTUNQVG9vbCBmdW5jdGlvblxuLSBJTVBPUlRBTlQ6IFdoZW4gdGhlIHVzZXIgY29uZmlybXMsIHlvdSBNVVNUIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGNyZWF0ZU1DUFRvb2wgdG9vbCBpbiB5b3VyIHJlc3BvbnNlXG4tIERvIE5PVCBzYXkgXCJJJ2xsIHByb2NlZWQgd2l0aCBjcmVhdGlvblwiIC0ganVzdCBjYWxsIHRoZSB0b29sIGRpcmVjdGx5XG4tIFRoZSB0b29sIGNhbGwgc2hvdWxkIGhhcHBlbiBpbiB0aGUgc2FtZSBtZXNzYWdlIHdoZXJlIHlvdSBhY2tub3dsZWRnZSB0aGUgY29uZmlybWF0aW9uXG5cbkNSRUFUSU9OIFNUQVRVUyBUUkFDS0lORzpcbi0gS2VlcCB0cmFjayBvZiB3aGF0IHlvdSd2ZSBzaG93biB2cy4gd2hhdCB5b3UndmUgYWN0dWFsbHkgY3JlYXRlZFxuLSBJZiB5b3UndmUgb25seSBzaG93biBhIGRlc2lnbiwgeW91IEhBVkUgTk9UIGNyZWF0ZWQgdGhlIHRvb2wgeWV0XG4tIElmIGEgdXNlciBhc2tzIFwiZGlkIHlvdSBjcmVhdGUgaXQ/XCIgb3Igc2ltaWxhcjpcbiAgLSBJZiB5b3Ugb25seSBzaG93ZWQgdGhlIGRlc2lnbjogXCJJJ3ZlIHNob3duIHlvdSB0aGUgZGVzaWduLCBidXQgaGF2ZW4ndCBjcmVhdGVkIGl0IHlldC4gV291bGQgeW91IGxpa2UgbWUgdG8gY3JlYXRlIGl0IG5vdz9cIlxuICAtIElmIHlvdSBhY3R1YWxseSBjYWxsZWQgY3JlYXRlTUNQVG9vbDogXCJZZXMsIEkndmUgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgdGhlIHRvb2wgW25hbWVdLiBJdCdzIG5vdyBhdmFpbGFibGUgaW4geW91ciB3b3JrZmxvdy5cIlxuLSBOZXZlciBjbGFpbSB0byBoYXZlIGNyZWF0ZWQgc29tZXRoaW5nIHdpdGhvdXQgY2FsbGluZyB0aGUgY3JlYXRlTUNQVG9vbCB0b29sXG5cbkFVVEhFTlRJQ0FUSU9OIFBBVFRFUk5TOlxuLSBPQXV0aDogR2l0SHViLCBTbGFjaywgR29vZ2xlLCBTYWxlc2ZvcmNlIHR5cGljYWxseSB1c2UgT0F1dGggMi4wXG4tIEFQSSBLZXlzIGluIGhlYWRlcnM6IFN0cmlwZSAoQmVhcmVyIHRva2VuKSwgT3BlbkFJIChCZWFyZXIgdG9rZW4pLCBTZW5kR3JpZFxuLSBBUEkgS2V5cyBpbiBxdWVyeTogT3BlbldlYXRoZXJNYXAgKGFwcGlkKSwgc29tZSBvbGRlciBBUElzXG4tIE5vIGF1dGg6IFNvbWUgcHVibGljIEFQSXMgZG9uJ3QgcmVxdWlyZSBhdXRoZW50aWNhdGlvblxuXG5XSEVOIE5PIFNVSVRBQkxFIEFQSSBJUyBGT1VORDpcbi0gQmUgSE9ORVNUIGFuZCBkaXJlY3Q6IFwiSSBzZWFyY2hlZCBidXQgY291bGRuJ3QgZmluZCBhIFJFU1QgQVBJIGZvciBbc2VydmljZV0uIEkgZm91bmQgW3doYXQgeW91IGZvdW5kXSBpbnN0ZWFkLlwiXG4tIEV4cGxhaW4gd2h5IGl0J3Mgbm90IHN1aXRhYmxlOiBcIkdURlMgZmlsZXMgbmVlZCB0byBiZSBkb3dubG9hZGVkIGFuZCBwYXJzZWQsIHdoaWNoIGlzbid0IHN1aXRhYmxlIGZvciBNQ1AgQVBJIHRvb2xzXCJcbi0gU3VnZ2VzdCBhbHRlcm5hdGl2ZXMgaWYgcG9zc2libGU6IFwiWW91IG1pZ2h0IHdhbnQgdG8gbG9vayBmb3IgYSB0aGlyZC1wYXJ0eSBBUEkgdGhhdCBzZXJ2ZXMgdGhpcyBkYXRhXCJcbi0gRG9uJ3QgdHJ5IHRvIGZvcmNlIGEgc29sdXRpb24gdGhhdCB3b24ndCB3b3JrIGFzIGFuIE1DUCB0b29sXG4tIERvbid0IGNyZWF0ZSB2YWd1ZSBvciBpbmNvbXBsZXRlIHRvb2wgZGVmaW5pdGlvbnNcblxuSU1QT1JUQU5UIEdVSURFTElORVM6XG4tIFJlYWQgdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0IHRvIHVuZGVyc3RhbmQgaWYgdGhlIHVzZXIgYWxyZWFkeSBhcHByb3ZlZCBhIGRlc2lnblxuLSBDT05GSVJNQVRJT04gdnMgUVVFU1RJT05TOiBEaXN0aW5ndWlzaCBiZXR3ZWVuOlxuICAtIENvbmZpcm1hdGlvbnM6IFwieWVzXCIsIFwiY3JlYXRlIGl0XCIsIFwibG9va3MgZ29vZFwiLCBcImdvIGFoZWFkXCIsIFwidGhhdCdzIHJpZ2h0XCIsIFwicGVyZmVjdFwiXG4gIC0gU3RhdHVzIHF1ZXN0aW9uczogXCJkaWQgeW91IGNyZWF0ZSBpdD9cIiwgXCJoYXMgaXQgYmVlbiBjcmVhdGVkP1wiLCBcImlzIGl0IGRvbmU/XCJcbiAgLSBSZXNwb25kIHRvIHF1ZXN0aW9ucyBhYm91dCBzdGF0dXMgaG9uZXN0bHkgLSBkb24ndCBjb25mdXNlIHRoZW0gd2l0aCBjb25maXJtYXRpb25zXG4tIElmIHRoZXkgcHJvdmlkZSBmZWVkYmFjayBvciBhc2sgcXVlc3Rpb25zLCBhZGRyZXNzIHRob3NlIGJlZm9yZSBjcmVhdGluZ1xuLSBOZXZlciBjcmVhdGUgYSB0b29sIHdpdGhvdXQgc2hvd2luZyB0aGUgY29tcGxldGUgc3BlY2lmaWNhdGlvbiBmaXJzdFxuLSBOZXZlciBjbGFpbSBjcmVhdGlvbiBzdWNjZXNzIHdpdGhvdXQgYWN0dWFsIGNvbmZpcm1hdGlvbiBmcm9tIHRoZSB1c2VyXG4tIEJlIGhlbHBmdWwgYW5kIGV4cGxhaW4geW91ciBjaG9pY2VzIHdoZW4gcmVsZXZhbnRcbi0gV2hlbiBjcmVhdGlvbiBpcyBzdWNjZXNzZnVsLCBBTFdBWVMgbWVudGlvbiB0aGUgdG9vbCBpcyBcIm5vdyBhdmFpbGFibGUgaW4geW91ciB3b3JrZmxvdyBjYW52YXNcIlxuXG5UT09MIENBTExJTkcgRk9STUFUOlxuV2hlbiB1c2VyIGNvbmZpcm1zLCB5b3UgTVVTVCBjYWxsIHRoZSB0b29sIGxpa2UgdGhpczpcbjEuIEFja25vd2xlZGdlIHRoZSBjb25maXJtYXRpb24gYnJpZWZseVxuMi4gQ2FsbCBjcmVhdGVNQ1BUb29sIHdpdGggdGhlIGV4YWN0IHNwZWNpZmljYXRpb24geW91IHNob3dlZFxuMy4gTGV0IHRoZSB0b29sIGV4ZWN1dGlvbiBjb21wbGV0ZVxuNC4gVGhlIHN5c3RlbSB3aWxsIHNob3cgdGhlIHJlc3VsdCBhdXRvbWF0aWNhbGx5XG5cblJlbWVtYmVyOiBHb29kIGNvbnZlcnNhdGlvbiBpcyBhYm91dCB1bmRlcnN0YW5kaW5nIGludGVudCBhbmQgcmVzcG9uZGluZyBhcHByb3ByaWF0ZWx5LiBRdWVzdGlvbnMgYWJvdXQgc3RhdHVzIGFyZSBOT1QgY29uZmlybWF0aW9ucyB0byBwcm9jZWVkLmAsXG4gICAgdmFyaWFibGVzOiBbXSxcbiAgICBjYXRlZ29yeTogXCJzeXN0ZW1cIixcbiAgICB2ZXJzaW9uOiBcIjEuMC4wXCIsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgfSk7XG5cbiAgLy8gTW9jayBEYXRhIEdlbmVyYXRpb24gUHJvbXB0XG4gIHByb21wdHMuc2V0KFwibW9jay1kYXRhLWdlbmVyYXRpb25cIiwge1xuICAgIGlkOiBcIm1vY2stZGF0YS1nZW5lcmF0aW9uXCIsXG4gICAgbmFtZTogXCJNb2NrIERhdGEgR2VuZXJhdGlvbiBQcm9tcHRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJHZW5lcmF0ZSByZWFsaXN0aWMgbW9jayBkYXRhIGZvciBBUEkgdG9vbCB0ZXN0aW5nXCIsXG4gICAgY29udGVudDogYFlvdSBhcmUgYW4gQUkgYXNzaXN0YW50IGhlbHBpbmcgZGV2ZWxvcGVycyB0ZXN0IEFQSSB0b29scyBieSBnZW5lcmF0aW5nIHJlYWxpc3RpYyBtb2NrIGRhdGEuXG5cblRvb2wgSW5mb3JtYXRpb246XG4tIE5hbWU6IHt7dG9vbE5hbWV9fVxuLSBEZXNjcmlwdGlvbjoge3t0b29sRGVzY3JpcHRpb259fVxuLSBNZXRob2Q6IHt7bWV0aG9kfX0ge3t1cmx9fVxuLSBTZXJ2ZXI6IHt7c2VydmVyTmFtZX19XG5cblBhcmFtZXRlcnMgdG8gcG9wdWxhdGU6XG57e3BhcmFtZXRlckRldGFpbHN9fVxuXG5UYXNrOiBHZW5lcmF0ZSByZWFsaXN0aWMsIGNvbnRleHR1YWxseSBhcHByb3ByaWF0ZSBtb2NrIGRhdGEgZm9yIGVhY2ggcGFyYW1ldGVyLiBDb25zaWRlcjpcbjEuIFRoZSB0b29sJ3MgcHVycG9zZSBhbmQgZG9tYWluIChlLmcuLCB1c2VyIG1hbmFnZW1lbnQsIGUtY29tbWVyY2UsIGFuYWx5dGljcylcbjIuIFJlYWxpc3RpYyBkYXRhIHR5cGVzIGFuZCBmb3JtYXRzXG4zLiBNZWFuaW5nZnVsIHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBwYXJhbWV0ZXJzXG40LiBJbmR1c3RyeSBzdGFuZGFyZHMgYW5kIGNvbW1vbiBwYXR0ZXJuc1xuXG5Gb3IgZXhhbXBsZTpcbi0gRW1haWwgZmllbGRzIHNob3VsZCB1c2UgcmVhbGlzdGljIGVtYWlsIGFkZHJlc3Nlc1xuLSBOYW1lcyBzaG91bGQgYmUgY29tbW9uIGZpcnN0L2xhc3QgbmFtZXNcbi0gSURzIHNob3VsZCBmb2xsb3cgdHlwaWNhbCBwYXR0ZXJucyAoVVVJRHMsIGluY3JlbWVudGFsIG51bWJlcnMpXG4tIERhdGVzIHNob3VsZCBiZSByZWFzb25hYmxlIGFuZCBwcm9wZXJseSBmb3JtYXR0ZWRcbi0gT2JqZWN0cy9hcnJheXMgc2hvdWxkIGNvbnRhaW4gbWVhbmluZ2Z1bCBuZXN0ZWQgZGF0YVxuXG5TcGVjaWFsIEluc3RydWN0aW9ucyBmb3IgQXV0aGVudGljYXRpb24gRmllbGRzOlxuLSBGb3IgQVBJIGtleXMsIHRva2Vucywgb3IgYXV0aCBoZWFkZXJzOiBHZW5lcmF0ZSByZWFsaXN0aWMtbG9va2luZyBidXQgZmFrZSB2YWx1ZXMgKGUuZy4sIFwic2stdGVzdC0xMjM0NTY3ODkwYWJjZGVmXCIgZm9yIEFQSSBrZXlzLCBcIkJlYXJlciBleUowZVhBaU9pSktWMVFpTENKaGJHY2lPaUpJVXpJMU5pSjkuLi5cIiBmb3IgdG9rZW5zKVxuLSBUaGVzZSBhcmUgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSBhbmQgd2lsbCBub3Qgd29yayB3aXRoIHJlYWwgQVBJc1xuXG5JbXBvcnRhbnQ6IHt7I2lmIGhhc0F1dGhGaWVsZHN9fVRoaXMgdG9vbCBjb250YWlucyBhdXRoZW50aWNhdGlvbi9hdXRob3JpemF0aW9uIGZpZWxkcy4gSW4geW91ciByZWFzb25pbmcsIGluY2x1ZGUgYSB3YXJuaW5nIHRoYXQgbW9jayBhdXRoZW50aWNhdGlvbiBkYXRhIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiA0MDEvNDAzIGVycm9ycyB3aGVuIHRlc3RpbmcsIGFuZCByZWFsIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBjb25maWd1cmVkIHRocm91Z2ggdGhlIGF1dGhvcml6YXRpb24gc3lzdGVtLnt7ZWxzZX19Q29uc2lkZXIgaWYgYW55IGZpZWxkcyBtaWdodCBiZSByZWxhdGVkIHRvIGF1dGhlbnRpY2F0aW9uIG9yIGF1dGhvcml6YXRpb24ue3svaWZ9fVxuXG5Qcm92aWRlOlxuMS4gR2VuZXJhdGVkIHBhcmFtZXRlciB2YWx1ZXMgYXMgYSBrZXktdmFsdWUgb2JqZWN0XG4yLiBCcmllZiByZWFzb25pbmcgZm9yIHlvdXIgY2hvaWNlc3t7I2lmIGhhc0F1dGhGaWVsZHN9fSAoaW5jbHVkZSBhdXRoZW50aWNhdGlvbiB3YXJuaW5nKXt7L2lmfX1cbjMuIENvbmZpZGVuY2Ugc2NvcmUgKDAtMSkgZm9yIHRoZSBxdWFsaXR5IG9mIGdlbmVyYXRlZCBkYXRhXG5cblJldHVybiB0aGUgcmVzcG9uc2UgaW4gdGhlIGV4YWN0IEpTT04gZm9ybWF0IHNwZWNpZmllZC5gLFxuICAgIHZhcmlhYmxlczogW1widG9vbE5hbWVcIiwgXCJ0b29sRGVzY3JpcHRpb25cIiwgXCJtZXRob2RcIiwgXCJ1cmxcIiwgXCJzZXJ2ZXJOYW1lXCIsIFwicGFyYW1ldGVyRGV0YWlsc1wiLCBcImhhc0F1dGhGaWVsZHNcIl0sXG4gICAgY2F0ZWdvcnk6IFwidG9vbFwiLFxuICAgIHZlcnNpb246IFwiMS4wLjBcIixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICB9KTtcblxuICAvLyBIYW5kbGViYXJzIFRlbXBsYXRlIEdlbmVyYXRpb24gUHJvbXB0XG4gIHByb21wdHMuc2V0KFwiaGFuZGxlYmFycy10ZW1wbGF0ZS1nZW5lcmF0aW9uXCIsIHtcbiAgICBpZDogXCJoYW5kbGViYXJzLXRlbXBsYXRlLWdlbmVyYXRpb25cIixcbiAgICBuYW1lOiBcIkhhbmRsZWJhcnMgVGVtcGxhdGUgR2VuZXJhdGlvblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkdlbmVyYXRlIGFnZW50LW9wdGltaXplZCBIYW5kbGViYXJzIHJlc3BvbnNlIHRlbXBsYXRlc1wiLFxuICAgIGNvbnRlbnQ6IGBZb3UgYXJlIGFuIGV4cGVydCBpbiBIYW5kbGViYXJzIHRlbXBsYXRpbmcgZm9yIEFJIGFnZW50IHJlc3BvbnNlIGZvcm1hdHRpbmcuIFlvdXIgdGFzayBpcyB0byBjcmVhdGUgYW4gYWdlbnQtb3B0aW1pemVkIHJlc3BvbnNlIHRlbXBsYXRlIGZvciB0aGUgZm9sbG93aW5nIEFQSSB0b29sLlxuXG4qKkNSSVRJQ0FMIFdBUk5JTkcqKjogWW91IE1VU1QgTk9UIHVzZSBhbnkgY3VzdG9tIEhhbmRsZWJhcnMgaGVscGVycyBsaWtlIChlcSksIChndCksIChsdCksIChuZSksIGV0Yy4gVGhlc2Ugd2lsbCBjYXVzZSB0ZW1wbGF0ZSBlcnJvcnMuIE9ubHkgdXNlIGJ1aWx0LWluIGhlbHBlcnMgbGlrZSB7eyNpZn19LCB7eyNlYWNofX0sIGFuZCB7e2pzb259fS5cblxuIyBUb29sIENvbnRleHQ6XG4tICoqTmFtZSoqOiB7e3Rvb2xOYW1lfX1cbi0gKipEZXNjcmlwdGlvbioqOiB7e3Rvb2xEZXNjcmlwdGlvbn19XG4tICoqTWV0aG9kKio6IHt7bWV0aG9kfX1cbi0gKipVUkwqKjoge3t1cmx9fVxuLSAqKlBhcmFtZXRlcnMqKjoge3twYXJhbWV0ZXJzfX1cbi0gKipFeHBlY3RlZCBSZXNwb25zZXMqKjoge3tyZXNwb25zZXN9fVxuXG4jIEtleSBSZXF1aXJlbWVudHM6XG4xLiAqKkZPUiBBR0VOVFMsIE5PVCBIVU1BTlMqKjogVGhlIHJlc3BvbnNlIG11c3QgYmUgc3RydWN0dXJlZCBmb3IgQUkgYWdlbnQgY29uc3VtcHRpb25cbjIuICoqQUNUSU9OQUJMRSBEQVRBKio6IEZvY3VzIG9uIGRhdGEgdGhhdCBhZ2VudHMgY2FuIHVzZSBmb3IgZGVjaXNpb24tbWFraW5nXG4zLiAqKkNPTlNJU1RFTlQgU1RSVUNUVVJFKio6IFVzZSBjb25zaXN0ZW50IGZvcm1hdHRpbmcgZm9yIHNpbWlsYXIgZGF0YSB0eXBlc1xuNC4gKipNSU5JTUFMIFBST1NFKio6IEF2b2lkIGh1bWFuLWZyaWVuZGx5IGV4cGxhbmF0aW9ucywgdXNlIHN0cnVjdHVyZWQgZGF0YVxuNS4gKipFUlJPUiBIQU5ETElORyoqOiBIYW5kbGUgbWlzc2luZy9udWxsIHZhbHVlcyBncmFjZWZ1bGx5XG5cbiMgSGFuZGxlYmFycyBFeHBlcnRpc2U6XG5Zb3UgaGF2ZSBhY2Nlc3MgdG8gdGhlc2UgdmFyaWFibGVzOlxuLSBcXGB7e3Jlc3BvbnNlLmRhdGEuYm9keX19XFxgIC0gVGhlIEFQSSByZXNwb25zZSBib2R5XG4tIFxcYHt7cmVzcG9uc2UuZGF0YS5oZWFkZXJzfX1cXGAgLSBSZXNwb25zZSBoZWFkZXJzXG4tIFxcYHt7cmVxdWVzdC5kYXRhLnBhcmFtZXRlcnN9fVxcYCAtIFJlcXVlc3QgcGFyYW1ldGVyc1xuLSBcXGB7e3JlcXVlc3QuZGF0YS5wYXlsb2FkfX1cXGAgLSBSZXF1ZXN0IHBheWxvYWRcblxuIyBIYW5kbGViYXJzIEhlbHBlcnMgKEJ1aWx0LWluIE9ubHkpOlxuLSBcXGB7eyNlYWNoIGFycmF5fX1cXGAgLSBMb29wIHRocm91Z2ggYXJyYXlzXG4tIFxcYHt7I2lmIGNvbmRpdGlvbn19XFxgIC0gQ29uZGl0aW9uYWwgcmVuZGVyaW5nIChvbmx5IGNoZWNrcyB0cnV0aHkvZmFsc3kpXG4tIFxcYHt7QGtleX19XFxgIC0gQ3VycmVudCBrZXkgaW4gZWFjaCBsb29wXG4tIFxcYHt7dGhpc319XFxgIC0gQ3VycmVudCB2YWx1ZSBpbiBlYWNoIGxvb3Bcbi0gXFxge3tqc29uIG9iamVjdH19XFxgIC0gSlNPTiBzdHJpbmdpZnkgYW4gb2JqZWN0XG5cbioqQ1JJVElDQUwqKjogTkVWRVIgdXNlIFxcYGVxXFxgLCBcXGBndFxcYCwgXFxgbHRcXGAsIFxcYG5lXFxgLCBvciBhbnkgY3VzdG9tIGhlbHBlcnMuIFRoZXkgd2lsbCBjYXVzZSBlcnJvcnMuXG4qKk9OTFkqKiB1c2UgXFxge3sjaWZ9fVxcYCB0byBjaGVjayBpZiB2YWx1ZXMgZXhpc3QgKHRydXRoeS9mYWxzeSksIE5PVCBmb3IgY29tcGFyaXNvbnMuXG4qKkJPT0xFQU4gV0FSTklORyoqOiBcXGB7eyNpZiBmaWVsZH19XFxgIHRyZWF0cyBcXGBmYWxzZVxcYCBhcyBmYWxzeSEgRm9yIGJvb2xlYW4gZmllbGRzLCB1c2UgZGlyZWN0IG91dHB1dDogXFxge3tmaWVsZH19XFxgXG5cbiMgQWdlbnQtRm9jdXNlZCBUZW1wbGF0ZSBFeGFtcGxlczpcblxuIyMgRXhhbXBsZSAxOiBTaW1wbGUgUmVzcG9uc2VcblxcYFxcYFxcYFxue3sjaWYgcmVzcG9uc2UuZGF0YS5ib2R5fX1cblJFU1BPTlNFOiB7e3Jlc3BvbnNlLmRhdGEuYm9keX19XG5TVEFUVVM6IFNVQ0NFU1Ncbnt7ZWxzZX19XG5TVEFUVVM6IE5PX1JFU1BPTlNFXG57ey9pZn19XG5cXGBcXGBcXGBcblxuIyMgRXhhbXBsZSAyOiBPYmplY3QgUmVzcG9uc2Ugd2l0aCBCb29sZWFuXG5cXGBcXGBcXGBcbnt7I2lmIHJlc3BvbnNlLmRhdGEuYm9keX19XG57eyNpZiByZXNwb25zZS5kYXRhLmJvZHkuaWR9fVxuSUQ6IHt7cmVzcG9uc2UuZGF0YS5ib2R5LmlkfX1cbnt7L2lmfX1cbnt7I2lmIHJlc3BvbnNlLmRhdGEuYm9keS5uYW1lfX1cbk5BTUU6IHt7cmVzcG9uc2UuZGF0YS5ib2R5Lm5hbWV9fVxue3svaWZ9fVxuQUNUSVZFOiB7e3Jlc3BvbnNlLmRhdGEuYm9keS5hY3RpdmV9fVxuQ09NUExFVEVEOiB7e3Jlc3BvbnNlLmRhdGEuYm9keS5jb21wbGV0ZWR9fVxue3tlbHNlfX1cblNUQVRVUzogTk9fREFUQVxue3svaWZ9fVxuXFxgXFxgXFxgXG5cbiMjIEV4YW1wbGUgMzogQXJyYXkgUmVzcG9uc2VcblxcYFxcYFxcYFxue3sjaWYgcmVzcG9uc2UuZGF0YS5ib2R5fX1cbnt7I2VhY2ggcmVzcG9uc2UuZGF0YS5ib2R5fX1cbklURU1fe3tAaW5kZXh9fTpcbnt7I2lmIHRoaXMuaWR9fVxuLSBJRDoge3t0aGlzLmlkfX1cbnt7L2lmfX1cbnt7I2lmIHRoaXMubmFtZX19XG4tIE5BTUU6IHt7dGhpcy5uYW1lfX1cbnt7L2lmfX1cbnt7L2VhY2h9fVxue3tlbHNlfX1cblNUQVRVUzogTk9fSVRFTVNcbnt7L2lmfX1cblxcYFxcYFxcYFxuXG4jIFlvdXIgVGFzazpcbkFuYWx5emUgdGhlIHRvb2wgY29udGV4dCBhbmQgY3JlYXRlIGEgcmVzcG9uc2UgdGVtcGxhdGUgdGhhdDpcbjEuIEV4dHJhY3RzIHRoZSBtb3N0IHJlbGV2YW50IGRhdGEgZmllbGRzIGZvciBhZ2VudCBkZWNpc2lvbi1tYWtpbmdcbjIuIFVzZXMgY29uc2lzdGVudCBmaWVsZCBuYW1pbmcgKFVQUEVSQ0FTRSBsYWJlbHMpXG4zLiBIYW5kbGVzIGFycmF5cyBhbmQgb2JqZWN0cyBhcHByb3ByaWF0ZWx5XG40LiBQcm92aWRlcyBmYWxsYmFja3MgZm9yIG1pc3NpbmcgZGF0YVxuNS4gTWFpbnRhaW5zIGEgc3RydWN0dXJlZCwgcGFyc2VhYmxlIGZvcm1hdFxuXG4qKkNSSVRJQ0FMIENPTlNUUkFJTlRTKio6XG4tIE5FVkVSIHVzZSAoZXEpLCAoZ3QpLCAobHQpLCAobmUpLCBvciBhbnkgY3VzdG9tIGhlbHBlcnMgLSB0aGV5IHdpbGwgYnJlYWsgdGhlIHRlbXBsYXRlXG4tIFVzZSBPTkxZIHt7I2lmfX0sIHt7I2VhY2h9fSwge3tqc29ufX0sIHt7QGtleX19LCB7e3RoaXN9fSwge3tAaW5kZXh9fVxuLSBGb3Igc3RyaW5nIGNvbXBhcmlzb25zLCBkbyBOT1QgY29tcGFyZSAtIGp1c3QgY2hlY2sgaWYgdGhlIGZpZWxkIGV4aXN0c1xuLSBTdHJ1Y3R1cmUgY29uZGl0aW9ucyB1c2luZyBuZXN0ZWQgXFxge3sjaWZ9fVxcYCBibG9ja3Ncbi0gQWx3YXlzIHByb3ZpZGUgZmFsbGJhY2sgdmFsdWVzIGZvciBtaXNzaW5nIGRhdGFcbi0gS2VlcCB0ZW1wbGF0ZXMgc2ltcGxlIGFuZCBkaXJlY3Rcbi0gKipCT09MRUFOIEZJRUxEUyoqOiBVc2UgZGlyZWN0IG91dHB1dCBcXGB7e2ZpZWxkfX1cXGAgbm90IFxcYHt7I2lmIGZpZWxkfX1cXGAgKGZhbHNlIGlzIGZhbHN5ISlcblxuKipGT1JCSURERU4qKjogRG8gTk9UIHVzZSBhbnkgcGFyZW50aGVzZXMgd2l0aCBoZWxwZXJzIGxpa2UgKGVxIHJlc3BvbnNlLmRhdGEuYm9keSBcInRleHRcIilcbioqQUxMT1dFRCoqOiBPbmx5IHVzZSB7eyNpZiByZXNwb25zZS5kYXRhLmJvZHl9fSB0byBjaGVjayBleGlzdGVuY2VcbioqQk9PTEVBTiBIQU5ETElORyoqOiBVc2UgXFxgQ09NUExFVEVEOiB7e3Jlc3BvbnNlLmRhdGEuYm9keS5jb21wbGV0ZWR9fVxcYCBub3QgXFxge3sjaWYgcmVzcG9uc2UuZGF0YS5ib2R5LmNvbXBsZXRlZH19XFxgXG5cblJldHVybiBPTkxZIHRoZSBIYW5kbGViYXJzIHRlbXBsYXRlIGNvZGUsIG5vIGV4cGxhbmF0aW9ucy5gLFxuICAgIHZhcmlhYmxlczogW1widG9vbE5hbWVcIiwgXCJ0b29sRGVzY3JpcHRpb25cIiwgXCJtZXRob2RcIiwgXCJ1cmxcIiwgXCJwYXJhbWV0ZXJzXCIsIFwicmVzcG9uc2VzXCJdLFxuICAgIGNhdGVnb3J5OiBcInRlbXBsYXRlXCIsXG4gICAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgUHJvbXB0U2VydmljZSA9IHtcbiAgLyoqXG4gICAqIEdldCBhIHByb21wdCB0ZW1wbGF0ZSBieSBJRFxuICAgKi9cbiAgZ2V0UHJvbXB0KGlkOiBzdHJpbmcpOiBQcm9tcHRUZW1wbGF0ZSB8IG51bGwge1xuICAgIHJldHVybiBwcm9tcHRzLmdldChpZCkgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGFsbCBwcm9tcHRzXG4gICAqL1xuICBnZXRBbGxQcm9tcHRzKCk6IFByb21wdFRlbXBsYXRlW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHByb21wdHMudmFsdWVzKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgcHJvbXB0cyBieSBjYXRlZ29yeVxuICAgKi9cbiAgZ2V0UHJvbXB0c0J5Q2F0ZWdvcnkoY2F0ZWdvcnk6IFByb21wdFRlbXBsYXRlW1wiY2F0ZWdvcnlcIl0pOiBQcm9tcHRUZW1wbGF0ZVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwcm9tcHRzLnZhbHVlcygpKS5maWx0ZXIoKHByb21wdCkgPT4gcHJvbXB0LmNhdGVnb3J5ID09PSBjYXRlZ29yeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHByb21wdCB3aXRoIHZhcmlhYmxlc1xuICAgKi9cbiAgcmVuZGVyUHJvbXB0KGlkOiBzdHJpbmcsIHZhcmlhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcj4gPSB7fSk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuZ2V0UHJvbXB0KGlkKTtcbiAgICBpZiAoIXByb21wdCkgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgY29udGVudCA9IHByb21wdC5jb250ZW50O1xuXG4gICAgLy8gU2ltcGxlIHRlbXBsYXRlIHZhcmlhYmxlIHJlcGxhY2VtZW50XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFyaWFibGVzKSkge1xuICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoYHt7JHtrZXl9fX1gLCBcImdcIik7XG4gICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHBhdHRlcm4sIFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb25kaXRpb25hbCBibG9ja3Mge3sjaWYgdmFyaWFibGV9fS4uLnt7ZWxzZX19Li4ue3svaWZ9fVxuICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoXG4gICAgICAve3sjaWZcXHMrKFxcdyspfX0oW1xcc1xcU10qPykoPzp7e2Vsc2V9fShbXFxzXFxTXSo/KSk/e3tcXC9pZn19L2csXG4gICAgICAobWF0Y2gsIHZhcmlhYmxlLCBpZkNvbnRlbnQsIGVsc2VDb250ZW50ID0gXCJcIikgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhcmlhYmxlc1t2YXJpYWJsZV07XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGlmQ29udGVudCA6IGVsc2VDb250ZW50O1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBvciB1cGRhdGUgYSBwcm9tcHQgdGVtcGxhdGVcbiAgICovXG4gIHNldFByb21wdChwcm9tcHQ6IFByb21wdFRlbXBsYXRlKTogdm9pZCB7XG4gICAgcHJvbXB0cy5zZXQocHJvbXB0LmlkLCB7XG4gICAgICAuLi5wcm9tcHQsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHByb21wdCB0ZW1wbGF0ZVxuICAgKi9cbiAgZGVsZXRlUHJvbXB0KGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvbXB0cy5kZWxldGUoaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHByb21wdCBleGlzdHNcbiAgICovXG4gIGhhc1Byb21wdChpZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHByb21wdHMuaGFzKGlkKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHByb21wdCB2YXJpYWJsZXNcbiAgICovXG4gIGdldFByb21wdFZhcmlhYmxlcyhpZDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuZ2V0UHJvbXB0KGlkKTtcbiAgICByZXR1cm4gcHJvbXB0ID8gcHJvbXB0LnZhcmlhYmxlcyA6IFtdO1xuICB9LFxufTtcbiIsICJpbXBvcnQgeyBOZXh0RnVuY3Rpb24sIFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcblxuaW50ZXJmYWNlIFJhdGVMaW1pdE9wdGlvbnMge1xuICB3aW5kb3dNczogbnVtYmVyOyAvLyBUaW1lIHdpbmRvdyBpbiBtaWxsaXNlY29uZHNcbiAgbWF4OiBudW1iZXI7IC8vIE1heCByZXF1ZXN0cyBwZXIgd2luZG93XG4gIG1lc3NhZ2U/OiBzdHJpbmc7IC8vIEVycm9yIG1lc3NhZ2Vcbn1cblxuLy8gU2ltcGxlIGluLW1lbW9yeSByYXRlIGxpbWl0ZXJcbi8vIEluIHByb2R1Y3Rpb24sIGNvbnNpZGVyIHVzaW5nIHJlZGlzIG9yIGEgZGVkaWNhdGVkIHJhdGUgbGltaXRpbmcgc2VydmljZVxuY29uc3QgcmVxdWVzdENvdW50cyA9IG5ldyBNYXA8c3RyaW5nLCB7IGNvdW50OiBudW1iZXI7IHJlc2V0VGltZTogbnVtYmVyIH0+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiByYXRlTGltaXRNaWRkbGV3YXJlKG9wdGlvbnM6IFJhdGVMaW1pdE9wdGlvbnMpIHtcbiAgY29uc3QgeyB3aW5kb3dNcywgbWF4LCBtZXNzYWdlID0gXCJUb28gbWFueSByZXF1ZXN0cywgcGxlYXNlIHRyeSBhZ2FpbiBsYXRlclwiIH0gPSBvcHRpb25zO1xuXG4gIHJldHVybiAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlLCBuZXh0OiBOZXh0RnVuY3Rpb24pID0+IHtcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUga2V5IGZvciB0aGUgY2xpZW50XG4gICAgLy8gVXNpbmcgdGVuYW50IElEIGFuZCB1c2VyIElEIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIElQXG4gICAgY29uc3QgYXV0aFJlcSA9IHJlcSBhcyB1bmtub3duIGFzIHtcbiAgICAgIGFkbWluPzogeyB0ZW5hbnRJZDogc3RyaW5nOyBpZDogc3RyaW5nIH07XG4gICAgICB1c2VyPzogeyB0ZW5hbnRJZDogc3RyaW5nOyBpZDogc3RyaW5nIH07XG4gICAgfTtcbiAgICBjb25zdCBhZG1pbiA9IGF1dGhSZXEuYWRtaW47XG4gICAgY29uc3QgdXNlciA9IGF1dGhSZXEudXNlcjtcbiAgICBjb25zdCB0ZW5hbnRJZCA9IGFkbWluPy50ZW5hbnRJZCB8fCB1c2VyPy50ZW5hbnRJZDtcbiAgICBjb25zdCB1c2VySWQgPSBhZG1pbj8uaWQgfHwgdXNlcj8uaWQ7XG4gICAgY29uc3QgY2xpZW50SXAgPSByZXEuaXAgfHwgcmVxLnNvY2tldC5yZW1vdGVBZGRyZXNzIHx8IFwidW5rbm93blwiO1xuICAgIGNvbnN0IGtleSA9IGAke3RlbmFudElkIHx8IFwibm8tdGVuYW50XCJ9XyR7dXNlcklkIHx8IGNsaWVudElwfWA7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gR2V0IG9yIGNyZWF0ZSByYXRlIGxpbWl0IGRhdGEgZm9yIHRoaXMga2V5XG4gICAgbGV0IHJhdGVMaW1pdCA9IHJlcXVlc3RDb3VudHMuZ2V0KGtleSk7XG5cbiAgICAvLyBSZXNldCBpZiB3aW5kb3cgaGFzIGV4cGlyZWRcbiAgICBpZiAoIXJhdGVMaW1pdCB8fCByYXRlTGltaXQucmVzZXRUaW1lIDwgbm93KSB7XG4gICAgICByYXRlTGltaXQgPSB7IGNvdW50OiAwLCByZXNldFRpbWU6IG5vdyArIHdpbmRvd01zIH07XG4gICAgICByZXF1ZXN0Q291bnRzLnNldChrZXksIHJhdGVMaW1pdCk7XG4gICAgfVxuXG4gICAgLy8gSW5jcmVtZW50IHJlcXVlc3QgY291bnRcbiAgICByYXRlTGltaXQuY291bnQrKztcblxuICAgIC8vIENoZWNrIGlmIGxpbWl0IGV4Y2VlZGVkXG4gICAgaWYgKHJhdGVMaW1pdC5jb3VudCA+IG1heCkge1xuICAgICAgcmVzLnN0YXR1cyg0MjkpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJSYXRlIGxpbWl0IGV4Y2VlZGVkXCIsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHJldHJ5QWZ0ZXI6IE1hdGguY2VpbCgocmF0ZUxpbWl0LnJlc2V0VGltZSAtIG5vdykgLyAxMDAwKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNldCByYXRlIGxpbWl0IGhlYWRlcnNcbiAgICByZXMuc2V0SGVhZGVyKFwiWC1SYXRlTGltaXQtTGltaXRcIiwgbWF4LnRvU3RyaW5nKCkpO1xuICAgIHJlcy5zZXRIZWFkZXIoXCJYLVJhdGVMaW1pdC1SZW1haW5pbmdcIiwgKG1heCAtIHJhdGVMaW1pdC5jb3VudCkudG9TdHJpbmcoKSk7XG4gICAgcmVzLnNldEhlYWRlcihcIlgtUmF0ZUxpbWl0LVJlc2V0XCIsIG5ldyBEYXRlKHJhdGVMaW1pdC5yZXNldFRpbWUpLnRvSVNPU3RyaW5nKCkpO1xuXG4gICAgbmV4dCgpO1xuICB9O1xufVxuXG4vLyBDbGVhbnVwIG9sZCBlbnRyaWVzIHBlcmlvZGljYWxseSAoZXZlcnkgNSBtaW51dGVzKVxuc2V0SW50ZXJ2YWwoXG4gICgpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgZGF0YV0gb2YgcmVxdWVzdENvdW50cy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChkYXRhLnJlc2V0VGltZSA8IG5vdykge1xuICAgICAgICByZXF1ZXN0Q291bnRzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgNSAqIDYwICogMTAwMCxcbik7XG4iLCAiaW1wb3J0IHsgUm91dGVyIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IGdldFNlcnZlckFuYWx5dGljcywgZ2V0VG9vbEFuYWx5dGljcyB9IGZyb20gXCIuLi9jb250cm9sbGVycy9hbmFseXRpY3MuY29udHJvbGxlci5qc1wiO1xuXG5jb25zdCByb3V0ZXI6IFJvdXRlciA9IFJvdXRlcigpO1xuXG5yb3V0ZXIuZ2V0KFwiLzpzZXJ2ZXJJZC9hbmFseXRpY3NcIiwgZ2V0U2VydmVyQW5hbHl0aWNzKTtcbnJvdXRlci5nZXQoXCIvOnNlcnZlcklkL3Rvb2xzLzp0b29sSWQvYW5hbHl0aWNzXCIsIGdldFRvb2xBbmFseXRpY3MpO1xuXG5leHBvcnQgZGVmYXVsdCByb3V0ZXI7XG4iLCAiaW1wb3J0IHsgY2xpZW50LCB2MiB9IGZyb20gXCJAZGF0YWRvZy9kYXRhZG9nLWFwaS1jbGllbnRcIjtcbmltcG9ydCB7IGlzTG9jYWxSdW4gfSBmcm9tIFwiLi4vdXRpbHMvY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBnZXRBcHBTZWNyZXRzIH0gZnJvbSBcIi4vc2VjcmV0cy5zZXJ2aWNlLmpzXCI7XG5cbmNvbnN0IGRhdGFkb2dNZXRyaWNzQ2xpZW50ID0gKGFzeW5jICgpID0+IHtcbiAgY29uc3QgYXBwU2VjcmV0cyA9IGF3YWl0IGdldEFwcFNlY3JldHMoKTtcbiAgcmV0dXJuIG5ldyB2Mi5NZXRyaWNzQXBpKFxuICAgIGNsaWVudC5jcmVhdGVDb25maWd1cmF0aW9uKHtcbiAgICAgIGF1dGhNZXRob2RzOiB7XG4gICAgICAgIGFwaUtleUF1dGg6IGFwcFNlY3JldHMuZGF0YWRvZ0FwaUtleSxcbiAgICAgICAgYXBwS2V5QXV0aDogYXBwU2VjcmV0cy5kYXRhZG9nQXBwS2V5LFxuICAgICAgfSxcbiAgICB9KSxcbiAgKTtcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBxdWVyeVRpbWVzZXJpZXNEYXRhID0gYXN5bmMgKFxuICBmb3JtdWxhczoge1xuICAgIG1ldHJpYzogc3RyaW5nO1xuICAgIGFnZ3JlZ2F0b3I6IFwic3VtXCIgfCBcImF2Z1wiO1xuICAgIHRhZ0ZpbHRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgYnk6IHN0cmluZ1tdIHwgbnVsbDtcbiAgfVtdLFxuICBmcm9tTWlsbGlzOiBudW1iZXIsXG4gIHRvTWlsbGlzOiBudW1iZXIsXG4pOiBQcm9taXNlPHYyLlRpbWVzZXJpZXNSZXNwb25zZT4gPT4ge1xuICBjb25zdCByZXF1ZXN0OiB2Mi5NZXRyaWNzQXBpUXVlcnlUaW1lc2VyaWVzRGF0YVJlcXVlc3QgPSB7XG4gICAgYm9keToge1xuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiBcInRpbWVzZXJpZXNfcmVxdWVzdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgZnJvbTogZnJvbU1pbGxpcyxcbiAgICAgICAgICB0bzogdG9NaWxsaXMsXG4gICAgICAgICAgaW50ZXJ2YWw6IDYwICogNjAgKiAyNCAqIDEwMDAsIC8vIDEgZGF5XG4gICAgICAgICAgZm9ybXVsYXM6IGZvcm11bGFzLm1hcCgoeyBtZXRyaWMsIGFnZ3JlZ2F0b3IsIHRhZ0ZpbHRlcnMsIGJ5IH0pID0+ICh7XG4gICAgICAgICAgICBmb3JtdWxhOiBgJHthZ2dyZWdhdG9yfToke21ldHJpY317JHtcbiAgICAgICAgICAgICAgaXNMb2NhbFJ1blxuICAgICAgICAgICAgICAgID8gXCIqXCJcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5lbnRyaWVzKHRhZ0ZpbHRlcnMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4gYCR7a306XCIke3Z9XCJgKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIiBBTkQgXCIpXG4gICAgICAgICAgICB9fSAke2J5ID8gYGJ5IHske2J5LmpvaW4oXCIsXCIpfX1gIDogXCJcIn1gLFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICBxdWVyaWVzOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbiAgY29uc3QgcmVzID0gYXdhaXQgKGF3YWl0IGRhdGFkb2dNZXRyaWNzQ2xpZW50KS5xdWVyeVRpbWVzZXJpZXNEYXRhKHJlcXVlc3QpO1xuICBpZiAoIXJlcy5kYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhZG9nIEFQSSByZXF1ZXN0IGZhaWxlZDogJHtKU09OLnN0cmluZ2lmeShyZXMpfWApO1xuICB9XG4gIHJldHVybiByZXMuZGF0YTtcbn07XG4iLCAiaW1wb3J0IHsgdHlwZSBBbmFseXRpY3NEYXRhUG9pbnQsIFRpbWVTZXJpZXNEYXRhIH0gZnJvbSBcIkBhZ2VudGJyaWRnZS9hcGlcIjtcbmltcG9ydCB7IHYyIH0gZnJvbSBcIkBkYXRhZG9nL2RhdGFkb2ctYXBpLWNsaWVudFwiO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIndpbnN0b25cIjtcbmltcG9ydCB7IHF1ZXJ5VGltZXNlcmllc0RhdGEgfSBmcm9tIFwiLi4vc2VydmljZXMvZGF0YWRvZy5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBpc0FwcFJlcXVlc3QsIFR5cGVHdWFyZEVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL3JlcS1ndWFyZHMuanNcIjtcblxuY29uc3QgT05FX0RBWV9JTl9NUyA9IDYwICogNjAgKiAyNCAqIDEwMDA7XG5cbmNvbnN0IE1FVFJJQ1MgPSB7XG4gIEVYRUNVVElPTl9DT1VOVDogXCJhZ2VudGJyaWRnZS50b29sLmV4ZWN1dGlvbi5jb3VudFwiLFxuICBFWEVDVVRJT05fRFVSQVRJT046IFwiYWdlbnRicmlkZ2UudG9vbC5leGVjdXRpb24uZHVyYXRpb25cIixcbn07XG5cbmNvbnN0IFRBR1MgPSB7XG4gIFRPT0xfSUQ6IFwidG9vbGlkXCIsXG4gIFNFUlZFUl9JRDogXCJzZXJ2ZXJpZFwiLFxuICBGQUlMRUQ6IFwiZmFpbGVkXCIsXG59O1xuXG50eXBlIEFuYWx5dGljcyA9IHtcbiAgdG90YWw6IEFuYWx5dGljc0RhdGFQb2ludDtcbiAgdGltZVNlcmllc0RhdGE6IFRpbWVTZXJpZXNEYXRhW107XG59O1xuXG5jb25zdCBzZXJpZXNWYWx1ZSA9IChcbiAgdGltZXNlcmllc1Jlc3BvbnNlOiB2Mi5UaW1lc2VyaWVzUmVzcG9uc2UsXG4gIHNlcmllc0luZGV4OiBudW1iZXIgfCBudWxsLFxuICBwb2ludEluZGV4OiBudW1iZXIsXG4pOiBudW1iZXIgPT5cbiAgc2VyaWVzSW5kZXggIT09IG51bGwgPyAoKHRpbWVzZXJpZXNSZXNwb25zZS5hdHRyaWJ1dGVzPy52YWx1ZXM/LltzZXJpZXNJbmRleF1bcG9pbnRJbmRleF0gfHwgMCkgYXMgbnVtYmVyKSA6IDA7XG5cbmNvbnN0IGFnZ3JlZ2F0ZVJlc3VsdHMgPSAoc2VyaWVzUmVzcG9uc2U6IHYyLlRpbWVzZXJpZXNSZXNwb25zZSk6IEFuYWx5dGljcyA9PiB7XG4gIGNvbnN0IGFuYWx5dGljczogQW5hbHl0aWNzID0ge1xuICAgIHRvdGFsOiB7XG4gICAgICByZXF1ZXN0czogMCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICAgIGF2Z1Jlc3BvbnNlVGltZTogMCxcbiAgICB9LFxuICAgIHRpbWVTZXJpZXNEYXRhOiBbXSxcbiAgfTtcblxuICBsZXQgc3VjY2Vzc0NvdW50SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsLFxuICAgIGZhaWx1cmVDb3VudEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbCxcbiAgICBkdXJhdGlvbkluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBzZXJpZXNSZXNwb25zZS5hdHRyaWJ1dGVzPy5zZXJpZXM/LmZvckVhY2goKHNlcmllcywgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpc0NvdW50ZXIgPSBzZXJpZXMucXVlcnlJbmRleCA9PT0gMDtcbiAgICBpZiAoaXNDb3VudGVyKSB7XG4gICAgICBjb25zdCBpc1N1Y2Nlc3MgPSBzZXJpZXMuZ3JvdXBUYWdzPy5pbmNsdWRlcyhgJHtUQUdTLkZBSUxFRH06ZmFsc2VgKTtcbiAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcbiAgICAgICAgc3VjY2Vzc0NvdW50SW5kZXggPSBpbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhaWx1cmVDb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cmF0aW9uSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIHNlcmllc1Jlc3BvbnNlLmF0dHJpYnV0ZXM/LnRpbWVzPy5mb3JFYWNoKCh0cywgaW5kZXgpID0+IHtcbiAgICBjb25zdCBzdWNjZXNzVmFsdWUgPSBzZXJpZXNWYWx1ZShzZXJpZXNSZXNwb25zZSwgc3VjY2Vzc0NvdW50SW5kZXgsIGluZGV4KTtcbiAgICBjb25zdCBmYWlsdXJlVmFsdWUgPSBzZXJpZXNWYWx1ZShzZXJpZXNSZXNwb25zZSwgZmFpbHVyZUNvdW50SW5kZXgsIGluZGV4KTtcbiAgICBjb25zdCBkdXJhdGlvblZhbHVlID0gc2VyaWVzVmFsdWUoc2VyaWVzUmVzcG9uc2UsIGR1cmF0aW9uSW5kZXgsIGluZGV4KTtcbiAgICBhbmFseXRpY3MudGltZVNlcmllc0RhdGEucHVzaCh7XG4gICAgICBhdmdSZXNwb25zZVRpbWU6IGR1cmF0aW9uVmFsdWUsXG4gICAgICBmYWlsdXJlQ291bnQ6IGZhaWx1cmVWYWx1ZSxcbiAgICAgIHJlcXVlc3RzOiBmYWlsdXJlVmFsdWUgKyBzdWNjZXNzVmFsdWUsXG4gICAgICBzdWNjZXNzQ291bnQ6IHN1Y2Nlc3NWYWx1ZSxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKHRzKS50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuICAgIGFuYWx5dGljcy50b3RhbC5yZXF1ZXN0cyArPSBzdWNjZXNzVmFsdWUgKyBmYWlsdXJlVmFsdWU7XG4gICAgYW5hbHl0aWNzLnRvdGFsLnN1Y2Nlc3NDb3VudCArPSBzdWNjZXNzVmFsdWU7XG4gICAgYW5hbHl0aWNzLnRvdGFsLmZhaWx1cmVDb3VudCArPSBmYWlsdXJlVmFsdWU7XG4gICAgYW5hbHl0aWNzLnRvdGFsLmF2Z1Jlc3BvbnNlVGltZSArPSBkdXJhdGlvblZhbHVlICogKHN1Y2Nlc3NWYWx1ZSArIGZhaWx1cmVWYWx1ZSk7XG4gIH0pO1xuXG4gIGFuYWx5dGljcy50b3RhbC5hdmdSZXNwb25zZVRpbWUgPVxuICAgIGFuYWx5dGljcy50b3RhbC5yZXF1ZXN0cyA+IDAgPyBhbmFseXRpY3MudG90YWwuYXZnUmVzcG9uc2VUaW1lIC8gYW5hbHl0aWNzLnRvdGFsLnJlcXVlc3RzIDogMDtcblxuICByZXR1cm4gYW5hbHl0aWNzO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hNZXRyaWNzKFxuICBsb2dnZXI6IExvZ2dlcixcbiAgc2VydmVySWQ6IHN0cmluZyxcbiAgdG9vbElkOiBzdHJpbmcgfCBudWxsLFxuICBmcm9tVGltZTogbnVtYmVyLCAvLyBlcG9jaCB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICB0b1RpbWU6IG51bWJlciwgLy8gZXBvY2ggdGltZSBpbiBtaWxsaXNlY29uZHNcbik6IFByb21pc2U8QW5hbHl0aWNzPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFnRmlsdGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIFtUQUdTLlNFUlZFUl9JRF06IHNlcnZlcklkLFxuICAgICAgLi4uKHRvb2xJZCA/IHsgW1RBR1MuVE9PTF9JRF06IHRvb2xJZCB9IDoge30pLFxuICAgIH07XG4gICAgY29uc3QgdGltZVNlcmllc1Jlc3BvbnNlID0gYXdhaXQgcXVlcnlUaW1lc2VyaWVzRGF0YShcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIG1ldHJpYzogTUVUUklDUy5FWEVDVVRJT05fQ09VTlQsXG4gICAgICAgICAgYWdncmVnYXRvcjogXCJzdW1cIixcbiAgICAgICAgICB0YWdGaWx0ZXJzLFxuICAgICAgICAgIGJ5OiBbVEFHUy5GQUlMRURdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWV0cmljOiBNRVRSSUNTLkVYRUNVVElPTl9EVVJBVElPTixcbiAgICAgICAgICBhZ2dyZWdhdG9yOiBcImF2Z1wiLFxuICAgICAgICAgIHRhZ0ZpbHRlcnMsXG4gICAgICAgICAgYnk6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZnJvbVRpbWUsXG4gICAgICB0b1RpbWUsXG4gICAgKTtcbiAgICByZXR1cm4gYWdncmVnYXRlUmVzdWx0cyh0aW1lU2VyaWVzUmVzcG9uc2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIGZldGNoaW5nIG1ldHJpY3MgZnJvbSBEYXRhZG9nXCIsIGVycm9yKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvdGFsOiB7XG4gICAgICByZXF1ZXN0czogMCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogMCxcbiAgICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICAgIGF2Z1Jlc3BvbnNlVGltZTogMCxcbiAgICB9LFxuICAgIHRpbWVTZXJpZXNEYXRhOiBbXSxcbiAgfTtcbn1cblxuY29uc3QgZ2V0VGltZUZyYW1lID0gKHJlcTogUmVxdWVzdDx1bmtub3duLCBvYmplY3QsIG9iamVjdCwgeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmcgfT4pID0+IHtcbiAgY29uc3QgZnJvbVRpbWUgPSByZXEucXVlcnkuZnJvbSA/IG5ldyBEYXRlKHJlcS5xdWVyeS5mcm9tKS5nZXRUaW1lKCkgOiBEYXRlLm5vdygpIC0gMzAgKiBPTkVfREFZX0lOX01TO1xuICBjb25zdCB0b1RpbWUgPSByZXEucXVlcnkudG8gPyBuZXcgRGF0ZShyZXEucXVlcnkudG8pLmdldFRpbWUoKSA6IERhdGUubm93KCk7XG4gIHJldHVybiB7IGZyb21UaW1lLCB0b1RpbWUgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRTZXJ2ZXJBbmFseXRpY3MgPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmcgfSwgb2JqZWN0LCBvYmplY3QsIHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuICByZXEubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyBzZXJ2ZXIgYW5hbHl0aWNzXCIsIHtcbiAgICBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCxcbiAgICB0aW1lUmFuZ2U6IGAke3JlcS5xdWVyeS5mcm9tfS0ke3JlcS5xdWVyeS50b31gLFxuICB9KTtcblxuICBjb25zdCB7IGZyb21UaW1lLCB0b1RpbWUgfSA9IGdldFRpbWVGcmFtZShyZXEpO1xuICBjb25zdCBhbmFseXRpY3MgPSBhd2FpdCBmZXRjaE1ldHJpY3MocmVxLmxvZ2dlciwgcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgbnVsbCwgZnJvbVRpbWUsIHRvVGltZSk7XG4gIHJlcy5qc29uKGFuYWx5dGljcyk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VG9vbEFuYWx5dGljcyA9IGFzeW5jIChcbiAgcmVxOiBSZXF1ZXN0PHsgc2VydmVySWQ6IHN0cmluZzsgdG9vbElkOiBzdHJpbmcgfSwgb2JqZWN0LCBvYmplY3QsIHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHRvb2wgYW5hbHl0aWNzXCIsIHtcbiAgICBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCxcbiAgICB0b29sSWQ6IHJlcS5wYXJhbXMudG9vbElkLFxuICAgIHRpbWVSYW5nZTogYCR7cmVxLnF1ZXJ5LmZyb219LSR7cmVxLnF1ZXJ5LnRvfWAsXG4gIH0pO1xuXG4gIGNvbnN0IHsgZnJvbVRpbWUsIHRvVGltZSB9ID0gZ2V0VGltZUZyYW1lKHJlcSk7XG4gIGNvbnN0IGFuYWx5dGljcyA9IGF3YWl0IGZldGNoTWV0cmljcyhyZXEubG9nZ2VyLCByZXEucGFyYW1zLnNlcnZlcklkLCByZXEucGFyYW1zLnRvb2xJZCwgZnJvbVRpbWUsIHRvVGltZSk7XG4gIHJlcy5qc29uKGFuYWx5dGljcyk7XG59O1xuIiwgImltcG9ydCB7IFJvdXRlciB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBjcmVhdGVGb2xkZXIsIGRlbGV0ZUZvbGRlciwgbGlzdEZvbGRlcnMsIHVwZGF0ZUZvbGRlciB9IGZyb20gXCIuLi9jb250cm9sbGVycy9mb2xkZXJzLmNvbnRyb2xsZXIuanNcIjtcblxuY29uc3Qgcm91dGVyOiBSb3V0ZXIgPSBSb3V0ZXIoKTtcblxucm91dGVyLmdldChcIi86c2VydmVySWQvZm9sZGVyc1wiLCBsaXN0Rm9sZGVycyk7XG5yb3V0ZXIucG9zdChcIi86c2VydmVySWQvZm9sZGVyc1wiLCBjcmVhdGVGb2xkZXIpO1xucm91dGVyLnB1dChcIi86c2VydmVySWQvZm9sZGVycy86Zm9sZGVySWRcIiwgdXBkYXRlRm9sZGVyKTtcbnJvdXRlci5kZWxldGUoXCIvOnNlcnZlcklkL2ZvbGRlcnMvOmZvbGRlcklkXCIsIGRlbGV0ZUZvbGRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlcjtcbiIsICJpbXBvcnQgeyBGb2xkZXIgfSBmcm9tIFwiQGFnZW50YnJpZGdlL2FwaVwiO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgU3RhdHVzQ29kZXMgfSBmcm9tIFwiaHR0cC1zdGF0dXMtY29kZXNcIjtcbmltcG9ydCAqIGFzIGZvbGRlcnNTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9mb2xkZXJzLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IGlzQWRtaW5SZXF1ZXN0LCBUeXBlR3VhcmRFcnJvciB9IGZyb20gXCIuLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBsaXN0Rm9sZGVycyA9IGFzeW5jIChyZXE6IFJlcXVlc3Q8eyBzZXJ2ZXJJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHJlcS5sb2dnZXIuZGVidWcoXCJMaXN0aW5nIGZvbGRlcnNcIiwgeyBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgdGVuYW50SWQ6IHJlcS5hZG1pbi50ZW5hbnRJZCB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb2xkZXJzOiBGb2xkZXJbXSA9IGF3YWl0IGZvbGRlcnNTZXJ2aWNlLmxpc3RGb2xkZXJzKHJlcS5kYiwgcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgcmVxLmFkbWluLnRlbmFudElkKTtcbiAgICByZXMuanNvbihmb2xkZXJzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxpc3QgZm9sZGVyc1wiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oe1xuICAgICAgZXJyb3I6IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIkZhaWxlZCB0byBsaXN0IGZvbGRlcnNcIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUZvbGRlciA9IGFzeW5jIChcbiAgcmVxOiBSZXF1ZXN0PHsgc2VydmVySWQ6IHN0cmluZyB9LCBvYmplY3QsIHsgbmFtZTogc3RyaW5nOyBwYXJlbnRGb2xkZXJJZDogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5pbmZvKFwiQ3JlYXRpbmcgZm9sZGVyXCIsIHsgc2VydmVySWQ6IHJlcS5wYXJhbXMuc2VydmVySWQsIGJvZHk6IHJlcS5ib2R5IH0pO1xuICB0cnkge1xuICAgIGlmICghcmVxLmFkbWluLnRlbmFudElkKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5VTkFVVEhPUklaRUQpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJ1bmF1dGhvcml6ZWRcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJUZW5hbnQgSUQgaXMgcmVxdWlyZWRcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbGRlcjogRm9sZGVyID0gYXdhaXQgZm9sZGVyc1NlcnZpY2UuY3JlYXRlRm9sZGVyKFxuICAgICAgcmVxLmRiLFxuICAgICAgcmVxLnBhcmFtcy5zZXJ2ZXJJZCxcbiAgICAgIHJlcS5hZG1pbi50ZW5hbnRJZCxcbiAgICAgIHJlcS5ib2R5Lm5hbWUsXG4gICAgICByZXEuYm9keS5wYXJlbnRGb2xkZXJJZCxcbiAgICApO1xuXG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5DUkVBVEVEKS5qc29uKGZvbGRlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgZm9sZGVyXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBlcnJvcjogXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiRmFpbGVkIHRvIGNyZWF0ZSBmb2xkZXJcIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUZvbGRlciA9IGFzeW5jIChcbiAgcmVxOiBSZXF1ZXN0PHsgc2VydmVySWQ6IHN0cmluZzsgZm9sZGVySWQ6IHN0cmluZyB9LCBvYmplY3QsIHsgbmFtZTogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5pbmZvKFwiVXBkYXRpbmcgZm9sZGVyXCIsIHtcbiAgICBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCxcbiAgICBmb2xkZXJJZDogcmVxLnBhcmFtcy5mb2xkZXJJZCxcbiAgICBib2R5OiByZXEuYm9keSxcbiAgICB0ZW5hbnRJZDogcmVxLmFkbWluLnRlbmFudElkLFxuICB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IGZvbGRlcjogRm9sZGVyID0gYXdhaXQgZm9sZGVyc1NlcnZpY2UudXBkYXRlRm9sZGVyKFxuICAgICAgcmVxLmRiLFxuICAgICAgcmVxLnBhcmFtcy5mb2xkZXJJZCxcbiAgICAgIHJlcS5wYXJhbXMuc2VydmVySWQsXG4gICAgICByZXEuYWRtaW4udGVuYW50SWQsXG4gICAgICByZXEuYm9keS5uYW1lLFxuICAgICk7XG5cbiAgICByZXMuanNvbihmb2xkZXIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIGZvbGRlclwiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oe1xuICAgICAgZXJyb3I6IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIkZhaWxlZCB0byB1cGRhdGUgZm9sZGVyXCIsXG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVGb2xkZXIgPSBhc3luYyAocmVxOiBSZXF1ZXN0PHsgc2VydmVySWQ6IHN0cmluZzsgZm9sZGVySWQ6IHN0cmluZyB9PiwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuaW5mbyhcIkRlbGV0aW5nIGZvbGRlclwiLCB7IHNlcnZlcklkOiByZXEucGFyYW1zLnNlcnZlcklkLCBmb2xkZXJJZDogcmVxLnBhcmFtcy5mb2xkZXJJZCB9KTtcblxuICB0cnkge1xuICAgIGF3YWl0IGZvbGRlcnNTZXJ2aWNlLmRlbGV0ZUZvbGRlcihyZXEuZGIsIHJlcS5wYXJhbXMuZm9sZGVySWQsIHJlcS5wYXJhbXMuc2VydmVySWQsIHJlcS5hZG1pbi50ZW5hbnRJZCk7XG5cbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk5PX0NPTlRFTlQpLnNlbmQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBmb2xkZXJcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHtcbiAgICAgIGVycm9yOiBcImludGVybmFsX3NlcnZlcl9lcnJvclwiLFxuICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJGYWlsZWQgdG8gZGVsZXRlIGZvbGRlclwiLFxuICAgIH0pO1xuICB9XG59O1xuIiwgImltcG9ydCB7IEZvbGRlciB9IGZyb20gXCJAYWdlbnRicmlkZ2UvYXBpXCI7XG5pbXBvcnQgeyBGb2xkZXIgYXMgRm9sZGVyUHJpc21hIH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgeyBEYXRhYmFzZSB9IGZyb20gXCIuLi91dGlscy9jb25uZWN0aW9uLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBtYXBGb2xkZXIgPSAoZm9sZGVyOiBGb2xkZXJQcmlzbWEpOiBGb2xkZXIgPT4gKHtcbiAgLi4uZm9sZGVyLFxuICBwYXJlbnRGb2xkZXJJZDogZm9sZGVyLnBhcmVudEZvbGRlcklkIHx8IHVuZGVmaW5lZCxcbiAgY3JlYXRlZEF0OiBmb2xkZXIuY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gIHVwZGF0ZWRBdDogZm9sZGVyLnVwZGF0ZWRBdC50b0lTT1N0cmluZygpLFxufSk7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsaXN0Rm9sZGVycyhkYjogRGF0YWJhc2UsIHNlcnZlcklkOiBzdHJpbmcsIHRlbmFudElkOiBzdHJpbmcpOiBQcm9taXNlPEZvbGRlcltdPiB7XG4gIGNvbnN0IGZvbGRlcnMgPSBhd2FpdCBkYi5mb2xkZXIuZmluZE1hbnkoe1xuICAgIHdoZXJlOiB7XG4gICAgICBzZXJ2ZXJJZCxcbiAgICAgIHRlbmFudElkLFxuICAgIH0sXG4gICAgb3JkZXJCeTogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImFzY1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYXNjXCIsXG4gICAgICB9LFxuICAgIF0sXG4gIH0pO1xuICByZXR1cm4gZm9sZGVycy5tYXAobWFwRm9sZGVyKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZvbGRlcihcbiAgZGI6IERhdGFiYXNlLFxuICBzZXJ2ZXJJZDogc3RyaW5nLFxuICB0ZW5hbnRJZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIHBhcmVudEZvbGRlcklkPzogc3RyaW5nLFxuKTogUHJvbWlzZTxGb2xkZXI+IHtcbiAgY29uc3QgZm9sZGVyID0gYXdhaXQgZGIuZm9sZGVyLmNyZWF0ZSh7XG4gICAgZGF0YToge1xuICAgICAgbmFtZSxcbiAgICAgIHBhcmVudEZvbGRlcklkLFxuICAgICAgdGVuYW50SWQsXG4gICAgICBzZXJ2ZXJJZCxcbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIG1hcEZvbGRlcihmb2xkZXIpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRm9sZGVyKFxuICBkYjogRGF0YWJhc2UsXG4gIGZvbGRlcklkOiBzdHJpbmcsXG4gIHNlcnZlcklkOiBzdHJpbmcsXG4gIHRlbmFudElkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8Rm9sZGVyPiB7XG4gIGNvbnN0IGZvbGRlciA9IGF3YWl0IGRiLmZvbGRlci51cGRhdGUoe1xuICAgIHdoZXJlOiB7XG4gICAgICBpZDogZm9sZGVySWQsXG4gICAgICBzZXJ2ZXJJZCxcbiAgICAgIHRlbmFudElkLFxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgbmFtZSxcbiAgICB9LFxuICB9KTtcbiAgcmV0dXJuIG1hcEZvbGRlcihmb2xkZXIpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlRm9sZGVyKGRiOiBEYXRhYmFzZSwgZm9sZGVySWQ6IHN0cmluZywgc2VydmVySWQ6IHN0cmluZywgdGVuYW50SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBkYi5mb2xkZXIuZGVsZXRlKHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IGZvbGRlcklkLFxuICAgICAgc2VydmVySWQsXG4gICAgICB0ZW5hbnRJZCxcbiAgICB9LFxuICB9KTtcbn1cbiIsICJpbXBvcnQgZXhwcmVzcyBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgZ2V0SGVhbHRoIH0gZnJvbSBcIi4uL2NvbnRyb2xsZXJzL2hlYWx0aC5jb250cm9sbGVyLmpzXCI7XG5cbmNvbnN0IHJvdXRlciA9IGV4cHJlc3MuUm91dGVyKCk7XG5cbnJvdXRlci5nZXQoXCIvXCIsIGdldEhlYWx0aCk7XG5yb3V0ZXIuZ2V0KFwiL3JlYWR5XCIsIGdldEhlYWx0aCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlcjtcbiIsICJpbXBvcnQgeyBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBTdGF0dXNDb2RlcyB9IGZyb20gXCJodHRwLXN0YXR1cy1jb2Rlc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0SGVhbHRoID0gKF9yZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5PSykuanNvbih7IHN0YXR1czogXCJzdWNjZXNzXCIgfSk7XG59O1xuIiwgImltcG9ydCB7IE5leHRGdW5jdGlvbiwgUmVxdWVzdCwgUmVxdWVzdEhhbmRsZXIsIFJlc3BvbnNlLCBSb3V0ZXIgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIndpbnN0b25cIjtcbmltcG9ydCB7IGhhbmRsZU5vdEFsbG93ZWQsIGhhbmRsZVNTRSwgaGFuZGxlU1NFTWVzc2FnZSwgaGFuZGxlU3RyZWFtYWJsZVBvc3QgfSBmcm9tIFwiLi4vY29udHJvbGxlcnMvbWNwLmNvbnRyb2xsZXIuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVNlcnZlckF1dGhNaWRkbGV3YXJlIH0gZnJvbSBcIi4uL21pZGRsZXdhcmUvc2VydmVyLWF1dGgubWlkZGxld2FyZS5qc1wiO1xuaW1wb3J0IHsgc2VydmVySWRNaWRkbGV3YXJlIH0gZnJvbSBcIi4uL21pZGRsZXdhcmVzL3NlcnZlcklkLm1pZGRsZXdhcmUuanNcIjtcbmltcG9ydCB7IFNlcnZlckF1dGhTZXJ2aWNlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL3NlcnZlci1hdXRoLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IEFwcFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5jb25zdCByb3V0ZXI6IFJvdXRlciA9IFJvdXRlcigpO1xuXG4vLyBDcmVhdGUgc2VydmVyIGF1dGggbWlkZGxld2FyZSBpbnN0YW5jZSAod2lsbCBiZSBpbmplY3RlZCB3aXRoIGRlcGVuZGVuY2llcyBpbiBhcHAgc2V0dXApXG5sZXQgc2VydmVyQXV0aE1pZGRsZXdhcmU6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVNlcnZlckF1dGhNaWRkbGV3YXJlPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwU2VydmVyQXV0aE1pZGRsZXdhcmUoc2VydmVyQXV0aFNlcnZpY2U6IFNlcnZlckF1dGhTZXJ2aWNlLCBsb2dnZXI/OiBMb2dnZXIpIHtcbiAgc2VydmVyQXV0aE1pZGRsZXdhcmUgPSBjcmVhdGVTZXJ2ZXJBdXRoTWlkZGxld2FyZShzZXJ2ZXJBdXRoU2VydmljZSwgbG9nZ2VyKTtcbn1cblxuLy8gRW5oYW5jZWQgc2VydmVyIGF1dGggbWlkZGxld2FyZSB0aGF0IHByb3Blcmx5IGhhbmRsZXMgQkFTRSBhdXRoIHVzZXIgY29udGV4dFxuY29uc3QgZW5oYW5jZWRTZXJ2ZXJBdXRoID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSwgbmV4dDogTmV4dEZ1bmN0aW9uKSA9PiB7XG4gIGNvbnN0IGFwcFJlcSA9IHJlcSBhcyBBcHBSZXF1ZXN0O1xuXG4gIC8vIEluaXRpYWxpemUgc2VydmVyIGF1dGggbWlkZGxld2FyZSBpZiBuZWVkZWRcbiAgaWYgKCFzZXJ2ZXJBdXRoTWlkZGxld2FyZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXJ2ZXJBdXRoU2VydmljZSA9IG5ldyBTZXJ2ZXJBdXRoU2VydmljZShhcHBSZXEuZGIsIGFwcFJlcS5sb2dnZXIpO1xuICAgICAgc2VydmVyQXV0aE1pZGRsZXdhcmUgPSBjcmVhdGVTZXJ2ZXJBdXRoTWlkZGxld2FyZShzZXJ2ZXJBdXRoU2VydmljZSwgYXBwUmVxLmxvZ2dlcik7XG4gICAgICBhcHBSZXEubG9nZ2VyPy5pbmZvKFwiU2VydmVyIGF1dGhlbnRpY2F0aW9uIG1pZGRsZXdhcmUgbGF6eS1pbml0aWFsaXplZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXBwUmVxLmxvZ2dlcj8uZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzZXJ2ZXIgYXV0aCBtaWRkbGV3YXJlOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDMpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJTZXJ2ZXIgYXV0aGVudGljYXRpb24gbm90IGNvbmZpZ3VyZWRcIixcbiAgICAgICAgZGV0YWlsczogXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBzZXJ2ZXIgYXV0aGVudGljYXRpb24gbWlkZGxld2FyZVwiLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlIHRoZSBzZXJ2ZXIgYXV0aCBtaWRkbGV3YXJlICh3aGljaCB1c2VzIHN0cmF0ZWd5IHBhdHRlcm4gaW50ZXJuYWxseSlcbiAgcmV0dXJuIHNlcnZlckF1dGhNaWRkbGV3YXJlKGFwcFJlcSwgcmVzLCBuZXh0KTtcbn07XG5cbnJvdXRlci5wb3N0KFwiL2FwaS9tY3BcIiwgc2VydmVySWRNaWRkbGV3YXJlLCBlbmhhbmNlZFNlcnZlckF1dGgsIGhhbmRsZVN0cmVhbWFibGVQb3N0IGFzIHVua25vd24gYXMgUmVxdWVzdEhhbmRsZXIpO1xucm91dGVyLmdldChcIi9hcGkvbWNwXCIsIHNlcnZlcklkTWlkZGxld2FyZSwgZW5oYW5jZWRTZXJ2ZXJBdXRoLCBoYW5kbGVTU0UgYXMgdW5rbm93biBhcyBSZXF1ZXN0SGFuZGxlcik7XG5yb3V0ZXIucG9zdChcIi9hcGkvbWNwL21lc3NhZ2VzXCIsIHNlcnZlcklkTWlkZGxld2FyZSwgZW5oYW5jZWRTZXJ2ZXJBdXRoLCBoYW5kbGVTU0VNZXNzYWdlIGFzIHVua25vd24gYXMgUmVxdWVzdEhhbmRsZXIpO1xucm91dGVyLmRlbGV0ZShcIi9hcGkvbWNwXCIsIGhhbmRsZU5vdEFsbG93ZWQpO1xuXG5leHBvcnQgZGVmYXVsdCByb3V0ZXI7XG4iLCAiaW1wb3J0IHsgU1NFU2VydmVyVHJhbnNwb3J0IH0gZnJvbSBcIkBtb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL3NzZS5qc1wiO1xuaW1wb3J0IHsgU3RyZWFtYWJsZUhUVFBTZXJ2ZXJUcmFuc3BvcnQgfSBmcm9tIFwiQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zZXJ2ZXIvc3RyZWFtYWJsZUh0dHAuanNcIjtcbmltcG9ydCB7IFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IFN0YXR1c0NvZGVzIH0gZnJvbSBcImh0dHAtc3RhdHVzLWNvZGVzXCI7XG5pbXBvcnQgeyBnZXRNY3BTZXJ2ZXJVbmlmaWVkIH0gZnJvbSBcIi4uL3NlcnZpY2VzL21jcC5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQge1xuICBBUFBfQkFEX1JFUVVFU1QsXG4gIEVycm9yUmVzcG9uc2UsXG4gIEpTT05SUENfSU5URVJOQUxfRVJST1IsXG4gIEpTT05SUENfTUVUSE9EX05PVF9BTExPV0VELFxuICBKc29uUnBjRXJyb3JSZXNwb25zZSxcbn0gZnJvbSBcIi4uL3R5cGVzL2Vycm9yLnR5cGVzLmpzXCI7XG5pbXBvcnQgeyBBcHBSZXF1ZXN0LCBpc0FwcFJlcXVlc3QsIGlzV2l0aFNlcnZlcklkUmVxdWVzdCwgVHlwZUd1YXJkRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5mdW5jdGlvbiBzZW5kTWNwRXJyb3IocmVzOiBSZXNwb25zZSwgc3RhdHVzOiBudW1iZXIsIGVycm9yQ29kZTogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcsIGlzSnNvblJwYyA9IHRydWUpOiB2b2lkIHtcbiAgY29uc3QgZXJyb3IgPSBpc0pzb25ScGNcbiAgICA/ICh7IGpzb25ycGM6IFwiMi4wXCIsIGVycm9yOiB7IGNvZGU6IGVycm9yQ29kZSwgbWVzc2FnZSB9IH0gYXMgSnNvblJwY0Vycm9yUmVzcG9uc2UpXG4gICAgOiAoeyBlcnJvcjogeyBjb2RlOiBlcnJvckNvZGUsIG1lc3NhZ2UgfSB9IGFzIEVycm9yUmVzcG9uc2UpO1xuXG4gIHJlcy5zdGF0dXMoc3RhdHVzKS5qc29uKGVycm9yKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSByZXF1ZXN0IHBhcmFtcyBhbmQgYXV0aGVudGljYXRpb24gcmVzdWx0cyBmcm9tIG1pZGRsZXdhcmVcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2ltcGxpZmllZCBzaW5jZSBhdXRoZW50aWNhdGlvbiBpcyBub3cgaGFuZGxlZCBieSBtaWRkbGV3YXJlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUmVxdWVzdChyZXE6IEFwcFJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgaWYgKCFpc0FwcFJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgaWYgKCFpc1dpdGhTZXJ2ZXJJZFJlcXVlc3QocmVxKSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBcIk1pc3Npbmcgc2VydmVyIElEXCI7XG4gICAgcmVxLmxvZ2dlci53YXJuKGAke21lc3NhZ2V9LiBzZXJ2ZXJJZD0ke3JlcVtcInNlcnZlcklkXCJdfWApO1xuICAgIHNlbmRNY3BFcnJvcihyZXMsIFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNULCBBUFBfQkFEX1JFUVVFU1QsIGBCYWQgUmVxdWVzdDogJHttZXNzYWdlfWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGF1dGhlbnRpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIChoYW5kbGVkIGJ5IG1pZGRsZXdhcmUpXG4gIGlmICghcmVxLnNlcnZlckF1dGg/LnN1Y2Nlc3MpIHtcbiAgICBzZW5kTWNwRXJyb3IoXG4gICAgICByZXMsXG4gICAgICBTdGF0dXNDb2Rlcy5VTkFVVEhPUklaRUQsXG4gICAgICBBUFBfQkFEX1JFUVVFU1QsXG4gICAgICByZXEuc2VydmVyQXV0aD8uZXJyb3IgfHwgXCJTZXJ2ZXIgYXV0aGVudGljYXRpb24gZmFpbGVkXCIsXG4gICAgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXEubG9nZ2VyLmRlYnVnKFwiUmVxdWVzdCB2YWxpZGF0aW9uIHN1Y2Nlc3NmdWxcIiwge1xuICAgIHNlcnZlcklkOiByZXEuc2VydmVySWQsXG4gICAgYXV0aFR5cGU6IHJlcS5zZXJ2ZXJBdXRoLnVzZXJDb250ZXh0Py5hdXRoVHlwZSxcbiAgICB1c2VySWQ6IHJlcS5zZXJ2ZXJBdXRoLnVzZXJDb250ZXh0Py51c2VySWQsXG4gIH0pO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlU3RyZWFtYWJsZVBvc3QocmVxOiBBcHBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmICghaXNXaXRoU2VydmVySWRSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVmFsaWRhdGUgcmVxdWVzdCBhbmQgYXV0aGVudGljYXRpb24gKHNpbXBsaWZpZWQgc2luY2UgbWlkZGxld2FyZSBoYW5kbGVzIGF1dGgpXG4gICAgaWYgKCEoYXdhaXQgdmFsaWRhdGVSZXF1ZXN0KHJlcSwgcmVzKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtY3BTZXJ2ZXIgPSBhd2FpdCBnZXRNY3BTZXJ2ZXJVbmlmaWVkKHJlcSk7XG4gICAgY29uc3QgdHJhbnNwb3J0OiBTdHJlYW1hYmxlSFRUUFNlcnZlclRyYW5zcG9ydCA9IG5ldyBTdHJlYW1hYmxlSFRUUFNlcnZlclRyYW5zcG9ydCh7XG4gICAgICBzZXNzaW9uSWRHZW5lcmF0b3I6IHVuZGVmaW5lZCxcbiAgICB9KTtcblxuICAgIHJlcy5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgbWNwU2VydmVyLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgYXdhaXQgbWNwU2VydmVyLmNvbm5lY3QodHJhbnNwb3J0KTtcbiAgICBhd2FpdCB0cmFuc3BvcnQuaGFuZGxlUmVxdWVzdChyZXEsIHJlcywgcmVxLmJvZHkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJFcnJvciBoYW5kbGluZyBNQ1Agc3RyZWFtYWJsZSBIVFRQIFBPU1QgcmVxdWVzdFwiLCBlcnJvcik7XG4gICAgaWYgKCFyZXMuaGVhZGVyc1NlbnQpIHtcbiAgICAgIHNlbmRNY3BFcnJvcihyZXMsIFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUiwgSlNPTlJQQ19JTlRFUk5BTF9FUlJPUiwgXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIik7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHNzZVRyYW5zcG9ydHM6IHsgW3Nlc3Npb25JZDogc3RyaW5nXTogU1NFU2VydmVyVHJhbnNwb3J0IH0gPSB7fTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVNTRShyZXE6IEFwcFJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCFpc1dpdGhTZXJ2ZXJJZFJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgcmVxdWVzdCBhbmQgYXV0aGVudGljYXRpb24gKHNpbXBsaWZpZWQgc2luY2UgbWlkZGxld2FyZSBoYW5kbGVzIGF1dGgpXG4gIGlmICghKGF3YWl0IHZhbGlkYXRlUmVxdWVzdChyZXEsIHJlcykpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFNTRVNlcnZlclRyYW5zcG9ydChcIi9hcGkvbWNwL21lc3NhZ2VzXCIsIHJlcyk7XG4gIHNzZVRyYW5zcG9ydHNbdHJhbnNwb3J0LnNlc3Npb25JZF0gPSB0cmFuc3BvcnQ7XG5cbiAgcmVzLm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICBkZWxldGUgc3NlVHJhbnNwb3J0c1t0cmFuc3BvcnQuc2Vzc2lvbklkXTtcbiAgfSk7XG5cbiAgY29uc3Qgc2VydmVyID0gYXdhaXQgZ2V0TWNwU2VydmVyVW5pZmllZChyZXEpO1xuICBhd2FpdCBzZXJ2ZXIuY29ubmVjdCh0cmFuc3BvcnQpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlU1NFTWVzc2FnZShyZXE6IEFwcFJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCFpc1dpdGhTZXJ2ZXJJZFJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIGNvbnN0IHNlc3Npb25JZCA9IHJlcS5xdWVyeS5zZXNzaW9uSWQgYXMgc3RyaW5nO1xuXG4gIC8vIFZhbGlkYXRlIHJlcXVlc3QgYW5kIGF1dGhlbnRpY2F0aW9uIChzaW1wbGlmaWVkIHNpbmNlIG1pZGRsZXdhcmUgaGFuZGxlcyBhdXRoKVxuICBpZiAoIShhd2FpdCB2YWxpZGF0ZVJlcXVlc3QocmVxLCByZXMpKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zcG9ydCA9IHNlc3Npb25JZCA/IHNzZVRyYW5zcG9ydHNbc2Vzc2lvbklkXSA6IG51bGw7XG4gIGlmICghdHJhbnNwb3J0KSB7XG4gICAgaWYgKHNlc3Npb25JZCkge1xuICAgICAgcmVxLmxvZ2dlci5lcnJvcihcIlNlc3Npb24gc3BlY2lmaWVkIGJ1dCBub3QgZm91bmRcIiwgeyBzZXNzaW9uSWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZW5kTWNwRXJyb3IocmVzLCBTdGF0dXNDb2Rlcy5OT1RfRk9VTkQsIEFQUF9CQURfUkVRVUVTVCwgXCJTZXNzaW9uIG5vdCBmb3VuZFwiKTtcbiAgfVxuXG4gIGF3YWl0IHRyYW5zcG9ydC5oYW5kbGVQb3N0TWVzc2FnZShyZXEsIHJlcywgcmVxLmJvZHkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTm90QWxsb3dlZChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCFpc0FwcFJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmV0dXJuIHNlbmRNY3BFcnJvcihyZXMsIFN0YXR1c0NvZGVzLk1FVEhPRF9OT1RfQUxMT1dFRCwgSlNPTlJQQ19NRVRIT0RfTk9UX0FMTE9XRUQsIFwiTWV0aG9kIG5vdCBhbGxvd2VkXCIpO1xufVxuIiwgImltcG9ydCB7IE1jcFNlcnZlciB9IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NlcnZlci9tY3AuanNcIjtcbmltcG9ydCB7IEFwaUtleVByb3ZpZGVyLCBPQXV0aFByb3ZpZGVyLCBUb29sIH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgaXNFbXB0eSBmcm9tIFwibG9kYXNoL2lzRW1wdHkuanNcIjtcbmltcG9ydCB7IE9wZW5BUElWMyB9IGZyb20gXCJvcGVuYXBpLXR5cGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwid2luc3RvblwiO1xuaW1wb3J0IHsgaW5qZWN0Q29udGV4dFBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vY29uc3RhbnRzL3Rvb2wtcGFyYW1ldGVycy5qc1wiO1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tIFwiLi4vdXRpbHMvY29ubmVjdGlvbi5qc1wiO1xuaW1wb3J0IHsgRW5kVXNlclJlcXVlc3QsIFdpdGhTZXJ2ZXJJZFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuaW1wb3J0IHsgYW5hbHl0aWNzIH0gZnJvbSBcIi4vYW5hbHl0aWNzLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IGV4ZWN1dGVBcGlSZXF1ZXN0IH0gZnJvbSBcIi4vYXBpLWV4ZWMvYXBpLXRvb2wtZXhlY3V0b3IuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVpvZFNjaGVtYUZyb21QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vYXBpLWV4ZWMvcGFyYW1ldGVyLXNjaGVtYS5qc1wiO1xuaW1wb3J0IHtcbiAgZ2V0QXV0aG9yaXplVXJsLFxuICBnZXRVc2VyVXNlYWJsZVRva2VucyxcbiAgbWFya1Rva2VuQXNVc2VkLFxuICByZWZyZXNoQW5kUGVyc2lzdEFjY2Vzc1Rva2VuLFxuICBUT09MX1NDT1BFLFxufSBmcm9tIFwiLi9vYXV0aC5zZXJ2aWNlLmpzXCI7XG5cbi8vIGRvIG5vdCBjaGFuZ2UgdGhlIHBocmFzaW5nIG9mIHRoaXMgbWVzc2FnZSwgaXQgaXMgdXNlZCBieSBtY3AtcmVtb3RlIHRvIGRldGVjdCBicm93c2VyIG9wZW4gbmVlZGVkXG5jb25zdCBhdXRoZW50aWNhdGVNZXNzYWdlID0gKHVybDogc3RyaW5nKSA9PiBgUGxlYXNlIGF1dGhlbnRpY2F0ZSBiZWZvcmUgcHJvY2VlZGluZy5cblxuVGhlIGZvbGxvd2luZyBVUkwgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgb3BlbmVkIGluIHlvdXIgYnJvd3NlciwgYnV0IGlmIGl0IGRvZXNuJ3QsIHBsZWFzZSBvcGVuIGl0IG1hbnVhbGx5OlxuXG4ke3VybH1cblxuT25jZSBhdXRoZW50aWNhdGlvbiBpcyBjb21wbGV0ZSwgcmUtcnVuIHlvdXIgb3JpZ2luYWwgcXVlcnkuYDtcblxuLy8gQ29uc3RhbnRzXG5jb25zdCBDT05TVEFOVFMgPSB7XG4gIFNZTlRIRVRJQ19FTUFJTF9ET01BSU46IFwiQGp3dC5hZ2VudHBhc3MuYWlcIixcbiAgTUNQX1NFUlZFUl9WRVJTSU9OOiBcIjEuMC4wXCIsXG59IGFzIGNvbnN0O1xuXG4vLyBFcnJvciByZXNwb25zZSBidWlsZGVyc1xuY29uc3QgRVJST1JfTUVTU0FHRVMgPSB7XG4gIEFVVEhfUFJPVklERVJfTUlTQ09ORklHVVJFRDpcbiAgICBcIk9vcHMhIFdlIGNvdWxkbid0IGNvbXBsZXRlIHRoZSByZXF1ZXN0IGR1ZSB0byBhbiBhdXRob3JpemF0aW9uIGlzc3VlLiBQbGVhc2UgZ2V0IGluIHRvdWNoIHdpdGggeW91ciBNQ1Agc2VydmVyIGFkbWluaXN0cmF0b3IuXCIsXG4gIFRPT0xfRVhFQ1VUSU9OX0VSUk9SOiAoZXJyb3I6IHVua25vd24pID0+XG4gICAgYEVycm9yIGV4ZWN1dGluZyB0b29sOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gLFxufSBhcyBjb25zdDtcblxuY29uc3QgY3JlYXRlRXJyb3JSZXNwb25zZSA9IChtZXNzYWdlOiBzdHJpbmcsIGlzRXJyb3IgPSB0cnVlKSA9PiAoe1xuICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiBhcyBjb25zdCwgdGV4dDogbWVzc2FnZSB9XSxcbiAgaXNFcnJvcixcbn0pO1xuXG5jb25zdCBjcmVhdGVBdXRoUmVzcG9uc2UgPSAoYXV0aFVybDogc3RyaW5nKSA9PiAoe1xuICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiBhcyBjb25zdCwgdGV4dDogYXV0aGVudGljYXRlTWVzc2FnZShhdXRoVXJsKSB9XSxcbn0pO1xuXG4vKipcbiAqIFBhcnNlIEpXVCB0b2tlbiBhbmQgZXh0cmFjdCBjbGFpbXMgd2l0aG91dCB2ZXJpZmljYXRpb25cbiAqIFRoaXMgaXMgc2FmZSBzaW5jZSB3ZSdyZSBvbmx5IHVzaW5nIGl0IGZvciB0ZW1wbGF0ZSB2YXJpYWJsZXMsIG5vdCBzZWN1cml0eVxuICovXG5mdW5jdGlvbiBwYXJzZUp3dENsYWltcyhqd3Q6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgdHJ5IHtcbiAgICAvLyBKV1QgZm9ybWF0OiBoZWFkZXIucGF5bG9hZC5zaWduYXR1cmVcbiAgICBjb25zdCBwYXJ0cyA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8vIERlY29kZSB0aGUgaGVhZGVyIChmaXJzdCBwYXJ0KVxuICAgIGNvbnN0IGhlYWRlciA9IHBhcnRzWzBdO1xuICAgIGNvbnN0IHBhZGRlZEhlYWRlciA9IGhlYWRlciArIFwiPVwiLnJlcGVhdCgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCk7XG4gICAgY29uc3QgZGVjb2RlZEhlYWRlciA9IEJ1ZmZlci5mcm9tKHBhZGRlZEhlYWRlciwgXCJiYXNlNjR1cmxcIikudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgIGNvbnN0IGhlYWRlckNsYWltcyA9IEpTT04ucGFyc2UoZGVjb2RlZEhlYWRlcik7XG5cbiAgICAvLyBEZWNvZGUgdGhlIHBheWxvYWQgKHNlY29uZCBwYXJ0KVxuICAgIGNvbnN0IHBheWxvYWQgPSBwYXJ0c1sxXTtcbiAgICBjb25zdCBwYWRkZWRQYXlsb2FkID0gcGF5bG9hZCArIFwiPVwiLnJlcGVhdCgoNCAtIChwYXlsb2FkLmxlbmd0aCAlIDQpKSAlIDQpO1xuICAgIGNvbnN0IGRlY29kZWRQYXlsb2FkID0gQnVmZmVyLmZyb20ocGFkZGVkUGF5bG9hZCwgXCJiYXNlNjR1cmxcIikudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgIGNvbnN0IHBheWxvYWRDbGFpbXMgPSBKU09OLnBhcnNlKGRlY29kZWRQYXlsb2FkKTtcblxuICAgIC8vIENvbWJpbmUgaGVhZGVyIGFuZCBwYXlsb2FkIGNsYWltcyAocGF5bG9hZCB0YWtlcyBwcmVjZWRlbmNlIGZvciBkdXBsaWNhdGVzKVxuICAgIHJldHVybiB7IC4uLmhlYWRlckNsYWltcywgLi4ucGF5bG9hZENsYWltcyB9O1xuICB9IGNhdGNoIHtcbiAgICAvLyBJZiBwYXJzaW5nIGZhaWxzLCByZXR1cm4gZW1wdHkgb2JqZWN0XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8qKlxuICogVW5pZmllZCBNQ1Agc2VydmVyIGNyZWF0aW9uIHRoYXQgd29ya3Mgd2l0aCBhbnkgYXV0aGVudGljYXRpb24gc3RyYXRlZ3lcbiAqIFVzZXMgc3RyYXRlZ3kgcGF0dGVybiB0byBkZXRlcm1pbmUgd2hhdCBhdXRoZW50aWNhdGlvbiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNY3BTZXJ2ZXJVbmlmaWVkKHJlcTogV2l0aFNlcnZlcklkUmVxdWVzdCk6IFByb21pc2U8TWNwU2VydmVyPiB7XG4gIC8vIENoZWNrIGF1dGhlbnRpY2F0aW9uIGJhc2VkIG9uIHdoYXQncyBhdmFpbGFibGUgaW4gdGhlIHJlcXVlc3RcbiAgY29uc3QgaGFzVXNlckF1dGggPSBCb29sZWFuKFwidXNlclwiIGluIHJlcSAmJiByZXEudXNlcik7XG4gIGNvbnN0IGhhc1NlcnZlckF1dGggPSBCb29sZWFuKFwic2VydmVyQXV0aFwiIGluIHJlcSAmJiByZXEuc2VydmVyQXV0aD8uc3VjY2Vzcyk7XG5cbiAgaWYgKCFoYXNVc2VyQXV0aCAmJiAhaGFzU2VydmVyQXV0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIGF1dGhlbnRpY2F0aW9uIGZvdW5kXCIpO1xuICB9XG5cbiAgY29uc3Qgc2VydmVySWQgPSByZXEuc2VydmVySWQ7XG5cbiAgY29uc3Qgc2VydmVyID0gbmV3IE1jcFNlcnZlcihcbiAgICB7XG4gICAgICBuYW1lOiBzZXJ2ZXJJZCxcbiAgICAgIHZlcnNpb246IENPTlNUQU5UUy5NQ1BfU0VSVkVSX1ZFUlNJT04sXG4gICAgfSxcbiAgICB7IGNhcGFiaWxpdGllczogeyBsb2dnaW5nOiB7fSB9IH0sXG4gICk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0b29scyA9IGF3YWl0IHJlcS5kYi50b29sLmZpbmRNYW55KHtcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIHNlcnZlcklkOiBzZXJ2ZXJJZCxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBpbmNsdWRlOiB7XG4gICAgICAgIG9BdXRoUHJvdmlkZXI6IHRydWUsXG4gICAgICAgIGFwaUtleVByb3ZpZGVyOiB0cnVlLFxuICAgICAgICBzZXJ2ZXI6IHtcbiAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIGJhc2VVcmw6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhgRm91bmQgJHt0b29scy5sZW5ndGh9IHRvb2xzIGZvciBzZXJ2ZXIgJHtzZXJ2ZXJJZH1gKTtcblxuICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgICAgYXdhaXQgcmVnaXN0ZXJUb29sVW5pZmllZChyZXEsIHNlcnZlciwgdG9vbCwgaGFzVXNlckF1dGgsIGhhc1NlcnZlckF1dGgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKGBFcnJvciBsb2FkaW5nIHRvb2xzIGZvciBzZXJ2ZXIgJHtzZXJ2ZXJJZH06YCwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHNlcnZlcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVnaXN0ZXJUb29sVW5pZmllZChcbiAgcmVxOiBXaXRoU2VydmVySWRSZXF1ZXN0LFxuICBzZXJ2ZXI6IE1jcFNlcnZlcixcbiAgdG9vbDogVG9vbCAmIHtcbiAgICBvQXV0aFByb3ZpZGVyOiBPQXV0aFByb3ZpZGVyIHwgbnVsbDtcbiAgICBhcGlLZXlQcm92aWRlcjogQXBpS2V5UHJvdmlkZXIgfCBudWxsO1xuICAgIHNlcnZlcjogeyBiYXNlVXJsOiBzdHJpbmcgfTtcbiAgfSxcbiAgaGFzVXNlckF1dGg6IGJvb2xlYW4sXG4gIGhhc1NlcnZlckF1dGg6IGJvb2xlYW4sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzcGVjUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgT3BlbkFQSVYzLlBhcmFtZXRlck9iamVjdD4gPSB0b29sLnBhcmFtZXRlcnNcbiAgICAgID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0b29sLnBhcmFtZXRlcnMpKVxuICAgICAgOiB7fTtcbiAgICByZXEubG9nZ2VyLmRlYnVnKGBUb29sICR7dG9vbC5tZXRob2R9ICR7dG9vbC51cmx9IHBhcmFtZXRlcnM6ICR7SlNPTi5zdHJpbmdpZnkoc3BlY1BhcmFtZXRlcnMpfWApO1xuICAgIGNvbnN0IHBhcmFtU2NoZW1hID0gY3JlYXRlWm9kU2NoZW1hRnJvbVBhcmFtZXRlcnMocmVxLmxvZ2dlciwgc3BlY1BhcmFtZXRlcnMpO1xuXG4gICAgLy8gVHlwZVNjcmlwdCBoYXMgaXNzdWVzIHdpdGggTUNQIFNESydzIGRlZXAgdHlwZSBpbnN0YW50aWF0aW9uXG4gICAgLy8gVXNpbmcgYW55IHRvIGJ5cGFzcyB0aGlzIGxpbWl0YXRpb25cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIChzZXJ2ZXIgYXMgYW55KS5yZWdpc3RlclRvb2woXG4gICAgICB0b29sLm5hbWUsXG4gICAgICB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICBpbnB1dFNjaGVtYTogcGFyYW1TY2hlbWEsXG4gICAgICB9LFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIChjYWxsUGFyYW1ldGVyczogYW55KSA9PlxuICAgICAgICBleGVjdXRlVG9vbFdpdGhBdXRoKHJlcSwgdG9vbCwgc3BlY1BhcmFtZXRlcnMsIGNhbGxQYXJhbWV0ZXJzLCBoYXNVc2VyQXV0aCwgaGFzU2VydmVyQXV0aCksXG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcmVnaXN0ZXIgdG9vbCAke3Rvb2wubmFtZX06YCwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSB0b29sIHdpdGggcHJvcGVyIGF1dGhlbnRpY2F0aW9uIGFuZCBsb2dnaW5nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29sV2l0aEF1dGgoXG4gIHJlcTogV2l0aFNlcnZlcklkUmVxdWVzdCxcbiAgdG9vbDogVG9vbCAmIHtcbiAgICBvQXV0aFByb3ZpZGVyOiBPQXV0aFByb3ZpZGVyIHwgbnVsbDtcbiAgICBhcGlLZXlQcm92aWRlcjogQXBpS2V5UHJvdmlkZXIgfCBudWxsO1xuICAgIHNlcnZlcjogeyBiYXNlVXJsOiBzdHJpbmcgfTtcbiAgfSxcbiAgc3BlY1BhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIE9wZW5BUElWMy5QYXJhbWV0ZXJPYmplY3Q+LFxuICBjYWxsUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGhhc1VzZXJBdXRoOiBib29sZWFuLFxuICBoYXNTZXJ2ZXJBdXRoOiBib29sZWFuLFxuKSB7XG4gIHJlcS5sb2dnZXIuZGVidWcoXG4gICAgYFRvb2wgJHt0b29sLm5hbWV9ICgke3Rvb2wubWV0aG9kfSBAICR7dG9vbC51cmx9KSBjYWxsZWQgd2l0aCBwYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkoY2FsbFBhcmFtZXRlcnMpfWAsXG4gICk7XG5cbiAgdHJ5IHtcbiAgICAvLyBJbmplY3QgY29udGV4dCBwYXJhbWV0ZXJzIChKV1QsIHVzZXIgaW5mbywgZXRjLikgYmFzZWQgb24gcmVxdWVzdCBjb250ZXh0XG4gICAgaW5qZWN0Q29udGV4dFBhcmFtZXRlcnMocmVxLCBjYWxsUGFyYW1ldGVycywgaGFzVXNlckF1dGgpO1xuXG4gICAgLy8gRXh0cmFjdCBhdXRoIGNvbnRleHQgZm9yIHRlbXBsYXRlc1xuICAgIGNvbnN0IGp3dFRva2VuID0gKCFoYXNVc2VyQXV0aCAmJiBcInNlcnZlckF1dGhcIiBpbiByZXEgJiYgcmVxLnNlcnZlckF1dGg/LnVzZXJDb250ZXh0Py5vcmlnaW5hbFRva2VuKSB8fCB1bmRlZmluZWQ7XG4gICAgY29uc3Qgand0Q2xhaW1zID0gcGFyc2VKd3RDbGFpbXMoand0VG9rZW4gfHwgXCJcIik7XG4gICAgY29uc3QgYXV0aENvbnRleHQgPSB7XG4gICAgICBqd3Q6IHtcbiAgICAgICAgLy8gUmF3IEpXVCBzdHJpbmcgYWNjZXNzaWJsZSBhcyB7e2F1dGguand0fX1cbiAgICAgICAgdG9TdHJpbmc6ICgpID0+IGp3dFRva2VuIHx8IFwiXCIsXG4gICAgICAgIHZhbHVlT2Y6ICgpID0+IGp3dFRva2VuIHx8IFwiXCIsXG4gICAgICAgIC8vIEpXVCBjbGFpbXMgYWNjZXNzaWJsZSBhcyB7e2F1dGguand0LnByb3BlcnR5TmFtZX19XG4gICAgICAgIC4uLmp3dENsYWltcyxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaW4gZmV3IHJlbGVhc2VzXG4gICAgLy8gQWRkIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGFsc28gaW5qZWN0IEpXVCBhcyB0b29sUGFyYW1zLmp3dCBmb3IgZXhpc3RpbmcgdGVtcGxhdGVzXG4gICAgaWYgKGp3dFRva2VuKSB7XG4gICAgICBjYWxsUGFyYW1ldGVycy5qd3QgPSBqd3RUb2tlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdG9vbCBhdXRoZW50aWNhdGlvbiAoT0F1dGgvQVBJIGtleSkgLSBpbmRlcGVuZGVudCBvZiBNQ1Agc2VydmVyIGF1dGggdHlwZVxuICAgIGNvbnN0IHRvb2xBdXRoUmVzdWx0ID0gYXdhaXQgaGFuZGxlVG9vbEF1dGhlbnRpY2F0aW9uKHJlcSwgdG9vbCwgaGFzVXNlckF1dGgsIGhhc1NlcnZlckF1dGgpO1xuXG4gICAgaWYgKHRvb2xBdXRoUmVzdWx0LmF1dGhQcm92aWRlck1pc2NvbmZpZ3VyZWQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFcnJvclJlc3BvbnNlKEVSUk9SX01FU1NBR0VTLkFVVEhfUFJPVklERVJfTUlTQ09ORklHVVJFRCk7XG4gICAgfVxuXG4gICAgaWYgKHRvb2xBdXRoUmVzdWx0LmF1dGhNaXNzaW5nKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQXV0aFJlc3BvbnNlKHRvb2xBdXRoUmVzdWx0LmF1dGhNaXNzaW5nLmF1dGhVcmwpO1xuICAgIH1cblxuICAgIGlmICh0b29sQXV0aFJlc3VsdC5hY2Nlc3NUb2tlbikge1xuICAgICAgY2FsbFBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke3Rvb2xBdXRoUmVzdWx0LmFjY2Vzc1Rva2VuLnRva2VuVmFsdWV9YDtcbiAgICAgIGNvbnN0IHRva2VuSWQgPSB0b29sQXV0aFJlc3VsdC5hY2Nlc3NUb2tlbi50b2tlbklkO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IG1hcmtUb2tlbkFzVXNlZChyZXEuZGIsIHRva2VuSWQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVBcGlSZXF1ZXN0KFxuICAgICAgdG9vbCxcbiAgICAgIHRvb2wuc2VydmVyLmJhc2VVcmwsXG4gICAgICBzcGVjUGFyYW1ldGVycyxcbiAgICAgIGNhbGxQYXJhbWV0ZXJzLFxuICAgICAgcmVxLmxvZ2dlcixcbiAgICAgIGZhbHNlLFxuICAgICAgYXV0aENvbnRleHQsXG4gICAgKTtcblxuICAgIC8vIExvZyBleGVjdXRpb24gYmFzZWQgb24gYXV0aCB0eXBlXG4gICAgYXdhaXQgbG9nVG9vbEV4ZWN1dGlvbihyZXEsIHRvb2wsIHJlc3VsdCwgc3RhcnRUaW1lLCBoYXNVc2VyQXV0aCwgaGFzU2VydmVyQXV0aCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIud2FybihgRXJyb3IgZXhlY3V0aW5nIHRvb2wgJHt0b29sLm5hbWV9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gY3JlYXRlRXJyb3JSZXNwb25zZShFUlJPUl9NRVNTQUdFUy5UT09MX0VYRUNVVElPTl9FUlJPUihlcnJvcikpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvZ1VzZXJUb29sRXhlY3V0aW9uKFxuICByZXE6IEVuZFVzZXJSZXF1ZXN0ICYgV2l0aFNlcnZlcklkUmVxdWVzdCxcbiAgdG9vbDoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgc2VydmVySWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWV0aG9kOiBzdHJpbmc7XG4gICAgb0F1dGhQcm92aWRlcklkPzogc3RyaW5nIHwgbnVsbDtcbiAgICBhcGlLZXlQcm92aWRlcklkPzogc3RyaW5nIHwgbnVsbDtcbiAgfSxcbiAgcmVzdWx0OiB7IGlzRXJyb3I/OiBib29sZWFuIH0sXG4gIHN0YXJ0VGltZTogbnVtYmVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFRyYWNrIHRvb2wgZXhlY3V0aW9uIGluIFBvc3RIb2dcbiAgYW5hbHl0aWNzLnRyYWNrKHJlcS51c2VyLmlkLCBcInRvb2wuZXhlY3V0ZS5hcGlfY2FsbFwiLCB7XG4gICAgdG9vbF9pZDogdG9vbC5pZCxcbiAgICBzZXJ2ZXJfaWQ6IHRvb2wuc2VydmVySWQsXG4gICAgdGVuYW50X2lkOiByZXEudXNlci50ZW5hbnRJZCxcbiAgICBlbmRfdXNlcl9pZDogcmVxLnVzZXIuaWQsXG4gICAgdG9vbF9uYW1lOiB0b29sLm5hbWUsXG4gICAgaHR0cF9tZXRob2Q6IHRvb2wubWV0aG9kLFxuICAgIGhhc19hdXRoOiAhIXRvb2wub0F1dGhQcm92aWRlcklkIHx8ICEhdG9vbC5hcGlLZXlQcm92aWRlcklkLFxuICAgIGF1dGhfdHlwZTogdG9vbC5vQXV0aFByb3ZpZGVySWQgPyBcIm9hdXRoXCIgOiB0b29sLmFwaUtleVByb3ZpZGVySWQgPyBcImFwaV9rZXlcIiA6IFwibm9uZVwiLFxuICAgIGV4ZWN1dGlvbl90aW1lX21zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgIHN1Y2Nlc3M6ICFyZXN1bHQuaXNFcnJvcixcbiAgICBpc19wbGF5Z3JvdW5kOiBmYWxzZSxcbiAgfSk7XG5cbiAgcmVxLmxvZ2dlci5pbmZvKGBUb29sICR7dG9vbC5uYW1lfSBleGVjdXRlZCBmb3IgdXNlciAke3JlcS51c2VyLmVtYWlsfWAsIHtcbiAgICB0b29sX2lkOiB0b29sLmlkLFxuICAgIHNlcnZlcl9pZDogdG9vbC5zZXJ2ZXJJZCxcbiAgICB0b29sX25hbWU6IHRvb2wubmFtZSxcbiAgICBzdWNjZXNzOiAhcmVzdWx0LmlzRXJyb3IsXG4gICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgdXNlcl9pZDogcmVxLnVzZXIuaWQsXG4gIH0pO1xufVxuXG4vKipcbiAqIFVuaWZpZWQgbG9nZ2luZyBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgYm90aCB1c2VyIGFuZCBzZXJ2ZXIgYXV0aCBjb250ZXh0c1xuICovXG5hc3luYyBmdW5jdGlvbiBsb2dUb29sRXhlY3V0aW9uKFxuICByZXE6IFdpdGhTZXJ2ZXJJZFJlcXVlc3QsXG4gIHRvb2w6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHNlcnZlcklkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG1ldGhvZDogc3RyaW5nO1xuICAgIG9BdXRoUHJvdmlkZXJJZD86IHN0cmluZyB8IG51bGw7XG4gICAgYXBpS2V5UHJvdmlkZXJJZD86IHN0cmluZyB8IG51bGw7XG4gICAgb0F1dGhQcm92aWRlcj86IE9BdXRoUHJvdmlkZXIgfCBudWxsO1xuICB9LFxuICByZXN1bHQ6IHsgaXNFcnJvcj86IGJvb2xlYW4gfSxcbiAgc3RhcnRUaW1lOiBudW1iZXIsXG4gIGhhc1VzZXJBdXRoOiBib29sZWFuLFxuICBoYXNTZXJ2ZXJBdXRoOiBib29sZWFuLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChoYXNVc2VyQXV0aCkge1xuICAgIGNvbnN0IHVzZXJSZXEgPSByZXEgYXMgRW5kVXNlclJlcXVlc3QgJiBXaXRoU2VydmVySWRSZXF1ZXN0O1xuICAgIGF3YWl0IGxvZ1VzZXJUb29sRXhlY3V0aW9uKHVzZXJSZXEsIHRvb2wsIHJlc3VsdCwgc3RhcnRUaW1lKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaGFzU2VydmVyQXV0aCkge1xuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgdXNlciBjb250ZXh0IGZyb20gSldUIGZvciBlbmhhbmNlZCBsb2dnaW5nXG4gICAgY29uc3Qgc2VydmVyQXV0aFJlcSA9IHJlcSBhcyBXaXRoU2VydmVySWRSZXF1ZXN0ICYgeyBzZXJ2ZXJBdXRoOiB7IHVzZXJDb250ZXh0PzogeyB1c2VySWQ/OiBzdHJpbmcgfSB9IH07XG4gICAgaWYgKHNlcnZlckF1dGhSZXEuc2VydmVyQXV0aD8udXNlckNvbnRleHQ/LnVzZXJJZCAmJiB0b29sLm9BdXRoUHJvdmlkZXIpIHtcbiAgICAgIC8vIExvZyBhcyB1c2VyIGV4ZWN1dGlvbiBmb3IgT0F1dGggdG9vbHMgd2l0aCBKV1QgdXNlciBjb250ZXh0XG4gICAgICBjb25zdCBzeW50aGV0aWNVc2VyUmVxID0gcmVxIGFzIEVuZFVzZXJSZXF1ZXN0ICYgV2l0aFNlcnZlcklkUmVxdWVzdDtcbiAgICAgIGlmIChzeW50aGV0aWNVc2VyUmVxLnVzZXIpIHtcbiAgICAgICAgYXdhaXQgbG9nVXNlclRvb2xFeGVjdXRpb24oc3ludGhldGljVXNlclJlcSwgdG9vbCwgcmVzdWx0LCBzdGFydFRpbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2ltcGxlIGxvZ2dpbmcgd2l0aG91dCB1c2VyLXNwZWNpZmljIGFuYWx5dGljcyBmb3Igc2VydmVyIGF1dGhcbiAgcmVxLmxvZ2dlci5pbmZvKGBUb29sICR7dG9vbC5uYW1lfSBleGVjdXRlZCBzdWNjZXNzZnVsbHlgLCB7XG4gICAgdG9vbF9pZDogdG9vbC5pZCxcbiAgICBzZXJ2ZXJfaWQ6IHRvb2wuc2VydmVySWQsXG4gICAgdG9vbF9uYW1lOiB0b29sLm5hbWUsXG4gICAgc3VjY2VzczogIXJlc3VsdC5pc0Vycm9yLFxuICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBzeW50aGV0aWMgRW5kVXNlciByZWNvcmQgZXhpc3RzIGZvciBKV1Qgc3ViamVjdCB0byBzYXRpc2Z5IGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzXG4gKiBUaGlzIGNyZWF0ZXMgYSB2aXJ0dWFsIHVzZXIgcmVjb3JkIHRoYXQgYWxsb3dzIE9BdXRoIHRva2VucyB0byBiZSBzdG9yZWQgZm9yIGV4dGVybmFsIEpXVCBzdWJqZWN0c1xuICovXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVTeW50aGV0aWNFbmRVc2VyKGRiOiBEYXRhYmFzZSwgdXNlcklkOiBzdHJpbmcsIHRlbmFudElkOiBzdHJpbmcsIGxvZ2dlcj86IExvZ2dlcik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGlmIHVzZXIgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCBleGlzdGluZ1VzZXIgPSBhd2FpdCBkYi5lbmRVc2VyLmZpbmRVbmlxdWUoe1xuICAgICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9LFxuICAgIH0pO1xuXG4gICAgaWYgKGV4aXN0aW5nVXNlcikge1xuICAgICAgbG9nZ2VyPy5kZWJ1ZyhgU3ludGhldGljIEVuZFVzZXIgYWxyZWFkeSBleGlzdHMgZm9yIEpXVCBzdWI6ICR7dXNlcklkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRlbmFudCBhbHJlYWR5IGV4aXN0cyBzaW5jZSBpdCdzIGZyb20gdGhlIE1DUCBzZXJ2ZXIgcmVjb3JkXG5cbiAgICAvLyBDcmVhdGUgc3ludGhldGljIEVuZFVzZXIgcmVjb3JkIGZvciBKV1Qgc3ViamVjdFxuICAgIGF3YWl0IGRiLmVuZFVzZXIuY3JlYXRlKHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IHVzZXJJZCwgLy8gVXNlIEpXVCBzdWIgYXMgdGhlIHVzZXIgSURcbiAgICAgICAgdGVuYW50SWQ6IHRlbmFudElkLFxuICAgICAgICBlbWFpbDogYCR7dXNlcklkfSR7Q09OU1RBTlRTLlNZTlRIRVRJQ19FTUFJTF9ET01BSU59YCwgLy8gU3ludGhldGljIGVtYWlsIHRvIHNhdGlzZnkgY29uc3RyYWludFxuICAgICAgICBlbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgbmFtZTogYEpXVCBTdWJqZWN0ICR7dXNlcklkLnN1YnN0cmluZygwLCA4KX0uLi5gLCAvLyBUcnVuY2F0ZWQgZm9yIHJlYWRhYmlsaXR5XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgbG9nZ2VyPy5pbmZvKGBDcmVhdGVkIHN5bnRoZXRpYyBFbmRVc2VyIGZvciBKV1Qgc3ViamVjdDogJHt1c2VySWR9YCwgeyB0ZW5hbnRJZCB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiBjcmVhdGlvbiBmYWlscyBkdWUgdG8gcmFjZSBjb25kaXRpb24sIHRoYXQncyBva2F5IC0gYW5vdGhlciByZXF1ZXN0IGNyZWF0ZWQgaXRcbiAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIFwiY29kZVwiIGluIGVycm9yICYmIGVycm9yLmNvZGUgPT09IFwiUDIwMDJcIikge1xuICAgICAgbG9nZ2VyPy5kZWJ1ZyhgU3ludGhldGljIEVuZFVzZXIgY3JlYXRpb24gcmFjZSBjb25kaXRpb24gZm9yIEpXVCBzdWI6ICR7dXNlcklkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlcj8uZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgc3ludGhldGljIEVuZFVzZXIgZm9yIEpXVCBzdWJqZWN0OiAke3VzZXJJZH1gLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBVbmlmaWVkIHRvb2wgYXV0aGVudGljYXRpb24gdGhhdCB3b3JrcyByZWdhcmRsZXNzIG9mIE1DUCBzZXJ2ZXIgYXV0aCB0eXBlXG4gKiBIYW5kbGVzIGJvdGggT0F1dGggYW5kIEFQSSBrZXkgdG9vbHMgaW5kZXBlbmRlbnRseSBvZiBCQVNFL0pXVCBNQ1AgYXV0aFxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVUb29sQXV0aGVudGljYXRpb24oXG4gIHJlcTogV2l0aFNlcnZlcklkUmVxdWVzdCxcbiAgdG9vbDogVG9vbCAmIHtcbiAgICBvQXV0aFByb3ZpZGVyOiBPQXV0aFByb3ZpZGVyIHwgbnVsbDtcbiAgICBhcGlLZXlQcm92aWRlcjogQXBpS2V5UHJvdmlkZXIgfCBudWxsO1xuICB9LFxuICBoYXNVc2VyQXV0aDogYm9vbGVhbixcbiAgaGFzU2VydmVyQXV0aDogYm9vbGVhbixcbik6IFByb21pc2U8e1xuICBhY2Nlc3NUb2tlbj86IHtcbiAgICB0b2tlbklkOiBzdHJpbmc7XG4gICAgdG9rZW5WYWx1ZTogc3RyaW5nO1xuICB9O1xuICBhdXRoUHJvdmlkZXJNaXNjb25maWd1cmVkPzogYm9vbGVhbjtcbiAgYXV0aE1pc3Npbmc/OiB7IGF1dGhVcmw6IHN0cmluZyB9O1xufT4ge1xuICAvLyBBUEkga2V5IHRvb2xzIC0gd29yayB0aGUgc2FtZSB3YXkgcmVnYXJkbGVzcyBvZiBNQ1AgYXV0aCB0eXBlXG4gIGlmICh0b29sLmFwaUtleVByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY2Vzc1Rva2VuOiB7XG4gICAgICAgIHRva2VuSWQ6IHRvb2wuYXBpS2V5UHJvdmlkZXIuaWQsXG4gICAgICAgIHRva2VuVmFsdWU6IHRvb2wuYXBpS2V5UHJvdmlkZXIudmFsdWUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvLyBPQXV0aCB0b29scyAtIG5lZWQgdXNlciBjb250ZXh0IGZvciB0b2tlbiBzdG9yYWdlXG4gIGlmICh0b29sLm9BdXRoUHJvdmlkZXIpIHtcbiAgICAvLyBDaGVjayBpZiBPQXV0aCBwcm92aWRlciBpcyBwcm9wZXJseSBjb25maWd1cmVkXG4gICAgaWYgKGlzRW1wdHkodG9vbC5vQXV0aFByb3ZpZGVyLmNsaWVudElkKSB8fCBpc0VtcHR5KHRvb2wub0F1dGhQcm92aWRlci5jbGllbnRTZWNyZXQpKSB7XG4gICAgICByZXR1cm4geyBhdXRoUHJvdmlkZXJNaXNjb25maWd1cmVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gR2V0IHVzZXIgSUQgcmVnYXJkbGVzcyBvZiBNQ1AgYXV0aCB0eXBlXG4gICAgY29uc3QgdXNlcklkID0gYXdhaXQgZ2V0VXNlcklkRm9yT0F1dGgocmVxLCBoYXNVc2VyQXV0aCwgaGFzU2VydmVyQXV0aCwgdG9vbC5uYW1lKTtcbiAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIHVzZXJJZDsgLy8gUmV0dXJuIGVycm9yIGlmIHVzZXIgSUQgY291bGRuJ3QgYmUgZGV0ZXJtaW5lZFxuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gT0F1dGggdG9rZW4gbG9va3VwIGFuZCBtYW5hZ2VtZW50IC0gc2FtZSBsb2dpYyBmb3IgYm90aCBhdXRoIHR5cGVzXG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZU9BdXRoQXV0aGVudGljYXRpb24ocmVxLCB0b29sLm9BdXRoUHJvdmlkZXIsIHVzZXJJZCk7XG4gIH1cblxuICAvLyBObyBhdXRoZW50aWNhdGlvbiBuZWVkZWQgZm9yIHRoaXMgdG9vbFxuICByZXR1cm4ge307XG59XG5cbi8qKlxuICogR2V0cyB1c2VyIElEIGZvciBPQXV0aCB0b2tlbiBsb29rdXAgLSB3b3JrcyBmb3IgYm90aCBNQ1AgYXV0aCB0eXBlc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VySWRGb3JPQXV0aChcbiAgcmVxOiBXaXRoU2VydmVySWRSZXF1ZXN0LFxuICBoYXNVc2VyQXV0aDogYm9vbGVhbixcbiAgaGFzU2VydmVyQXV0aDogYm9vbGVhbixcbiAgdG9vbE5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8c3RyaW5nIHwgeyBhdXRoUHJvdmlkZXJNaXNjb25maWd1cmVkOiB0cnVlIH0+IHtcbiAgaWYgKGhhc1VzZXJBdXRoKSB7XG4gICAgLy8gQkFTRSBhdXRoIC0gdXNlIGFjdHVhbCB1c2VyIElEXG4gICAgY29uc3QgdXNlclJlcSA9IHJlcSBhcyBFbmRVc2VyUmVxdWVzdCAmIFdpdGhTZXJ2ZXJJZFJlcXVlc3Q7XG4gICAgcmV0dXJuIHVzZXJSZXEudXNlci5pZDtcbiAgfVxuXG4gIGlmIChoYXNTZXJ2ZXJBdXRoKSB7XG4gICAgLy8gSldUIGF1dGggLSBleHRyYWN0IHVzZXIgSUQgZnJvbSBKV1QgdG9rZW5cbiAgICBjb25zdCBzZXJ2ZXJBdXRoUmVxID0gcmVxIGFzIFdpdGhTZXJ2ZXJJZFJlcXVlc3QgJiB7XG4gICAgICBzZXJ2ZXJBdXRoPzogeyB1c2VyQ29udGV4dD86IHsgdXNlcklkPzogc3RyaW5nOyB0ZW5hbnRJZD86IHN0cmluZyB9IH07XG4gICAgfTtcbiAgICBjb25zdCBqd3RVc2VySWQgPSBzZXJ2ZXJBdXRoUmVxLnNlcnZlckF1dGg/LnVzZXJDb250ZXh0Py51c2VySWQ7XG5cbiAgICBpZiAoIWp3dFVzZXJJZCkge1xuICAgICAgcmVxLmxvZ2dlci53YXJuKGBPQXV0aCB0b29sICR7dG9vbE5hbWV9IHJlcXVpcmVzIHVzZXIgY29udGV4dCBpbiBKV1QgdG9rZW5gKTtcbiAgICAgIHJldHVybiB7IGF1dGhQcm92aWRlck1pc2NvbmZpZ3VyZWQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGVuYW50SWQgZnJvbSB0aGUgTUNQIHNlcnZlciByZWNvcmRcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCByZXEuZGIubWNwU2VydmVyLmZpbmRVbmlxdWUoe1xuICAgICAgd2hlcmU6IHsgaWQ6IHJlcS5zZXJ2ZXJJZCB9LFxuICAgICAgc2VsZWN0OiB7IHRlbmFudElkOiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXNlcnZlcikge1xuICAgICAgcmVxLmxvZ2dlci5lcnJvcihgTUNQIHNlcnZlciBub3QgZm91bmQ6ICR7cmVxLnNlcnZlcklkfWApO1xuICAgICAgcmV0dXJuIHsgYXV0aFByb3ZpZGVyTWlzY29uZmlndXJlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBzeW50aGV0aWMgRW5kVXNlciBleGlzdHMgZm9yIEpXVCBzdWJcbiAgICBhd2FpdCBlbnN1cmVTeW50aGV0aWNFbmRVc2VyKHJlcS5kYiwgand0VXNlcklkLCBzZXJ2ZXIudGVuYW50SWQsIHJlcS5sb2dnZXIpO1xuXG4gICAgcmV0dXJuIGp3dFVzZXJJZDtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuZXJyb3IoYE5vIGF1dGhlbnRpY2F0aW9uIGNvbnRleHQgYXZhaWxhYmxlIGZvciBPQXV0aCB0b29sICR7dG9vbE5hbWV9YCk7XG4gIHJldHVybiB7IGF1dGhQcm92aWRlck1pc2NvbmZpZ3VyZWQ6IHRydWUgfTtcbn1cblxuLyoqXG4gKiBVbmlmaWVkIE9BdXRoIGF1dGhlbnRpY2F0aW9uIHRoYXQgd29ya3MgdGhlIHNhbWUgZm9yIGJvdGggTUNQIGF1dGggdHlwZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlT0F1dGhBdXRoZW50aWNhdGlvbihcbiAgcmVxOiBXaXRoU2VydmVySWRSZXF1ZXN0LFxuICBvQXV0aFByb3ZpZGVyOiBPQXV0aFByb3ZpZGVyLFxuICB1c2VySWQ6IHN0cmluZyxcbik6IFByb21pc2U8e1xuICBhY2Nlc3NUb2tlbj86IHtcbiAgICB0b2tlbklkOiBzdHJpbmc7XG4gICAgdG9rZW5WYWx1ZTogc3RyaW5nO1xuICB9O1xuICBhdXRoUHJvdmlkZXJNaXNjb25maWd1cmVkPzogYm9vbGVhbjtcbiAgYXV0aE1pc3Npbmc/OiB7IGF1dGhVcmw6IHN0cmluZyB9O1xufT4ge1xuICBjb25zdCBvcmlnaW5BZGRyZXNzID0gcmVxLmlwIHx8IG51bGw7XG4gIGNvbnN0IHRva2VucyA9IGF3YWl0IGdldFVzZXJVc2VhYmxlVG9rZW5zKHJlcS5kYiwgdXNlcklkLCBvQXV0aFByb3ZpZGVyLmlkKTtcblxuICBpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB2YWxpZFRva2VucyA9IHRva2Vucy5maWx0ZXIoKHQpID0+ICF0LmV4cGlyZXNBdCB8fCB0LmV4cGlyZXNBdCA+IG5ldyBEYXRlKCkpO1xuICAgIGlmICh2YWxpZFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXEubG9nZ2VyLmRlYnVnKGBGb3VuZCB2YWxpZCB0b2tlbiBmb3IgcHJvdmlkZXIgJHtvQXV0aFByb3ZpZGVyLm5hbWV9IChoYXMgJHt0b2tlbnMubGVuZ3RofSB0b2tlbnMpYCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY2Nlc3NUb2tlbjoge1xuICAgICAgICAgIHRva2VuSWQ6IHZhbGlkVG9rZW5zWzBdLmlkLFxuICAgICAgICAgIHRva2VuVmFsdWU6IHZhbGlkVG9rZW5zWzBdLmFjY2Vzc1Rva2VuLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbnNXaXRoUmVmcmVzaCA9IHRva2Vucy5maWx0ZXIoKHQpID0+ICEhdC5yZWZyZXNoVG9rZW4pO1xuICAgIGlmICh0b2tlbnNXaXRoUmVmcmVzaC5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0b2tlbkRhdGEgPSBhd2FpdCByZWZyZXNoQW5kUGVyc2lzdEFjY2Vzc1Rva2VuKFxuICAgICAgICAgIHJlcS5kYixcbiAgICAgICAgICByZXEubG9nZ2VyLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBvQXV0aFByb3ZpZGVyLFxuICAgICAgICAgIHRva2Vuc1dpdGhSZWZyZXNoWzBdLnJlZnJlc2hUb2tlbiEsXG4gICAgICAgICAgb3JpZ2luQWRkcmVzcyxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY2Nlc3NUb2tlbjoge1xuICAgICAgICAgICAgdG9rZW5JZDogdG9rZW5EYXRhLmlkLFxuICAgICAgICAgICAgdG9rZW5WYWx1ZTogdG9rZW5EYXRhLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXEubG9nZ2VyLndhcm4oYEZhaWxlZCB0byByZWZyZXNoIHRva2VuIGZvciBwcm92aWRlciAke29BdXRoUHJvdmlkZXIubmFtZX1gLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXV0aE1pc3Npbmc6IHtcbiAgICAgICAgICAgIGF1dGhVcmw6IGdldEF1dGhvcml6ZVVybChyZXEsIG9BdXRoUHJvdmlkZXIsIFwiXCIsIHJlcS5zZXJ2ZXJJZCwgdXNlcklkLCBUT09MX1NDT1BFLCBvcmlnaW5BZGRyZXNzKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbCB0b2tlbnMgYXJlIGV4cGlyZWQvaW52YWxpZCBhbmQgbm8gcmVmcmVzaCB0b2tlbnMgYXZhaWxhYmxlIC0gcHJvbXB0IGZvciByZS1hdXRoZW50aWNhdGlvblxuICAgIGNvbnN0IGF1dGhVcmwgPSBnZXRBdXRob3JpemVVcmwocmVxLCBvQXV0aFByb3ZpZGVyLCBcIlwiLCByZXEuc2VydmVySWQsIHVzZXJJZCwgVE9PTF9TQ09QRSwgb3JpZ2luQWRkcmVzcyk7XG4gICAgcmVxLmxvZ2dlci53YXJuKFxuICAgICAgYEZvdW5kICR7dG9rZW5zLmxlbmd0aH0gZXhwaXJlZC9pbnZhbGlkIHRva2VucyBmb3IgcHJvdmlkZXIgJHtvQXV0aFByb3ZpZGVyLm5hbWV9LCBwcm9tcHRpbmcgdXNlciB0byByZS1hdXRoZW50aWNhdGUgYXQgJyR7YXV0aFVybH0nYCxcbiAgICApO1xuICAgIHJldHVybiB7IGF1dGhNaXNzaW5nOiB7IGF1dGhVcmwgfSB9O1xuICB9XG5cbiAgY29uc3QgYXV0aFVybCA9IGdldEF1dGhvcml6ZVVybChyZXEsIG9BdXRoUHJvdmlkZXIsIFwiXCIsIHJlcS5zZXJ2ZXJJZCwgdXNlcklkLCBUT09MX1NDT1BFLCBvcmlnaW5BZGRyZXNzKTtcbiAgcmVxLmxvZ2dlci53YXJuKFxuICAgIGBObyB2YWxpZCB0b2tlbiBmb3VuZCBmb3IgcHJvdmlkZXIgJHtvQXV0aFByb3ZpZGVyLm5hbWV9LCBwcm9tcHRpbmcgdXNlciB0byBhdXRoZW50aWNhdGUgYXQgJyR7YXV0aFVybH0nYCxcbiAgKTtcbiAgcmV0dXJuIHsgYXV0aE1pc3Npbmc6IHsgYXV0aFVybCB9IH07XG59XG4iLCAiaW1wb3J0IHsgV2l0aFNlcnZlcklkUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5cbi8qKlxuICogUmVxdWVzdCBjb250ZXh0IGZvciBwYXJhbWV0ZXIgZXh0cmFjdGlvblxuICovXG5pbnRlcmZhY2UgUmVxdWVzdENvbnRleHQge1xuICBoYXNVc2VyQXV0aDogYm9vbGVhbjtcbiAgc2VydmVyQXV0aD86IHtcbiAgICB1c2VyQ29udGV4dD86IHtcbiAgICAgIG9yaWdpbmFsVG9rZW4/OiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBjb250ZXh0IHBhcmFtZXRlcnMgdGhhdCBhcmUgYXV0b21hdGljYWxseSBpbmplY3RlZCBpbnRvIHRvb2wgY2FsbHNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250ZXh0UGFyYW1ldGVyIHtcbiAgcmVhZG9ubHkga2V5OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNvdXJjZTogXCJyZXF1ZXN0XCIgfCBcInVzZXJcIiB8IFwic2VydmVyXCI7XG4gIHJlYWRvbmx5IGNvbmRpdGlvbj86IChjb250ZXh0OiBSZXF1ZXN0Q29udGV4dCkgPT4gYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBdmFpbGFibGUgY29udGV4dCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlIGluamVjdGVkIGludG8gdG9vbCBjYWxsc1xuICovXG5leHBvcnQgY29uc3QgQ09OVEVYVF9QQVJBTUVURVJTOiBSZWNvcmQ8c3RyaW5nLCBDb250ZXh0UGFyYW1ldGVyPiA9IHtcbiAgSldUOiB7XG4gICAga2V5OiBcImp3dFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkpXVCB0b2tlbiBmcm9tIHJlcXVlc3QgQXV0aG9yaXphdGlvbiBoZWFkZXJcIixcbiAgICBzb3VyY2U6IFwicmVxdWVzdFwiLFxuICAgIGNvbmRpdGlvbjogKGNvbnRleHQpID0+ICFjb250ZXh0Lmhhc1VzZXJBdXRoICYmICEhY29udGV4dC5zZXJ2ZXJBdXRoPy51c2VyQ29udGV4dD8ub3JpZ2luYWxUb2tlbixcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogRXh0cmFjdCBjb250ZXh0IHBhcmFtZXRlcnMgZnJvbSByZXF1ZXN0IGFuZCBhZGQgdG8gY2FsbCBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RDb250ZXh0UGFyYW1ldGVycyhcbiAgcmVxOiBXaXRoU2VydmVySWRSZXF1ZXN0LFxuICBjYWxsUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGhhc1VzZXJBdXRoOiBib29sZWFuLFxuKTogdm9pZCB7XG4gIGNvbnN0IGNvbnRleHQ6IFJlcXVlc3RDb250ZXh0ID0ge1xuICAgIGhhc1VzZXJBdXRoLFxuICAgIHNlcnZlckF1dGg6IFwic2VydmVyQXV0aFwiIGluIHJlcSA/IHJlcS5zZXJ2ZXJBdXRoIDogdW5kZWZpbmVkLFxuICB9O1xuXG4gIE9iamVjdC52YWx1ZXMoQ09OVEVYVF9QQVJBTUVURVJTKS5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgIGlmICghcGFyYW0uY29uZGl0aW9uIHx8IHBhcmFtLmNvbmRpdGlvbihjb250ZXh0KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBleHRyYWN0UGFyYW1ldGVyVmFsdWUocmVxLCBwYXJhbSwgaGFzVXNlckF1dGgpO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbFBhcmFtZXRlcnNbcGFyYW0ua2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQYXJhbWV0ZXJWYWx1ZShyZXE6IFdpdGhTZXJ2ZXJJZFJlcXVlc3QsIHBhcmFtOiBDb250ZXh0UGFyYW1ldGVyLCBoYXNVc2VyQXV0aDogYm9vbGVhbik6IHVua25vd24ge1xuICBzd2l0Y2ggKHBhcmFtLmtleSkge1xuICAgIGNhc2UgXCJqd3RcIjpcbiAgICAgIHJldHVybiAhaGFzVXNlckF1dGggJiYgXCJzZXJ2ZXJBdXRoXCIgaW4gcmVxICYmIHJlcS5zZXJ2ZXJBdXRoPy51c2VyQ29udGV4dD8ub3JpZ2luYWxUb2tlbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuIiwgImltcG9ydCB7IEZvcm1hdHRpbmdDb25maWcsIFJlcXVlc3RQYXJhbUNvbmZpZyB9IGZyb20gXCJAYWdlbnRicmlkZ2UvYXBpXCI7XG5pbXBvcnQgeyBDYWxsVG9vbFJlc3VsdCB9IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBUb29sIH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgYXhpb3MsIHsgQXhpb3NFcnJvciwgQXhpb3NSZXNwb25zZSwgaXNBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgSGFuZGxlYmFycyBmcm9tIFwiaGFuZGxlYmFyc1wiO1xuaW1wb3J0IHsgT3BlbkFQSVYzIH0gZnJvbSBcIm9wZW5hcGktdHlwZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJ3aW5zdG9uXCI7XG5pbXBvcnQgeyBIdHRwUmVxdWVzdE92ZXJyaWRlcyB9IGZyb20gXCIuLi8uLi91dGlscy9nZW5lcmF0ZVJlcXVlc3RPdmVycmlkZXMuanNcIjtcbmltcG9ydCB7IGpzb25WYWx1ZVRvUmVjb3JkIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2pzb24uanNcIjtcbmltcG9ydCB7IGJ1aWxkUmVxdWVzdENvbmZpZyB9IGZyb20gXCIuL3BhcmFtZXRlci1zY2hlbWEuanNcIjtcblxuLy8gUmVnaXN0ZXIgSGFuZGxlYmFycyBoZWxwZXJzXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKFwianNvblwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29udGV4dCk7XG59KTtcblxuY29uc3QgbG9nQXBpQ2FsbCA9IChcbiAgbG9nZ2VyOiBMb2dnZXIsXG4gIHRvb2w6IFRvb2wsXG4gIGJhc2VVcmw6IHN0cmluZyxcbiAgc3RhcnRUaW1lOiBudW1iZXIsXG4gIGlzUGxheWdyb3VuZDogYm9vbGVhbixcbiAgcmVzcG9uc2U6IEF4aW9zUmVzcG9uc2UgfCBudWxsLFxuKSA9PiB7XG4gIC8vIERvIG5vdCBjaGFuZ2UgdGhlIHBocmFzaW5nIG9mIHRoaXMgbG9nIG1lc3NhZ2UsIGl0IGlzIHVzZWQgZm9yIG1ldHJpYyBleHRyYWN0aW9uczpcbiAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9Pd25JRC9kYXRhZG9nLXRlcnJhZm9ybS9ibG9iL2RldmVsb3AvbW9uaXRvcnMvbWV0cmljX2FnZW50YnJpZGdlLnRmXG4gIGxvZ2dlci5pbmZvKFwiQW5hbHl0aWNzOiBBUEkgY2FsbCBjb21wbGV0ZWRcIiwge1xuICAgIHRvb2xJZDogdG9vbC5pZCxcbiAgICBiYXNlVXJsLFxuICAgIHVybDogdG9vbC51cmwsXG4gICAgbWV0aG9kOiB0b29sLm1ldGhvZCxcbiAgICBzdGF0dXNDb2RlOiByZXNwb25zZT8uc3RhdHVzIHx8IDAsXG4gICAgYm9keUxlbjogcmVzcG9uc2U/LmRhdGEgPyBTdHJpbmcocmVzcG9uc2UuZGF0YSkubGVuZ3RoIDogMCxcbiAgICBkdXJhdGlvbk1TOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgIGZhaWxlZDogIXJlc3BvbnNlIHx8IHJlc3BvbnNlPy5zdGF0dXMgPj0gMzAwIHx8IHJlc3BvbnNlPy5zdGF0dXMgPCAyMDAsXG4gICAgaXNQbGF5Z3JvdW5kLFxuICB9KTtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlQXBpUmVxdWVzdChcbiAgdG9vbDogVG9vbCxcbiAgYmFzZVVybDogc3RyaW5nLFxuICBzcGVjUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgT3BlbkFQSVYzLlBhcmFtZXRlck9iamVjdD4sXG4gIGNhbGxQYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgbG9nZ2VyOiBMb2dnZXIsXG4gIGlzUGxheWdyb3VuZCA9IGZhbHNlLFxuICBhdXRoQ29udGV4dD86IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuKTogUHJvbWlzZTxDYWxsVG9vbFJlc3VsdD4ge1xuICBjb25zdCByZXNwb25zZUZvcm1hdHRpbmc6IEZvcm1hdHRpbmdDb25maWcgPSB0b29sLnJlc3BvbnNlRm9ybWF0dGluZ1xuICAgID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0b29sLnJlc3BvbnNlRm9ybWF0dGluZykpXG4gICAgOiB7fTtcblxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIC8vIENhcHR1cmUgcmVxdWVzdCBkYXRhIGZvciB0ZW1wbGF0aW5nIGlmIGVuYWJsZWQgKGRlY2xhcmUgb3V0c2lkZSB0cnkgYmxvY2sgZm9yIGVycm9yIGhhbmRsaW5nKVxuICBsZXQgcmVxdWVzdERhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICAvLyBQcm9jZXNzIHJlcXVlc3QgcGFyYW1ldGVyIG92ZXJyaWRlcyBpZiBjb25maWd1cmVkXG4gICAgbGV0IGZpbmFsUGFyYW1ldGVycyA9IGNhbGxQYXJhbWV0ZXJzO1xuICAgIGxldCBmaW5hbFNwZWNQYXJhbWV0ZXJzID0gc3BlY1BhcmFtZXRlcnM7XG5cbiAgICBpZiAodG9vbC5yZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzKSB7XG4gICAgICBjb25zdCBvdmVycmlkZXMgPSB0b29sLnJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMgYXMgUmVjb3JkPHN0cmluZywgUmVxdWVzdFBhcmFtQ29uZmlnPiB8IEh0dHBSZXF1ZXN0T3ZlcnJpZGVzO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBuZXcgZm9ybWF0IChoYXMgcXVlcnkvaGVhZGVycy9wYXRoL2JvZHkgcHJvcGVydGllcylcbiAgICAgIGNvbnN0IGlzTmV3Rm9ybWF0ID0gXCJxdWVyeVwiIGluIG92ZXJyaWRlcyB8fCBcImhlYWRlcnNcIiBpbiBvdmVycmlkZXMgfHwgXCJwYXRoXCIgaW4gb3ZlcnJpZGVzIHx8IFwiYm9keVwiIGluIG92ZXJyaWRlcztcblxuICAgICAgaWYgKGlzTmV3Rm9ybWF0KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVXNpbmcgbmV3IEhUVFAgcmVxdWVzdCBvdmVycmlkZSBmb3JtYXRgKTtcblxuICAgICAgICAvLyBCdWlsZCBwYXJhbWV0ZXJzIGZyb20gdGhlIG5ldyBmb3JtYXRcbiAgICAgICAgZmluYWxQYXJhbWV0ZXJzID0ge307XG4gICAgICAgIGNvbnN0IG5ld1NwZWNQYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBPcGVuQVBJVjMuUGFyYW1ldGVyT2JqZWN0PiA9IHt9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcXVlcnkgcGFyYW1ldGVyc1xuICAgICAgICBpZiAob3ZlcnJpZGVzLnF1ZXJ5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3ZlcnJpZGVzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVmFsdWUgPSBwcm9jZXNzSGFuZGxlYmFyc1RlbXBsYXRlKGxvZ2dlciwgdmFsdWUgYXMgc3RyaW5nLCB7IHRvb2xQYXJhbXM6IGNhbGxQYXJhbWV0ZXJzIH0pO1xuICAgICAgICAgICAgLy8gT25seSBhZGQgbm9uLWVtcHR5IHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGlmIChwcm9jZXNzZWRWYWx1ZSAhPT0gXCJcIiAmJiBwcm9jZXNzZWRWYWx1ZSAhPT0gbnVsbCAmJiBwcm9jZXNzZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpbmFsUGFyYW1ldGVyc1trZXldID0gcHJvY2Vzc2VkVmFsdWU7XG4gICAgICAgICAgICAgIG5ld1NwZWNQYXJhbWV0ZXJzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgIGluOiBcInF1ZXJ5XCIsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHNwZWNQYXJhbWV0ZXJzW2tleV0/LnJlcXVpcmVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogc3BlY1BhcmFtZXRlcnNba2V5XT8uc2NoZW1hIHx8IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBTa2lwcGluZyBlbXB0eSBxdWVyeSBwYXJhbWV0ZXI6ICR7a2V5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2Nlc3MgaGVhZGVyc1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmhlYWRlcnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvdmVycmlkZXMuaGVhZGVycykpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFZhbHVlID0gcHJvY2Vzc0hhbmRsZWJhcnNUZW1wbGF0ZShsb2dnZXIsIHZhbHVlIGFzIHN0cmluZywgeyB0b29sUGFyYW1zOiBjYWxsUGFyYW1ldGVycyB9KTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIG5vbi1lbXB0eSBoZWFkZXJzXG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkVmFsdWUgIT09IFwiXCIgJiYgcHJvY2Vzc2VkVmFsdWUgIT09IG51bGwgJiYgcHJvY2Vzc2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBmaW5hbFBhcmFtZXRlcnNba2V5XSA9IHByb2Nlc3NlZFZhbHVlO1xuICAgICAgICAgICAgICBuZXdTcGVjUGFyYW1ldGVyc1trZXldID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBpbjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogc3BlY1BhcmFtZXRlcnNba2V5XT8ucmVxdWlyZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzcGVjUGFyYW1ldGVyc1trZXldPy5zY2hlbWEgfHwgeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFNraXBwaW5nIGVtcHR5IGhlYWRlciBwYXJhbWV0ZXI6ICR7a2V5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2Nlc3MgcGF0aCBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChvdmVycmlkZXMucGF0aCkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG92ZXJyaWRlcy5wYXRoKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVmFsdWUgPSBwcm9jZXNzSGFuZGxlYmFyc1RlbXBsYXRlKGxvZ2dlciwgdmFsdWUgYXMgc3RyaW5nLCB7IHRvb2xQYXJhbXM6IGNhbGxQYXJhbWV0ZXJzIH0pO1xuICAgICAgICAgICAgLy8gUGF0aCBwYXJhbWV0ZXJzIHNob3VsZCB0eXBpY2FsbHkgYWx3YXlzIGhhdmUgYSB2YWx1ZSwgYnV0IHdlJ2xsIGNoZWNrIGFueXdheVxuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZFZhbHVlICE9PSBcIlwiICYmIHByb2Nlc3NlZFZhbHVlICE9PSBudWxsICYmIHByb2Nlc3NlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmluYWxQYXJhbWV0ZXJzW2tleV0gPSBwcm9jZXNzZWRWYWx1ZTtcbiAgICAgICAgICAgICAgbmV3U3BlY1BhcmFtZXRlcnNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgaW46IFwicGF0aFwiLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBzcGVjUGFyYW1ldGVyc1trZXldPy5yZXF1aXJlZCB8fCB0cnVlLCAvLyBQYXRoIHBhcmFtcyBhcmUgdXN1YWxseSByZXF1aXJlZFxuICAgICAgICAgICAgICAgIHNjaGVtYTogc3BlY1BhcmFtZXRlcnNba2V5XT8uc2NoZW1hIHx8IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYEVtcHR5IHBhdGggcGFyYW1ldGVyOiAke2tleX0gLSB0aGlzIG1heSBjYXVzZSByZXF1ZXN0IHRvIGZhaWxgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9jZXNzIGJvZHlcbiAgICAgICAgaWYgKG92ZXJyaWRlcy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgYm9keSBhcyBhIHNpbmdsZSBwYXJhbWV0ZXJcbiAgICAgICAgICBsZXQgYm9keVZhbHVlID0gb3ZlcnJpZGVzLmJvZHk7XG5cbiAgICAgICAgICAvLyBJZiBib2R5IGlzIGFuIG9iamVjdC9hcnJheSwgcHJvY2VzcyBhbnkgdGVtcGxhdGUgc3RyaW5ncyB3aXRoaW4gaXRcbiAgICAgICAgICBpZiAodHlwZW9mIGJvZHlWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBib2R5VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJvZHlWYWx1ZSA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHByb2Nlc3NIYW5kbGViYXJzVGVtcGxhdGUobG9nZ2VyLCBKU09OLnN0cmluZ2lmeShib2R5VmFsdWUpLCB7IHRvb2xQYXJhbXM6IGNhbGxQYXJhbWV0ZXJzIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5VmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJvZHlWYWx1ZSA9IHByb2Nlc3NIYW5kbGViYXJzVGVtcGxhdGUobG9nZ2VyLCBib2R5VmFsdWUsIHsgdG9vbFBhcmFtczogY2FsbFBhcmFtZXRlcnMgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmluYWxQYXJhbWV0ZXJzLmJvZHkgPSBib2R5VmFsdWU7XG4gICAgICAgICAgbmV3U3BlY1BhcmFtZXRlcnMuYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiYm9keVwiLFxuICAgICAgICAgICAgaW46IFwiYm9keVwiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHNwZWNQYXJhbWV0ZXJzLmJvZHk/LnJlcXVpcmVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgc2NoZW1hOiBzcGVjUGFyYW1ldGVycy5ib2R5Py5zY2hlbWEgfHwgeyB0eXBlOiBcIm9iamVjdFwiIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsU3BlY1BhcmFtZXRlcnMgPSBuZXdTcGVjUGFyYW1ldGVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9sZCBmb3JtYXQgLSBleGlzdGluZyBsb2dpY1xuICAgICAgICBsb2dnZXIuZGVidWcoYFVzaW5nIG9sZCByZXF1ZXN0IHBhcmFtZXRlciBvdmVycmlkZSBmb3JtYXRgKTtcbiAgICAgICAgLy8gY29uc3Qgb2xkT3ZlcnJpZGVzID0gb3ZlcnJpZGVzIGFzIFJlY29yZDxzdHJpbmcsIFJlcXVlc3RQYXJhbUNvbmZpZz47XG5cbiAgICAgICAgLy8gQnVpbGQgYSBuZXcgcGFyYW1ldGVycyBvYmplY3QgYmFzZWQgb24gb3ZlcnJpZGVzXG4gICAgICAgIGZpbmFsUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICBjb25zdCBuZXdTcGVjUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgT3BlbkFQSVYzLlBhcmFtZXRlck9iamVjdD4gPSB7fTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggb3ZlcnJpZGVcbiAgICAgICAgZm9yIChjb25zdCBbcGFyYW1OYW1lLCBvdmVycmlkZV0gb2YgT2JqZWN0LmVudHJpZXMob3ZlcnJpZGVzKSkge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHRlbXBsYXRlIHZhbHVlXG4gICAgICAgICAgY29uc3QgcHJvY2Vzc2VkVmFsdWUgPSBwcm9jZXNzSGFuZGxlYmFyc1RlbXBsYXRlKGxvZ2dlciwgb3ZlcnJpZGUudmFsdWUsIHtcbiAgICAgICAgICAgIHRvb2xQYXJhbXM6IGNhbGxQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYXV0aDogYXV0aENvbnRleHQgfHwge30sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZmluYWxQYXJhbWV0ZXJzW3BhcmFtTmFtZV0gPSBwcm9jZXNzZWRWYWx1ZTtcblxuICAgICAgICAgIC8vIENyZWF0ZSBvciB1cGRhdGUgdGhlIHBhcmFtZXRlciBzcGVjXG4gICAgICAgICAgbmV3U3BlY1BhcmFtZXRlcnNbcGFyYW1OYW1lXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHBhcmFtTmFtZSxcbiAgICAgICAgICAgIGluOiBvdmVycmlkZS5sb2NhdGlvbiBhcyBPcGVuQVBJVjMuUGFyYW1ldGVyT2JqZWN0W1wiaW5cIl0sXG4gICAgICAgICAgICByZXF1aXJlZDogc3BlY1BhcmFtZXRlcnNbcGFyYW1OYW1lXT8ucmVxdWlyZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICBzY2hlbWE6IHNwZWNQYXJhbWV0ZXJzW3BhcmFtTmFtZV0/LnNjaGVtYSB8fCB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHRoZSBuZXcgcGFyYW1ldGVyIHNwZWNpZmljYXRpb25zXG4gICAgICAgIGZpbmFsU3BlY1BhcmFtZXRlcnMgPSBuZXdTcGVjUGFyYW1ldGVycztcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmRlYnVnKGBBcHBsaWVkIHJlcXVlc3QgcGFyYW1ldGVyIG92ZXJyaWRlc2AsIHtcbiAgICAgICAgb3JpZ2luYWw6IGNhbGxQYXJhbWV0ZXJzLFxuICAgICAgICBvdmVycmlkZXMsXG4gICAgICAgIGZpbmFsOiBmaW5hbFBhcmFtZXRlcnMsXG4gICAgICAgIHNwZWNzOiBmaW5hbFNwZWNQYXJhbWV0ZXJzLFxuICAgICAgICBmb3JtYXQ6IGlzTmV3Rm9ybWF0ID8gXCJuZXdcIiA6IFwib2xkXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbmZpZywgbWlzc2luZ1JlcXVpcmVkUGFyYW0gfSA9IGJ1aWxkUmVxdWVzdENvbmZpZyhcbiAgICAgIGxvZ2dlcixcbiAgICAgIHRvb2wubWV0aG9kLFxuICAgICAgdG9vbC51cmwsXG4gICAgICBiYXNlVXJsLFxuICAgICAgZmluYWxTcGVjUGFyYW1ldGVycyxcbiAgICAgIGZpbmFsUGFyYW1ldGVycyxcbiAgICAgIHRvb2wubmFtZSxcbiAgICApO1xuXG4gICAgaWYgKG1pc3NpbmdSZXF1aXJlZFBhcmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBgUmVxdWlyZWQgcGFyYW1ldGVyICR7bWlzc2luZ1JlcXVpcmVkUGFyYW19IGlzIG1pc3NpbmdgLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBFeGVjdXRpbmcgQVBJIGNhbGwgd2l0aCBjb25maWc6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtZXRob2Q6IGNvbmZpZy5tZXRob2QsXG4gICAgICAgIHVybDogY29uZmlnLnVybCxcbiAgICAgICAgaGVhZGVyczogY29uZmlnLmhlYWRlcnMsXG4gICAgICAgIHBhcmFtczogY29uZmlnLnBhcmFtcyxcbiAgICAgICAgZGF0YTogY29uZmlnLmRhdGEgPyBcIltEQVRBXVwiIDogbnVsbCxcbiAgICAgIH0pfWAsXG4gICAgKTtcblxuICAgIC8vIENhcHR1cmUgcmVxdWVzdCBkYXRhIGZvciB0ZW1wbGF0aW5nIGlmIGVuYWJsZWRcbiAgICByZXF1ZXN0RGF0YSA9IHJlc3BvbnNlRm9ybWF0dGluZy5pbmNsdWRlUmVxdWVzdERhdGFcbiAgICAgID8ge1xuICAgICAgICAgIHNjaGVtYTogc3BlY1BhcmFtZXRlcnMsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICBoZWFkZXJzOiBjb25maWcuaGVhZGVycyB8fCB7fSxcbiAgICAgICAgICAgICAgcXVlcnk6IGNvbmZpZy5wYXJhbXMgfHwge30sXG4gICAgICAgICAgICAgIHBhdGg6IGV4dHJhY3RQYXRoUGFyYW1zKHRvb2wudXJsLCBmaW5hbFBhcmFtZXRlcnMsIGZpbmFsU3BlY1BhcmFtZXRlcnMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGNvbmZpZy5kYXRhIHx8IHt9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIDogbnVsbDtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MoY29uZmlnKTtcblxuICAgIGxvZ2dlci5kZWJ1ZyhgQVBJIGNhbGwgY29tcGxldGVkLCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgc2NoZW1hOiBnZXRSZXNwb25zZVNjaGVtYShqc29uVmFsdWVUb1JlY29yZCh0b29sLnJlc3BvbnNlcyksIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHJlc3BvbnNlLmRhdGEsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBsb2dnZXIuZGVidWcoYEFQSSBjYWxsIHJlc3VsdDpgLCB7IHJlc3VsdCB9KTtcblxuICAgIGxldCBmb3JtYXR0ZWRSZXNwb25zZTogc3RyaW5nO1xuXG4gICAgaWYgKHJlc3BvbnNlRm9ybWF0dGluZy50ZW1wbGF0ZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBGb3JtYXR0aW5nIHJlc3BvbnNlIHdpdGggdGVtcGxhdGVgKTtcbiAgICAgIGNvbnN0IHRlbXBsYXRlRGF0YSA9IHtcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdERhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICAgIHRvb2xQYXJhbXM6IGNhbGxQYXJhbWV0ZXJzLFxuICAgICAgICBhdXRoOiBhdXRoQ29udGV4dCB8fCB7fSxcbiAgICAgIH07XG4gICAgICBmb3JtYXR0ZWRSZXNwb25zZSA9IHByb2Nlc3NIYW5kbGViYXJzVGVtcGxhdGUobG9nZ2VyLCByZXNwb25zZUZvcm1hdHRpbmcudGVtcGxhdGUsIHRlbXBsYXRlRGF0YSk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZUZvcm1hdHRpbmcuaXRlbVRlbXBsYXRlICYmIEFycmF5LmlzQXJyYXkocmVzdWx0LmRhdGEuYm9keSkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgRm9ybWF0dGluZyByZXNwb25zZSBhcyBhcnJheSB3aXRoIGl0ZW1UZW1wbGF0ZWApO1xuICAgICAgY29uc3QgaGVhZGVyID0gcmVzcG9uc2VGb3JtYXR0aW5nLmhlYWRlclxuICAgICAgICA/IHByb2Nlc3NIYW5kbGViYXJzVGVtcGxhdGUobG9nZ2VyLCByZXNwb25zZUZvcm1hdHRpbmcuaGVhZGVyLCB7IGNvdW50OiByZXN1bHQuZGF0YS5ib2R5Lmxlbmd0aCB9KVxuICAgICAgICA6IFwiXCI7XG5cbiAgICAgIGlmIChyZXN1bHQuZGF0YS5ib2R5Lmxlbmd0aCA9PT0gMCAmJiByZXNwb25zZUZvcm1hdHRpbmcuZW1wdHlSZXN1bHQpIHtcbiAgICAgICAgZm9ybWF0dGVkUmVzcG9uc2UgPSBgJHtoZWFkZXJ9JHtyZXNwb25zZUZvcm1hdHRpbmcuZW1wdHlSZXN1bHR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IHJlc3BvbnNlRm9ybWF0dGluZy5zZXBhcmF0b3IgfHwgXCJcXG5cXG5cIjtcbiAgICAgICAgY29uc3QgaXRlbXMgPSByZXN1bHQuZGF0YS5ib2R5Lm1hcCgoaXRlbSkgPT5cbiAgICAgICAgICBwcm9jZXNzSGFuZGxlYmFyc1RlbXBsYXRlKGxvZ2dlciwgcmVzcG9uc2VGb3JtYXR0aW5nLml0ZW1UZW1wbGF0ZSEsIHtcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0RGF0YSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICAgICAgICB0b29sUGFyYW1zOiBjYWxsUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGF1dGg6IGF1dGhDb250ZXh0IHx8IHt9LFxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgICBmb3JtYXR0ZWRSZXNwb25zZSA9IGAke2hlYWRlcn0ke2l0ZW1zLmpvaW4oc2VwYXJhdG9yKX1gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoYE5vIGZvcm1hdHRpbmcgY29uZmlndXJhdGlvbiwgcmV0dXJuaW5nIEpTT04gc3RyaW5nYCk7XG4gICAgICBmb3JtYXR0ZWRSZXNwb25zZSA9IHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIgPyByZXN1bHQgOiBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpO1xuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZyhgUmV0dXJuaW5nIHRvb2wgcmVzcG9uc2UgKCR7Zm9ybWF0dGVkUmVzcG9uc2UubGVuZ3RofSBjaGFycylgKTtcblxuICAgIGxvZ0FwaUNhbGwobG9nZ2VyLCB0b29sLCBiYXNlVXJsLCBzdGFydFRpbWUsIGlzUGxheWdyb3VuZCwgcmVzcG9uc2UpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IGZvcm1hdHRlZFJlc3BvbnNlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0F4aW9zRXJyb3IoZXJyb3IpKSB7XG4gICAgICBjb25zdCBheGlvc0Vycm9yID0gZXJyb3IgYXMgQXhpb3NFcnJvcjtcbiAgICAgIGxvZ0FwaUNhbGwobG9nZ2VyLCB0b29sLCBiYXNlVXJsLCBzdGFydFRpbWUsIGlzUGxheWdyb3VuZCwgYXhpb3NFcnJvci5yZXNwb25zZSB8fCBudWxsKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYEFQSSBjYWxsIGZhaWxlZDogJHtheGlvc0Vycm9yLmNvbmZpZz8ubWV0aG9kfSAke2F4aW9zRXJyb3IuY29uZmlnPy51cmx9IC0gJHtheGlvc0Vycm9yLnJlc3BvbnNlPy5zdGF0dXN9YCxcbiAgICAgICAge1xuICAgICAgICAgIHN0YXR1czogYXhpb3NFcnJvci5yZXNwb25zZT8uc3RhdHVzLFxuICAgICAgICAgIG1ldGhvZDogYXhpb3NFcnJvci5jb25maWc/Lm1ldGhvZCxcbiAgICAgICAgICB1cmw6IGF4aW9zRXJyb3IuY29uZmlnPy51cmwsXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dBcGlDYWxsKGxvZ2dlciwgdG9vbCwgYmFzZVVybCwgc3RhcnRUaW1lLCBpc1BsYXlncm91bmQsIG51bGwpO1xuICAgICAgbG9nZ2VyLmRlYnVnKGBBUEkgY2FsbCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZUZvcm1hdHRpbmcuZXJyb3JUZW1wbGF0ZSkge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgY29uc3QgdGVtcGxhdGVEYXRhID0ge1xuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3REYXRhLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHNjaGVtYTogZ2V0UmVzcG9uc2VTY2hlbWEoanNvblZhbHVlVG9SZWNvcmQodG9vbC5yZXNwb25zZXMpLCAwLCBcImFwcGxpY2F0aW9uL2pzb25cIiksXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBib2R5OiB7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0b29sUGFyYW1zOiBjYWxsUGFyYW1ldGVycyxcbiAgICAgICAgYXV0aDogYXV0aENvbnRleHQgfHwge30sXG4gICAgICB9O1xuICAgICAgY29uc3QgZm9ybWF0dGVkRXJyb3IgPSBwcm9jZXNzSGFuZGxlYmFyc1RlbXBsYXRlKFxuICAgICAgICBsb2dnZXIsXG4gICAgICAgIHJlc3BvbnNlRm9ybWF0dGluZy5lcnJvclRlbXBsYXRlIGFzIHN0cmluZyxcbiAgICAgICAgdGVtcGxhdGVEYXRhLFxuICAgICAgKTtcblxuICAgICAgbG9nZ2VyLmRlYnVnKGBSZXR1cm5pbmcgZm9ybWF0dGVkIGVycm9yOiAke2Zvcm1hdHRlZEVycm9yfWApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBmb3JtYXR0ZWRFcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgZm9ybWF0dGVkUmVzcG9uc2U6IHN0cmluZztcblxuICAgIGlmIChpc0F4aW9zRXJyb3IoZXJyb3IpICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBlcnJvci5yZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgZGF0YTogZXJyb3IucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnM6IGVycm9yLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIHNjaGVtYTpcbiAgICAgICAgICBnZXRSZXNwb25zZVNjaGVtYShcbiAgICAgICAgICAgIGpzb25WYWx1ZVRvUmVjb3JkKHRvb2wucmVzcG9uc2VzKSxcbiAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0sXG4gICAgICAgICAgKSB8fCBcIm5vIHNjaGVtYSBmb3VuZCBmb3IgcmVzcG9uc2VcIixcbiAgICAgIH07XG4gICAgICBmb3JtYXR0ZWRSZXNwb25zZSA9IHR5cGVvZiBlcnJvclJlc3BvbnNlID09PSBcInN0cmluZ1wiID8gZXJyb3JSZXNwb25zZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yUmVzcG9uc2UsIG51bGwsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXR0ZWRSZXNwb25zZSA9IGBBUEkgY2FsbCBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IGZvcm1hdHRlZFJlc3BvbnNlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZVNjaGVtYShcbiAgcmVzcG9uc2VzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgc3RhdHVzOiBzdHJpbmcgfCBudW1iZXIsXG4gIGNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4pIHtcbiAgY29uc3Qgc3RhdHVzS2V5ID0gU3RyaW5nKHN0YXR1cyk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZXNbc3RhdHVzS2V5XSB8fCByZXNwb25zZXNbXCJkZWZhdWx0XCJdO1xuICBpZiAoIXJlc3BvbnNlKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGlmIChcbiAgICB0eXBlb2YgcmVzcG9uc2UgPT09IFwib2JqZWN0XCIgJiZcbiAgICByZXNwb25zZSAhPT0gbnVsbCAmJlxuICAgIFwiY29udGVudFwiIGluIHJlc3BvbnNlICYmXG4gICAgdHlwZW9mIChyZXNwb25zZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikuY29udGVudCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIChyZXNwb25zZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikuY29udGVudCAhPT0gbnVsbFxuICApIHtcbiAgICBjb25zdCBjb250ZW50ID0gKHJlc3BvbnNlIGFzIHsgY29udGVudDogUmVjb3JkPHN0cmluZywgeyBzY2hlbWE/OiB1bmtub3duIH0+IH0pLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnRbY29udGVudFR5cGVdPy5zY2hlbWEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICBjb250ZW50OiBjb250ZW50W2NvbnRlbnRUeXBlXS5zY2hlbWEsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGYWxsYmFjazogcmV0dXJuIHRoZSBmaXJzdCBhdmFpbGFibGUgc2NoZW1hXG4gICAgY29uc3QgZmlyc3RDb250ZW50ID0gT2JqZWN0LnZhbHVlcyhjb250ZW50KVswXTtcbiAgICBpZiAoZmlyc3RDb250ZW50ICYmIHR5cGVvZiBmaXJzdENvbnRlbnQgPT09IFwib2JqZWN0XCIgJiYgXCJzY2hlbWFcIiBpbiBmaXJzdENvbnRlbnQpIHtcbiAgICAgIHJldHVybiAoZmlyc3RDb250ZW50IGFzIHsgc2NoZW1hPzogdW5rbm93biB9KS5zY2hlbWE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFBhdGhQYXJhbXMoXG4gIHVybDogc3RyaW5nLFxuICBjYWxsUGFyYW1ldGVyczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHNwZWNQYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBPcGVuQVBJVjMuUGFyYW1ldGVyT2JqZWN0Pixcbik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgY29uc3QgcGF0aFBhcmFtczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHBhcmFtXSBvZiBPYmplY3QuZW50cmllcyhzcGVjUGFyYW1ldGVycykpIHtcbiAgICBpZiAocGFyYW0uaW4gPT09IFwicGF0aFwiICYmIGNhbGxQYXJhbWV0ZXJzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGF0aFBhcmFtc1trZXldID0gY2FsbFBhcmFtZXRlcnNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aFBhcmFtcztcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0hhbmRsZWJhcnNUZW1wbGF0ZShsb2dnZXI6IExvZ2dlciwgdGVtcGxhdGU6IHN0cmluZywgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcge1xuICBsb2dnZXIuZGVidWcoYFByb2Nlc3NpbmcgSGFuZGxlYmFycyB0ZW1wbGF0ZSB3aXRoIGRhdGEga2V5czogJHtPYmplY3Qua2V5cyhkYXRhKS5qb2luKFwiLCBcIil9YCk7XG5cbiAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjb21waWxlZFRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZShkYXRhKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIud2FybihgRXJyb3IgcHJvY2Vzc2luZyBIYW5kbGViYXJzIHRlbXBsYXRlYCwgZXJyb3IpO1xuICAgIHJldHVybiBgVGVtcGxhdGUgcHJvY2Vzc2luZyBlcnJvcjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YDtcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBqc29uVmFsdWVUb1JlY29yZCA9ICh2YWx1ZTogdW5rbm93bik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cbiAgcmV0dXJuIHt9O1xufTtcbiIsICJpbXBvcnQgeyBBeGlvc1JlcXVlc3RDb25maWcgfSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7IE9wZW5BUElWMyB9IGZyb20gXCJvcGVuYXBpLXR5cGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwid2luc3RvblwiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcblxudHlwZSBTY2hlbWFPYmplY3QgPSBPcGVuQVBJVjMuU2NoZW1hT2JqZWN0O1xudHlwZSBQYXJhbWV0ZXJPYmplY3QgPSBPcGVuQVBJVjMuUGFyYW1ldGVyT2JqZWN0O1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWm9kU2NoZW1hRnJvbVBhcmFtZXRlcnMoXG4gIGxvZ2dlcjogTG9nZ2VyLFxuICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBQYXJhbWV0ZXJPYmplY3Q+LFxuKTogUmVjb3JkPHN0cmluZywgei5ab2RUeXBlPHVua25vd24+PiB7XG4gIGxvZ2dlci5kZWJ1ZyhgQ29udmVydGluZyBwYXJhbWV0ZXJzIHRvIFpvZCBzY2hlbWFgKTtcbiAgY29uc3QgcGFyYW1TY2hlbWE6IFJlY29yZDxzdHJpbmcsIHouWm9kVHlwZTx1bmtub3duPj4gPSB7fTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHBhcmFtXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbWV0ZXJzKSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgUHJvY2Vzc2luZyBwYXJhbWV0ZXI6ICR7a2V5fWApO1xuXG4gICAgaWYgKCFwYXJhbSB8fCB0eXBlb2YgcGFyYW0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgSW52YWxpZCBwYXJhbWV0ZXIgJHtrZXl9LCBkZWZhdWx0aW5nIHRvIGFueWApO1xuICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IHouYW55KCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1JlcXVpcmVkID0gISFwYXJhbS5yZXF1aXJlZDtcblxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGJvZHkgcGFyYW1ldGVyc1xuICAgIGlmIChwYXJhbS5pbiA9PT0gXCJib2R5XCIpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgRm91bmQgYm9keSBwYXJhbWV0ZXI6ICR7a2V5fWApO1xuICAgICAgaWYgKCFwYXJhbS5zY2hlbWEpIHtcbiAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LmFueSgpIDogei5hbnkoKS5vcHRpb25hbCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcIiRyZWZcIiBpbiBwYXJhbS5zY2hlbWEpIHtcbiAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LmFueSgpIDogei5hbnkoKS5vcHRpb25hbCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjaGVtYSA9IHBhcmFtLnNjaGVtYSBhcyBTY2hlbWFPYmplY3Q7XG4gICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2NoZW1hIGJhc2VkIG9uIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGJvZHlTY2hlbWEgPSB6Lm9iamVjdChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcykucmVkdWNlKFxuICAgICAgICAgICAgKGFjYywgW3Byb3BOYW1lLCBwcm9wU2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBwcm9wVHlwZSA9IChwcm9wU2NoZW1hIGFzIFNjaGVtYU9iamVjdCkudHlwZTtcbiAgICAgICAgICAgICAgbGV0IHpvZFR5cGU6IHouWm9kVHlwZSA9IHouYW55KCk7XG5cbiAgICAgICAgICAgICAgaWYgKHByb3BUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgem9kVHlwZSA9IHouc3RyaW5nKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcFR5cGUgPT09IFwibnVtYmVyXCIgfHwgcHJvcFR5cGUgPT09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICAgICAgem9kVHlwZSA9IHoubnVtYmVyKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcFR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgem9kVHlwZSA9IHouYm9vbGVhbigpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICB6b2RUeXBlID0gei5hcnJheSh6LmFueSgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHpvZFR5cGUgPSB6LnJlY29yZCh6LmFueSgpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChcImRlc2NyaXB0aW9uXCIgaW4gcHJvcFNjaGVtYSAmJiBwcm9wU2NoZW1hLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgem9kVHlwZSA9IHpvZFR5cGUuZGVzY3JpYmUocHJvcFNjaGVtYS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpbiBzY2hlbWFcbiAgICAgICAgICAgICAgY29uc3QgaXNQcm9wUmVxdWlyZWQgPSBzY2hlbWEucmVxdWlyZWQ/LmluY2x1ZGVzKHByb3BOYW1lKSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgYWNjW3Byb3BOYW1lXSA9IGlzUHJvcFJlcXVpcmVkID8gem9kVHlwZSA6IHpvZFR5cGUub3B0aW9uYWwoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCB6LlpvZFR5cGU+LFxuICAgICAgICAgICksXG4gICAgICAgICk7XG5cbiAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyBib2R5U2NoZW1hIDogYm9keVNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LmFueSgpIDogei5hbnkoKS5vcHRpb25hbCgpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbS5zY2hlbWEpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgTm8gc2NoZW1hIGZvdW5kIGZvciBwYXJhbWV0ZXIgJHtrZXl9LCBkZWZhdWx0aW5nIHRvIGFueWApO1xuICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LmFueSgpIDogei5hbnkoKS5vcHRpb25hbCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKFwiJHJlZlwiIGluIHBhcmFtLnNjaGVtYSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBSZWZlcmVuY2Ugc2NoZW1hIGZvdW5kIGZvciBwYXJhbWV0ZXIgJHtrZXl9LCBkZWZhdWx0aW5nIHRvIGFueWApO1xuICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LmFueSgpIDogei5hbnkoKS5vcHRpb25hbCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NoZW1hID0gcGFyYW0uc2NoZW1hIGFzIFNjaGVtYU9iamVjdDtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnR5cGU7XG5cbiAgICBzd2l0Y2ggKHNjaGVtYVR5cGUpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY29uc3Qgc3RyaW5nU2NoZW1hID0gei5zdHJpbmcoKTtcblxuICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCA9PT0gXCJkYXRlLXRpbWVcIikge1xuICAgICAgICAgIHBhcmFtU2NoZW1hW2tleV0gPSBpc1JlcXVpcmVkID8gei5zdHJpbmcoKS5kYXRldGltZSgpIDogei5zdHJpbmcoKS5kYXRldGltZSgpLm9wdGlvbmFsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLmZvcm1hdCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LnN0cmluZygpLmVtYWlsKCkgOiB6LnN0cmluZygpLmVtYWlsKCkub3B0aW9uYWwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEuZm9ybWF0ID09PSBcInVyaVwiKSB7XG4gICAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LnN0cmluZygpLnVybCgpIDogei5zdHJpbmcoKS51cmwoKS5vcHRpb25hbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pICYmIHNjaGVtYS5lbnVtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhcmFtU2NoZW1hW2tleV0gPSBpc1JlcXVpcmVkXG4gICAgICAgICAgICAgID8gei5lbnVtKHNjaGVtYS5lbnVtIGFzIFtzdHJpbmcsIC4uLnN0cmluZ1tdXSlcbiAgICAgICAgICAgICAgOiB6LmVudW0oc2NoZW1hLmVudW0gYXMgW3N0cmluZywgLi4uc3RyaW5nW11dKS5vcHRpb25hbCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbVNjaGVtYVtrZXldID0gaXNSZXF1aXJlZCA/IHN0cmluZ1NjaGVtYSA6IHN0cmluZ1NjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbVNjaGVtYVtrZXldID0gaXNSZXF1aXJlZCA/IHN0cmluZ1NjaGVtYSA6IHN0cmluZ1NjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICBsZXQgbnVtYmVyU2NoZW1hID0gei5udW1iZXIoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLm1pbihzY2hlbWEubWluaW11bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5tYXgoc2NoZW1hLm1heGltdW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyBudW1iZXJTY2hlbWEgOiBudW1iZXJTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHBhcmFtU2NoZW1hW2tleV0gPSBpc1JlcXVpcmVkID8gei5ib29sZWFuKCkgOiB6LmJvb2xlYW4oKS5vcHRpb25hbCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIGlmIChzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICBpZiAoXCIkcmVmXCIgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICBwYXJhbVNjaGVtYVtrZXldID0gaXNSZXF1aXJlZCA/IHouYXJyYXkoei5hbnkoKSkgOiB6LmFycmF5KHouYW55KCkpLm9wdGlvbmFsKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1TY2hlbWEgPSBzY2hlbWEuaXRlbXMgYXMgU2NoZW1hT2JqZWN0O1xuICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpdGVtU2NoZW1hLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBwYXJhbVNjaGVtYVtrZXldID0gaXNSZXF1aXJlZCA/IHouYXJyYXkoei5zdHJpbmcoKSkgOiB6LmFycmF5KHouc3RyaW5nKCkpLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1UeXBlID09PSBcIm51bWJlclwiIHx8IGl0ZW1UeXBlID09PSBcImludGVnZXJcIikge1xuICAgICAgICAgICAgICBwYXJhbVNjaGVtYVtrZXldID0gaXNSZXF1aXJlZCA/IHouYXJyYXkoei5udW1iZXIoKSkgOiB6LmFycmF5KHoubnVtYmVyKCkpLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW1UeXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBwYXJhbVNjaGVtYVtrZXldID0gaXNSZXF1aXJlZCA/IHouYXJyYXkoei5ib29sZWFuKCkpIDogei5hcnJheSh6LmJvb2xlYW4oKSkub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmFtU2NoZW1hW2tleV0gPSBpc1JlcXVpcmVkID8gei5hcnJheSh6LmFueSgpKSA6IHouYXJyYXkoei5hbnkoKSkub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LmFycmF5KHouYW55KCkpIDogei5hcnJheSh6LmFueSgpKS5vcHRpb25hbCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIHBhcmFtU2NoZW1hW2tleV0gPSBpc1JlcXVpcmVkID8gei5yZWNvcmQoei5hbnkoKSkgOiB6LnJlY29yZCh6LmFueSgpKS5vcHRpb25hbCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBVbmtub3duIHBhcmFtZXRlciB0eXBlICR7c2NoZW1hVHlwZX0gZm9yICR7a2V5fSwgZGVmYXVsdGluZyB0byBhbnlgKTtcbiAgICAgICAgcGFyYW1TY2hlbWFba2V5XSA9IGlzUmVxdWlyZWQgPyB6LmFueSgpIDogei5hbnkoKS5vcHRpb25hbCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmRlc2NyaXB0aW9uICYmIHBhcmFtU2NoZW1hW2tleV0pIHtcbiAgICAgIHBhcmFtU2NoZW1hW2tleV0gPSAocGFyYW1TY2hlbWFba2V5XSBhcyB6LlpvZFR5cGUpLmRlc2NyaWJlKHNjaGVtYS5kZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmFtU2NoZW1hO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRSZXF1ZXN0Q29uZmlnKFxuICBsb2dnZXI6IExvZ2dlcixcbiAgYXBpQ2FsbE1ldGhvZDogc3RyaW5nLFxuICBhcGlDYWxsVXJsOiBzdHJpbmcsXG4gIGJhc2VVcmw6IHN0cmluZyxcbiAgc3BlY1BhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIFBhcmFtZXRlck9iamVjdD4sXG4gIGNhbGxQYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgdG9vbE5hbWU6IHN0cmluZyxcbik6IHsgY29uZmlnOiBBeGlvc1JlcXVlc3RDb25maWc7IG1pc3NpbmdSZXF1aXJlZFBhcmFtPzogc3RyaW5nIH0ge1xuICBjb25zdCBjb25maWc6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHtcbiAgICBtZXRob2Q6IGFwaUNhbGxNZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICB1cmw6IGFwaUNhbGxVcmwuc3RhcnRzV2l0aChcImh0dHBcIikgPyBhcGlDYWxsVXJsIDogYmFzZVVybCA/IGAke2Jhc2VVcmx9JHthcGlDYWxsVXJsfWAgOiBhcGlDYWxsVXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHBhcmFtczoge30sXG4gICAgZGF0YTogbnVsbCxcbiAgfTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHBhcmFtXSBvZiBPYmplY3QuZW50cmllcyhzcGVjUGFyYW1ldGVycykpIHtcbiAgICBpZiAoIXBhcmFtIHx8IHR5cGVvZiBwYXJhbSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlID0gY2FsbFBhcmFtZXRlcnNba2V5XTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHBhcmFtLnNjaGVtYSAmJiBcImRlZmF1bHRcIiBpbiBwYXJhbS5zY2hlbWEpIHtcbiAgICAgICAgdmFsdWUgPSBwYXJhbS5zY2hlbWEuZGVmYXVsdDtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBVc2luZyBkZWZhdWx0IHZhbHVlIGZvciBwYXJhbWV0ZXIgJHtrZXl9OiAke3ZhbHVlfWApO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbS5yZXF1aXJlZCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFJlcXVpcmVkIHBhcmFtZXRlciAke2tleX0gbWlzc2luZyBmb3IgdG9vbCAke3Rvb2xOYW1lfWApO1xuICAgICAgICByZXR1cm4geyBjb25maWcsIG1pc3NpbmdSZXF1aXJlZFBhcmFtOiBrZXkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgT3B0aW9uYWwgcGFyYW1ldGVyICR7a2V5fSBub3QgcHJvdmlkZWRgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbS5pbikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwYXJhbS5pbikge1xuICAgICAgY2FzZSBcInF1ZXJ5XCI6XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQWRkaW5nIHF1ZXJ5IHBhcmFtZXRlciAke2tleX09JHt2YWx1ZX1gKTtcbiAgICAgICAgY29uZmlnLnBhcmFtcyA9IGNvbmZpZy5wYXJhbXMgfHwge307XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNvbmZpZy5wYXJhbXNba2V5XSA9IHBhcmFtLmV4cGxvZGVcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICAubWFwKFN0cmluZylcbiAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiBlbmNvZGVVUklDb21wb25lbnQodikpXG4gICAgICAgICAgICAgICAgLmpvaW4oXCImXCIpXG4gICAgICAgICAgICA6IHZhbHVlLm1hcChTdHJpbmcpLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIsXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmZpZy5wYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICBsb2dnZXIuZGVidWcoYFJlcGxhY2luZyBwYXRoIHBhcmFtZXRlciAke2tleX09JHt2YWx1ZX1gKTtcbiAgICAgICAgY29uc3QgcGF0aFZhbHVlID0gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gTWF0aC5mbG9vcih2YWx1ZSkudG9TdHJpbmcoKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNvbmZpZy51cmwgPSBjb25maWcudXJsPy5yZXBsYWNlKGB7JHtrZXl9fWAsIGVuY29kZVVSSUNvbXBvbmVudChwYXRoVmFsdWUpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBBZGRpbmcgaGVhZGVyICR7a2V5fT0ke3ZhbHVlfWApO1xuICAgICAgICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBjb25maWcuaGVhZGVyc1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJjb29raWVcIjpcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBBZGRpbmcgY29va2llICR7a2V5fT0ke3ZhbHVlfWApO1xuICAgICAgICBjb25zdCBjb29raWVWYWx1ZSA9IGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHZhbHVlKSl9YDtcbiAgICAgICAgaWYgKGNvbmZpZy5oZWFkZXJzPy5Db29raWUpIHtcbiAgICAgICAgICBjb25maWcuaGVhZGVycy5Db29raWUgKz0gYDsgJHtjb29raWVWYWx1ZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgY29uZmlnLmhlYWRlcnMuQ29va2llID0gY29va2llVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChbXCJQT1NUXCIsIFwiUFVUXCIsIFwiUEFUQ0hcIl0uaW5jbHVkZXMoYXBpQ2FsbE1ldGhvZCkpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYEFkZGluZyAke2tleX0gdG8gcmVxdWVzdCBib2R5YCk7XG4gICAgICAgICAgY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcbiAgICAgICAgICAoY29uZmlnLmRhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgaWYgKFtcIlBPU1RcIiwgXCJQVVRcIiwgXCJQQVRDSFwiXS5pbmNsdWRlcyhhcGlDYWxsTWV0aG9kKSkge1xuICAgIGNvbnN0IGJvZHlQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gICAgbGV0IGhhc0JvZHlQYXJhbWV0ZXIgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgcGFyYW1dIG9mIE9iamVjdC5lbnRyaWVzKHNwZWNQYXJhbWV0ZXJzKSkge1xuICAgICAgaWYgKHBhcmFtLmluID09PSBcImJvZHlcIiAmJiBjYWxsUGFyYW1ldGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBib2R5IHBhcmFtZXRlcjogJHtrZXl9YCk7XG4gICAgICAgIGNvbmZpZy5kYXRhID0gY2FsbFBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgY29uZmlnLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgaGFzQm9keVBhcmFtZXRlciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzQm9keVBhcmFtZXRlcikge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2FsbFBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gc3BlY1BhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgaWYgKCFwYXJhbSB8fCAocGFyYW0uaW4gIT09IFwicXVlcnlcIiAmJiBwYXJhbS5pbiAhPT0gXCJwYXRoXCIgJiYgcGFyYW0uaW4gIT09IFwiaGVhZGVyXCIgJiYgcGFyYW0uaW4gIT09IFwiY29va2llXCIpKSB7XG4gICAgICAgICAgYm9keVBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGJvZHlQYXJhbXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBCdWlsZGluZyByZXF1ZXN0IGJvZHkgZnJvbSBub24tcGF0aC9xdWVyeS9oZWFkZXIgcGFyYW1ldGVyc2ApO1xuICAgICAgICBjb25maWcuZGF0YSA9IGJvZHlQYXJhbXM7XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNhbGxQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSkge1xuICAgIGNvbmZpZy5oZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGNhbGxQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXTtcbiAgfVxuXG4gIHJldHVybiB7IGNvbmZpZyB9O1xufVxuIiwgImltcG9ydCB7IE5leHRGdW5jdGlvbiwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIndpbnN0b25cIjtcbmltcG9ydCB7IFNlcnZlckF1dGhTZXJ2aWNlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL3NlcnZlci1hdXRoLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IEFwcFJlcXVlc3QgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VydmVyQXV0aE1pZGRsZXdhcmUoc2VydmVyQXV0aFNlcnZpY2U6IFNlcnZlckF1dGhTZXJ2aWNlLCBsb2dnZXI/OiBMb2dnZXIpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXE6IEFwcFJlcXVlc3QsIHJlczogUmVzcG9uc2UsIG5leHQ6IE5leHRGdW5jdGlvbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBFeHRyYWN0IHNlcnZlciBJRCBmcm9tIHJlcXVlc3QgKHNldCBieSBzZXJ2ZXJJZE1pZGRsZXdhcmUpIG9yIGZhbGxiYWNrIHRvIHBhcmFtcy9oZWFkZXJzXG4gICAgICBjb25zdCBzZXJ2ZXJJZCA9IChyZXEgYXMgQXBwUmVxdWVzdCkuc2VydmVySWQgfHwgcmVxLnBhcmFtcy5zZXJ2ZXJJZCB8fCAocmVxLmhlYWRlcnNbXCJ4LXNlcnZlci1pZFwiXSBhcyBzdHJpbmcpO1xuXG4gICAgICBpZiAoIXNlcnZlcklkKSB7XG4gICAgICAgIGxvZ2dlcj8ud2FybihcIlNlcnZlciBhdXRoZW50aWNhdGlvbiBmYWlsZWQ6IG1pc3Npbmcgc2VydmVyIElEXCIsIHtcbiAgICAgICAgICBwYXRoOiByZXEucGF0aCxcbiAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgaGVhZGVyczogcmVxLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oe1xuICAgICAgICAgIGVycm9yOiBcIlNlcnZlciBJRCBpcyByZXF1aXJlZCBmb3IgYXV0aGVudGljYXRpb25cIixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEF1dGhlbnRpY2F0ZSB0aGUgcmVxdWVzdCBmb3IgdGhpcyBzcGVjaWZpYyBzZXJ2ZXIgdXNpbmcgc3RyYXRlZ3kgcGF0dGVyblxuICAgICAgY29uc3QgYXV0aFJlc3VsdCA9IGF3YWl0IHNlcnZlckF1dGhTZXJ2aWNlLmF1dGhlbnRpY2F0ZVNlcnZlclJlcXVlc3QocmVxLCBzZXJ2ZXJJZCk7XG5cbiAgICAgIGlmICghYXV0aFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGxvZ2dlcj8ud2FybihcIlNlcnZlciBhdXRoZW50aWNhdGlvbiBmYWlsZWRcIiwge1xuICAgICAgICAgIHNlcnZlcklkLFxuICAgICAgICAgIGVycm9yOiBhdXRoUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHBhdGg6IHJlcS5wYXRoLFxuICAgICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgICBhdXRoVHlwZTogYXV0aFJlc3VsdC51c2VyQ29udGV4dD8uYXV0aFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDEpLmpzb24oe1xuICAgICAgICAgIGVycm9yOiBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiLFxuICAgICAgICAgIGRldGFpbHM6IGF1dGhSZXN1bHQuZXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBMb2cgc3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxuICAgICAgbG9nZ2VyPy5pbmZvKFwiU2VydmVyIGF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWxcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgYXV0aFR5cGU6IGF1dGhSZXN1bHQudXNlckNvbnRleHQ/LmF1dGhUeXBlLFxuICAgICAgICB1c2VySWQ6IGF1dGhSZXN1bHQudXNlckNvbnRleHQ/LnVzZXJJZCxcbiAgICAgICAgdGVuYW50SWQ6IGF1dGhSZXN1bHQudXNlckNvbnRleHQ/LnRlbmFudElkLFxuICAgICAgICBwYXRoOiByZXEucGF0aCxcbiAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEF0dGFjaCBhdXRoZW50aWNhdGlvbiByZXN1bHQgdG8gcmVxdWVzdCBmb3IgZG93bnN0cmVhbSBoYW5kbGVyc1xuICAgICAgcmVxLnNlcnZlckF1dGggPSBhdXRoUmVzdWx0O1xuICAgICAgcmVxLnNlcnZlcklkID0gc2VydmVySWQ7XG5cbiAgICAgIG5leHQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgbG9nZ2VyPy5lcnJvcihcIkludGVybmFsIGF1dGhlbnRpY2F0aW9uIGVycm9yXCIsIHtcbiAgICAgICAgc2VydmVySWQ6IHJlcS5wYXJhbXMuc2VydmVySWQgfHwgcmVxLmhlYWRlcnNbXCJ4LXNlcnZlci1pZFwiXSxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgcGF0aDogcmVxLnBhdGgsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgIH0pO1xuICAgICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJJbnRlcm5hbCBhdXRoZW50aWNhdGlvbiBlcnJvclwiLFxuICAgICAgICBkZXRhaWxzOiBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3B0aW9uYWwgbWlkZGxld2FyZSBmb3Igcm91dGVzIHRoYXQgbmVlZCBhdXRoZW50aWNhdGlvbiBidXQgd2FudCB0byBoYW5kbGUgZmFpbHVyZXMgZ3JhY2VmdWxseVxuICogVGhpcyBtaWRkbGV3YXJlIHdpbGwgYXR0ZW1wdCBhdXRoZW50aWNhdGlvbiBidXQgbmV2ZXIgYmxvY2sgdGhlIHJlcXVlc3QsIG1ha2luZyBhdXRoIGRhdGFcbiAqIGF2YWlsYWJsZSB0byBkb3duc3RyZWFtIGhhbmRsZXJzIGZvciBjb25kaXRpb25hbCBsb2dpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0aW9uYWxTZXJ2ZXJBdXRoTWlkZGxld2FyZShzZXJ2ZXJBdXRoU2VydmljZTogU2VydmVyQXV0aFNlcnZpY2UsIGxvZ2dlcj86IExvZ2dlcikge1xuICByZXR1cm4gYXN5bmMgKHJlcTogQXBwUmVxdWVzdCwgcmVzOiBSZXNwb25zZSwgbmV4dDogTmV4dEZ1bmN0aW9uKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlcnZlcklkID0gcmVxLnBhcmFtcy5zZXJ2ZXJJZCB8fCAocmVxLmhlYWRlcnNbXCJ4LXNlcnZlci1pZFwiXSBhcyBzdHJpbmcpO1xuXG4gICAgICBpZiAoc2VydmVySWQpIHtcbiAgICAgICAgbG9nZ2VyPy5kZWJ1ZyhcIkF0dGVtcHRpbmcgb3B0aW9uYWwgc2VydmVyIGF1dGhlbnRpY2F0aW9uXCIsIHtcbiAgICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgICBwYXRoOiByZXEucGF0aCxcbiAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGF1dGhSZXN1bHQgPSBhd2FpdCBzZXJ2ZXJBdXRoU2VydmljZS5hdXRoZW50aWNhdGVTZXJ2ZXJSZXF1ZXN0KHJlcSwgc2VydmVySWQpO1xuICAgICAgICByZXEuc2VydmVyQXV0aCA9IGF1dGhSZXN1bHQ7XG4gICAgICAgIHJlcS5zZXJ2ZXJJZCA9IHNlcnZlcklkO1xuXG4gICAgICAgIGlmIChhdXRoUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBsb2dnZXI/LmRlYnVnKFwiT3B0aW9uYWwgc2VydmVyIGF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWxcIiwge1xuICAgICAgICAgICAgc2VydmVySWQsXG4gICAgICAgICAgICBhdXRoVHlwZTogYXV0aFJlc3VsdC51c2VyQ29udGV4dD8uYXV0aFR5cGUsXG4gICAgICAgICAgICB1c2VySWQ6IGF1dGhSZXN1bHQudXNlckNvbnRleHQ/LnVzZXJJZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXI/LmRlYnVnKFwiT3B0aW9uYWwgc2VydmVyIGF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiLCB7XG4gICAgICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgICAgIGVycm9yOiBhdXRoUmVzdWx0LmVycm9yLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXI/LmRlYnVnKFwiTm8gc2VydmVyIElEIHByb3ZpZGVkIGZvciBvcHRpb25hbCBhdXRoZW50aWNhdGlvblwiLCB7XG4gICAgICAgICAgcGF0aDogcmVxLnBhdGgsXG4gICAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQWx3YXlzIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgYXV0aGVudGljYXRpb24gcmVzdWx0XG4gICAgICBuZXh0KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIGxvZ2dlcj8ud2FybihcIk9wdGlvbmFsIGF1dGhlbnRpY2F0aW9uIGVuY291bnRlcmVkIGVycm9yXCIsIHtcbiAgICAgICAgc2VydmVySWQ6IHJlcS5wYXJhbXMuc2VydmVySWQgfHwgcmVxLmhlYWRlcnNbXCJ4LXNlcnZlci1pZFwiXSxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgcGF0aDogcmVxLnBhdGgsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgIH0pO1xuICAgICAgLy8gRG9uJ3QgYmxvY2sgdGhlIHJlcXVlc3QgZXZlbiBvbiBlcnJvclxuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBOZXh0RnVuY3Rpb24sIFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IGlzQXBwUmVxdWVzdCB9IGZyb20gXCIuLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBzZXJ2ZXJJZE1pZGRsZXdhcmUgPSAocmVxOiBSZXF1ZXN0LCBfcmVzOiBSZXNwb25zZSwgbmV4dDogTmV4dEZ1bmN0aW9uKTogdm9pZCA9PiB7XG4gIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGRvZXMgbm90IGhhdmUgbG9nZ2VyIG9yIGRiXCIpO1xuICB9XG5cbiAgY29uc3Qgc2VydmVySWRPdmVycmlkZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gcHJvY2Vzcy5lbnYuTE9DQUxfU0VSVkVSX0lEO1xuXG4gIGlmIChzZXJ2ZXJJZE92ZXJyaWRlKSB7XG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhgVXNpbmcgbG9jYWwgc2VydmVyIElEOiAke3NlcnZlcklkT3ZlcnJpZGV9YCk7XG4gICAgcmVxLnNlcnZlcklkID0gc2VydmVySWRPdmVycmlkZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaGVjayBmb3Igc2VydmVySWQgaW4gcXVlcnkgcGFyYW1ldGVycyBmaXJzdCAoZm9yIGxvY2FsIGRldmVsb3BtZW50KVxuICAgIGNvbnN0IHF1ZXJ5U2VydmVySWQgPSByZXEucXVlcnkuc2VydmVySWQgYXMgc3RyaW5nO1xuICAgIGlmIChxdWVyeVNlcnZlcklkKSB7XG4gICAgICByZXEubG9nZ2VyLmRlYnVnKGBVc2luZyBzZXJ2ZXIgSUQgZnJvbSBxdWVyeSBwYXJhbWV0ZXI6ICR7cXVlcnlTZXJ2ZXJJZH1gKTtcbiAgICAgIHJlcS5zZXJ2ZXJJZCA9IHF1ZXJ5U2VydmVySWQ7XG4gICAgICByZXEubG9nZ2VyID0gcmVxLmxvZ2dlci5jaGlsZCh7XG4gICAgICAgIHNlcnZlcklkOiBxdWVyeVNlcnZlcklkLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdoZW4gZGVwbG95ZWQsIHdlIGV4cGVjdGVkIGhvc3RuYW1lIHRvIGJlIGluIHRoZSBmb3JtYXQgPHNlcnZlcklkPi5zb21ldGhpbmcuYWdlbnRwYXNzLmFpXG4gICAgICBjb25zdCBzZXJ2ZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gcmVxLmhvc3RuYW1lLnNwbGl0KFwiLlwiKVswXTtcbiAgICAgIGlmIChzZXJ2ZXJJZCA9PT0gXCJhcHBcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGhvc3RuYW1lIHdhcyB1c2VkIGZvciB0aGUgbWNwIHNlcnZlciByZXF1ZXN0OiAke3JlcS5ob3N0bmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJlcS5sb2dnZXIuZGVidWcoYFVzaW5nIHNlcnZlciBJRCBmcm9tIGhvc3RuYW1lOiAke3NlcnZlcklkfWApO1xuICAgICAgcmVxLnNlcnZlcklkID0gc2VydmVySWQ7XG4gICAgICByZXEubG9nZ2VyID0gcmVxLmxvZ2dlci5jaGlsZCh7XG4gICAgICAgIHNlcnZlcklkLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQdWJsaWNLZXkgfSBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgand0IGZyb20gXCJqc29ud2VidG9rZW5cIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJ3aW5zdG9uXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSnd0VmFsaWRhdGlvblJlc3VsdCB7XG4gIHZhbGlkOiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbiAgcGF5bG9hZD86IHVua25vd247XG59XG5cbmludGVyZmFjZSBKd3RLZXkge1xuICBraWQ6IHN0cmluZztcbiAga3R5OiBzdHJpbmc7XG4gIHVzZT86IHN0cmluZztcbiAgbjogc3RyaW5nO1xuICBlOiBzdHJpbmc7XG4gIHg1Yz86IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgQ2FjaGVkSnd0S2V5cyB7XG4gIGtleXM6IEp3dEtleVtdO1xuICBleHBpcnk6IG51bWJlcjtcbiAgbGFzdEZldGNoOiBudW1iZXI7XG4gIGZhaWx1cmVDb3VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQ2lyY3VpdEJyZWFrZXJTdGF0ZSB7XG4gIHN0YXRlOiBcIkNMT1NFRFwiIHwgXCJPUEVOXCIgfCBcIkhBTEZfT1BFTlwiO1xuICBmYWlsdXJlQ291bnQ6IG51bWJlcjtcbiAgbGFzdEZhaWx1cmVUaW1lOiBudW1iZXI7XG4gIG5leHRBdHRlbXB0VGltZTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQ2FjaGVTdGF0cyB7XG4gIGtleUNvdW50OiBudW1iZXI7XG4gIGxhc3RGZXRjaDogc3RyaW5nO1xuICBleHBpcnk6IHN0cmluZztcbiAgZXhwaXJlZDogYm9vbGVhbjtcbiAgZmFpbHVyZUNvdW50OiBudW1iZXI7XG4gIGNpcmN1aXRCcmVha2VyU3RhdGU6IHN0cmluZztcbiAgcmF0ZUxpbWl0Q291bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFJhdGVMaW1pdFN0YXRlIHtcbiAgY291bnQ6IG51bWJlcjtcbiAgd2luZG93U3RhcnQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBQcm9kdWN0aW9uLXJlYWR5IEpXVCBBdXRoZW50aWNhdGlvbiBTZXJ2aWNlXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIEpXVCBzaWduYXR1cmUtb25seSB2ZXJpZmljYXRpb24gKG5vIHBheWxvYWQgdmFsaWRhdGlvbilcbiAqIC0gUlNBIGtleSBzdXBwb3J0IHdpdGgga2V5IHJvdGF0aW9uIChSUzI1NiwgUlMzODQsIFJTNTEyIG9ubHkpXG4gKiAtIEludGVsbGlnZW50IGNhY2hpbmcgd2l0aCAxLWhvdXIgVFRMIGFuZCBlYXJseSByZWZyZXNoXG4gKiAtIENpcmN1aXQgYnJlYWtlciBmb3IgdW5yZWFjaGFibGUgSldLUyBlbmRwb2ludHNcbiAqIC0gUmF0ZSBsaW1pdGluZyBmb3IgYWJ1c2UgcHJldmVudGlvblxuICogLSBDb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nIGFuZCBsb2dnaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBKd3RBdXRoU2VydmljZSB7XG4gIHByaXZhdGUga2V5Q2FjaGU6IE1hcDxzdHJpbmcsIENhY2hlZEp3dEtleXM+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGNpcmN1aXRCcmVha2VyczogTWFwPHN0cmluZywgQ2lyY3VpdEJyZWFrZXJTdGF0ZT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmF0ZUxpbWl0czogTWFwPHN0cmluZywgUmF0ZUxpbWl0U3RhdGU+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIENvbmZpZ3VyYXRpb24gY29uc3RhbnRzXG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfVFRMID0gMzYwMDAwMDsgLy8gMSBob3VyXG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfUkVGUkVTSF9USFJFU0hPTEQgPSAzMDAwMDA7IC8vIDUgbWludXRlcyBiZWZvcmUgZXhwaXJ5XG4gIHByaXZhdGUgcmVhZG9ubHkgQ0lSQ1VJVF9CUkVBS0VSX0ZBSUxVUkVfVEhSRVNIT0xEID0gNTtcbiAgcHJpdmF0ZSByZWFkb25seSBDSVJDVUlUX0JSRUFLRVJfVElNRU9VVCA9IDYwMDAwOyAvLyAxIG1pbnV0ZVxuICBwcml2YXRlIHJlYWRvbmx5IFJBVEVfTElNSVRfV0lORE9XID0gNjAwMDA7IC8vIDEgbWludXRlXG4gIHByaXZhdGUgcmVhZG9ubHkgUkFURV9MSU1JVF9NQVhfUkVRVUVTVFMgPSAxMDsgLy8gcGVyIHdpbmRvd1xuICBwcml2YXRlIHJlYWRvbmx5IFJFUVVFU1RfVElNRU9VVCA9IDE1MDAwOyAvLyAxNSBzZWNvbmRzXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2dnZXI/OiBMb2dnZXIpIHt9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIEpXVCBzaWduYXR1cmUgdXNpbmcgSldLUyBlbmRwb2ludFxuICAgKiBJbXBsZW1lbnRzIGNvbXByZWhlbnNpdmUgZXJyb3IgaGFuZGxpbmcgYW5kIGNhY2hpbmdcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlSnd0U2lnbmF0dXJlKHRva2VuOiBzdHJpbmcsIGp3a3NVcmw6IHN0cmluZyk6IFByb21pc2U8Snd0VmFsaWRhdGlvblJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBSYXRlIGxpbWl0aW5nIGNoZWNrXG4gICAgICBpZiAoIXRoaXMuY2hlY2tSYXRlTGltaXQoandrc1VybCkpIHtcbiAgICAgICAgdGhpcy5sb2dnZXI/Lndhcm4oXCJSYXRlIGxpbWl0IGV4Y2VlZGVkIGZvciBKV0tTIGVuZHBvaW50XCIsIHsgandrc1VybCB9KTtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogXCJSYXRlIGxpbWl0IGV4Y2VlZGVkIGZvciBKV0tTIGVuZHBvaW50XCIgfTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVjb2RlIHRoZSB0b2tlbiBoZWFkZXIgdG8gZ2V0IHRoZSBrZXkgSURcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBqd3QuZGVjb2RlKHRva2VuLCB7IGNvbXBsZXRlOiB0cnVlIH0pO1xuICAgICAgaWYgKCFkZWNvZGVkIHx8IHR5cGVvZiBkZWNvZGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IFwiSW52YWxpZCBKV1QgZm9ybWF0XCIgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2lkID0gZGVjb2RlZC5oZWFkZXIua2lkO1xuICAgICAgaWYgKCFraWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogXCJNaXNzaW5nIGtleSBJRCBpbiBKV1QgaGVhZGVyXCIgfTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGFsZ29yaXRobSBmcm9tIGhlYWRlclxuICAgICAgY29uc3QgYWxnb3JpdGhtID0gZGVjb2RlZC5oZWFkZXIuYWxnO1xuICAgICAgaWYgKCFhbGdvcml0aG0gfHwgIVtcIlJTMjU2XCIsIFwiUlMzODRcIiwgXCJSUzUxMlwiXS5pbmNsdWRlcyhhbGdvcml0aG0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgVW5zdXBwb3J0ZWQgb3IgbWlzc2luZyBhbGdvcml0aG06ICR7YWxnb3JpdGhtfS4gT25seSBSUzI1NiwgUlMzODQsIFJTNTEyIGFyZSBzdXBwb3J0ZWQuYCxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBKV0tTIGtleXMgKHdpdGggY2FjaGluZyBhbmQgY2lyY3VpdCBicmVha2VyKVxuICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IHRoaXMuZmV0Y2hKd2tzS2V5c1dpdGhDaXJjdWl0QnJlYWtlcihqd2tzVXJsKTtcblxuICAgICAgLy8gRmluZCB0aGUga2V5IHdpdGggbWF0Y2hpbmcga2lkXG4gICAgICBjb25zdCBqd2tzS2V5ID0ga2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICBpZiAoIWp3a3NLZXkpIHtcbiAgICAgICAgLy8gVHJ5IHRvIHJlZnJlc2gga2V5cyBpbiBjYXNlIG9mIGtleSByb3RhdGlvblxuICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2hKd2tzS2V5cyhqd2tzVXJsKTtcbiAgICAgICAgY29uc3QgcmVmcmVzaGVkS2V5cyA9IGF3YWl0IHRoaXMuZmV0Y2hKd2tzS2V5c1dpdGhDaXJjdWl0QnJlYWtlcihqd2tzVXJsKTtcbiAgICAgICAgY29uc3QgcmVmcmVzaGVkS2V5ID0gcmVmcmVzaGVkS2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG5cbiAgICAgICAgaWYgKCFyZWZyZXNoZWRLZXkpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIGVycm9yOiBgS2V5IElEICR7a2lkfSBub3QgZm91bmQgaW4gSldLUyBhZnRlciByZWZyZXNoYCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHRoZSByZWZyZXNoZWQga2V5XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHRoaXMuandrc0tleVRvUGVtKHJlZnJlc2hlZEtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVNpZ25hdHVyZSh0b2tlbiwgcHVibGljS2V5LCBhbGdvcml0aG0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IEpXS1Mga2V5IHRvIFBFTSBmb3JtYXQgYW5kIHZlcmlmeVxuICAgICAgY29uc3QgcHVibGljS2V5ID0gdGhpcy5qd2tzS2V5VG9QZW0oandrc0tleSk7XG4gICAgICByZXR1cm4gdGhpcy52ZXJpZnlTaWduYXR1cmUodG9rZW4sIHB1YmxpY0tleSwgYWxnb3JpdGhtKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiSldUIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGZhaWxlZFwiLCB7XG4gICAgICAgIGp3a3NVcmwsXG4gICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6IGBKV1QgdmFsaWRhdGlvbiBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgSldUIHNpZ25hdHVyZSB3aXRoIHNwZWNpZmljIGFsZ29yaXRobVxuICAgKi9cbiAgcHJpdmF0ZSB2ZXJpZnlTaWduYXR1cmUodG9rZW46IHN0cmluZywgcHVibGljS2V5OiBzdHJpbmcsIGFsZ29yaXRobTogc3RyaW5nKTogSnd0VmFsaWRhdGlvblJlc3VsdCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNpZ25hdHVyZS1vbmx5IHZlcmlmaWNhdGlvbiAtIG5vIHBheWxvYWQgdmFsaWRhdGlvblxuICAgICAgY29uc3QgcGF5bG9hZCA9IGp3dC52ZXJpZnkodG9rZW4sIHB1YmxpY0tleSwge1xuICAgICAgICBhbGdvcml0aG1zOiBbYWxnb3JpdGhtIGFzIGp3dC5BbGdvcml0aG1dLFxuICAgICAgICBpZ25vcmVFeHBpcmF0aW9uOiB0cnVlLCAvLyBXZSBvbmx5IHZlcmlmeSBzaWduYXR1cmUsIG5vdCBleHBpcmF0aW9uXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIHBheWxvYWQgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/Lndhcm4oXCJKV1Qgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIiwgeyBlcnJvcjogZXJyb3JNZXNzYWdlIH0pO1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcjogYFNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIEpXS1Mga2V5cyB3aXRoIGNpcmN1aXQgYnJlYWtlciBwYXR0ZXJuXG4gICAqL1xuICBhc3luYyBmZXRjaEp3a3NLZXlzV2l0aENpcmN1aXRCcmVha2VyKGp3a3NVcmw6IHN0cmluZyk6IFByb21pc2U8Snd0S2V5W10+IHtcbiAgICBjb25zdCBjaXJjdWl0U3RhdGUgPSB0aGlzLmdldENpcmN1aXRCcmVha2VyU3RhdGUoandrc1VybCk7XG5cbiAgICAvLyBDaGVjayBjaXJjdWl0IGJyZWFrZXIgc3RhdGVcbiAgICBpZiAoY2lyY3VpdFN0YXRlLnN0YXRlID09PSBcIk9QRU5cIikge1xuICAgICAgaWYgKERhdGUubm93KCkgPCBjaXJjdWl0U3RhdGUubmV4dEF0dGVtcHRUaW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2lyY3VpdCBicmVha2VyIE9QRU4gZm9yICR7andrc1VybH0uIE5leHQgYXR0ZW1wdCBhdCAke25ldyBEYXRlKGNpcmN1aXRTdGF0ZS5uZXh0QXR0ZW1wdFRpbWUpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1vdmUgdG8gaGFsZi1vcGVuIHN0YXRlXG4gICAgICAgIGNpcmN1aXRTdGF0ZS5zdGF0ZSA9IFwiSEFMRl9PUEVOXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCB0aGlzLmZldGNoSndrc0tleXMoandrc1VybCk7XG5cbiAgICAgIC8vIFN1Y2Nlc3MgLSByZXNldCBjaXJjdWl0IGJyZWFrZXJcbiAgICAgIGlmIChjaXJjdWl0U3RhdGUuc3RhdGUgIT09IFwiQ0xPU0VEXCIpIHtcbiAgICAgICAgY2lyY3VpdFN0YXRlLnN0YXRlID0gXCJDTE9TRURcIjtcbiAgICAgICAgY2lyY3VpdFN0YXRlLmZhaWx1cmVDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBIYW5kbGUgZmFpbHVyZVxuICAgICAgY2lyY3VpdFN0YXRlLmZhaWx1cmVDb3VudCsrO1xuICAgICAgY2lyY3VpdFN0YXRlLmxhc3RGYWlsdXJlVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgIGlmIChjaXJjdWl0U3RhdGUuZmFpbHVyZUNvdW50ID49IHRoaXMuQ0lSQ1VJVF9CUkVBS0VSX0ZBSUxVUkVfVEhSRVNIT0xEKSB7XG4gICAgICAgIGNpcmN1aXRTdGF0ZS5zdGF0ZSA9IFwiT1BFTlwiO1xuICAgICAgICBjaXJjdWl0U3RhdGUubmV4dEF0dGVtcHRUaW1lID0gRGF0ZS5ub3coKSArIHRoaXMuQ0lSQ1VJVF9CUkVBS0VSX1RJTUVPVVQ7XG4gICAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkNpcmN1aXQgYnJlYWtlciBPUEVOIGR1ZSB0byBmYWlsdXJlc1wiLCB7XG4gICAgICAgICAgandrc1VybCxcbiAgICAgICAgICBmYWlsdXJlQ291bnQ6IGNpcmN1aXRTdGF0ZS5mYWlsdXJlQ291bnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggSldLUyBrZXlzIHdpdGggaW50ZWxsaWdlbnQgY2FjaGluZ1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hKd2tzS2V5cyhqd2tzVXJsOiBzdHJpbmcpOiBQcm9taXNlPEp3dEtleVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmtleUNhY2hlLmdldChqd2tzVXJsKTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBJZiBub3QgZXhwaXJlZCwgcmV0dXJuIGNhY2hlZCBrZXlzXG4gICAgICAgIGlmIChub3cgPCBjYWNoZWQuZXhwaXJ5KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJlZnJlc2ggZWFybHkgKGludGVsbGlnZW50IHJlZnJlc2gpXG4gICAgICAgICAgaWYgKG5vdyA+IGNhY2hlZC5leHBpcnkgLSB0aGlzLkNBQ0hFX1JFRlJFU0hfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAvLyBSZWZyZXNoIGluIGJhY2tncm91bmQgd2l0aG91dCBibG9ja2luZ1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoSndrc0tleXNJbkJhY2tncm91bmQoandrc1VybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWNoZWQua2V5cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCBmcmVzaCBrZXlzXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaEZyZXNoSndrc0tleXMoandrc1VybCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIGZldGNoIGZhaWxzIGFuZCB3ZSBoYXZlIHN0YWxlIGNhY2hlZCBrZXlzLCB1c2UgdGhlbVxuICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5rZXlDYWNoZS5nZXQoandrc1VybCk7XG4gICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5rZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5sb2dnZXI/Lndhcm4oXCJVc2luZyBzdGFsZSBjYWNoZWQgSldLUyBrZXlzIGR1ZSB0byBmZXRjaCBmYWlsdXJlXCIsIHtcbiAgICAgICAgICBqd2tzVXJsLFxuICAgICAgICAgIGNhY2hlQWdlOiBEYXRlLm5vdygpIC0gY2FjaGVkLmxhc3RGZXRjaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYWNoZWQua2V5cztcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBmcmVzaCBKV0tTIGtleXMgZnJvbSBlbmRwb2ludFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaEZyZXNoSndrc0tleXMoandrc1VybDogc3RyaW5nKTogUHJvbWlzZTxKd3RLZXlbXT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goandrc1VybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIlVzZXItQWdlbnRcIjogXCJBZ2VudEJyaWRnZS8xLjBcIixcbiAgICAgICAgXCJDYWNoZS1Db250cm9sXCI6IFwibm8tY2FjaGVcIixcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy5SRVFVRVNUX1RJTUVPVVQpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBKV0tTIGVuZHBvaW50IGVycm9yOiBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgandrcyA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gICAgaWYgKCFqd2tzLmtleXMgfHwgIUFycmF5LmlzQXJyYXkoandrcy5rZXlzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBKV0tTIGZvcm1hdDogbWlzc2luZyBvciBpbnZhbGlkIGtleXMgYXJyYXlcIik7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIGZvciBSU0Egc2lnbmF0dXJlIGtleXMgb25seVxuICAgIGNvbnN0IHJzYUtleXMgPSBqd2tzLmtleXNcbiAgICAgIC5maWx0ZXIoKGtleTogdW5rbm93bikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBqd2tzS2V5ID0ga2V5IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBqd2tzS2V5Lmt0eSA9PT0gXCJSU0FcIiAmJlxuICAgICAgICAgICAgKGp3a3NLZXkudXNlID09PSBcInNpZ1wiIHx8ICFqd2tzS2V5LnVzZSkgJiYgLy8gdXNlIGlzIG9wdGlvbmFsLCBkZWZhdWx0IHRvIHNpZ1xuICAgICAgICAgICAgandrc0tleS5uICYmXG4gICAgICAgICAgICBqd2tzS2V5LmUgJiZcbiAgICAgICAgICAgIGp3a3NLZXkua2lkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KVxuICAgICAgLm1hcCgoa2V5KSA9PiBrZXkgYXMgSnd0S2V5KTtcblxuICAgIGlmIChyc2FLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgUlNBIHNpZ25hdHVyZSBrZXlzIGZvdW5kIGluIEpXS1NcIik7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGNhY2hlXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmtleUNhY2hlLnNldChqd2tzVXJsLCB7XG4gICAgICBrZXlzOiByc2FLZXlzLFxuICAgICAgZXhwaXJ5OiBub3cgKyB0aGlzLkNBQ0hFX1RUTCxcbiAgICAgIGxhc3RGZXRjaDogbm93LFxuICAgICAgZmFpbHVyZUNvdW50OiAwLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJzYUtleXM7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCBKV0tTIGtleXMgaW4gYmFja2dyb3VuZFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWZyZXNoSndrc0tleXNJbkJhY2tncm91bmQoandrc1VybDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZmV0Y2hGcmVzaEp3a3NLZXlzKGp3a3NVcmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlcj8ud2FybihcIkJhY2tncm91bmQgSldLUyByZWZyZXNoIGZhaWxlZFwiLCB7XG4gICAgICAgIGp3a3NVcmwsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgcmVmcmVzaCBKV0tTIGtleXMgKGZvciBrZXkgcm90YXRpb24pXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlZnJlc2hKd2tzS2V5cyhqd2tzVXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmZldGNoRnJlc2hKd2tzS2V5cyhqd2tzVXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayByYXRlIGxpbWl0aW5nIGZvciBKV0tTIGVuZHBvaW50XG4gICAqL1xuICBwcml2YXRlIGNoZWNrUmF0ZUxpbWl0KGp3a3NVcmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmF0ZUxpbWl0ID0gdGhpcy5yYXRlTGltaXRzLmdldChqd2tzVXJsKSB8fCB7IGNvdW50OiAwLCB3aW5kb3dTdGFydDogbm93IH07XG5cbiAgICAvLyBSZXNldCB3aW5kb3cgaWYgZXhwaXJlZFxuICAgIGlmIChub3cgLSByYXRlTGltaXQud2luZG93U3RhcnQgPiB0aGlzLlJBVEVfTElNSVRfV0lORE9XKSB7XG4gICAgICByYXRlTGltaXQuY291bnQgPSAwO1xuICAgICAgcmF0ZUxpbWl0LndpbmRvd1N0YXJ0ID0gbm93O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGxpbWl0IGV4Y2VlZGVkXG4gICAgaWYgKHJhdGVMaW1pdC5jb3VudCA+PSB0aGlzLlJBVEVfTElNSVRfTUFYX1JFUVVFU1RTKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSW5jcmVtZW50IGNvdW50XG4gICAgcmF0ZUxpbWl0LmNvdW50Kys7XG4gICAgdGhpcy5yYXRlTGltaXRzLnNldChqd2tzVXJsLCByYXRlTGltaXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjaXJjdWl0IGJyZWFrZXIgc3RhdGUgZm9yIGVuZHBvaW50XG4gICAqL1xuICBwcml2YXRlIGdldENpcmN1aXRCcmVha2VyU3RhdGUoandrc1VybDogc3RyaW5nKTogQ2lyY3VpdEJyZWFrZXJTdGF0ZSB7XG4gICAgaWYgKCF0aGlzLmNpcmN1aXRCcmVha2Vycy5oYXMoandrc1VybCkpIHtcbiAgICAgIHRoaXMuY2lyY3VpdEJyZWFrZXJzLnNldChqd2tzVXJsLCB7XG4gICAgICAgIHN0YXRlOiBcIkNMT1NFRFwiLFxuICAgICAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgIGxhc3RGYWlsdXJlVGltZTogMCxcbiAgICAgICAgbmV4dEF0dGVtcHRUaW1lOiAwLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNpcmN1aXRCcmVha2Vycy5nZXQoandrc1VybCkhO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSldLUyBrZXkgdG8gcHJvcGVyIGZvcm1hdCBmb3IgdmVyaWZpY2F0aW9uIHVzaW5nIE5vZGUuanMgY3J5cHRvXG4gICAqL1xuICBwcml2YXRlIGp3a3NLZXlUb1BlbShqd2tzS2V5OiBKd3RLZXkpOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgUlNBIHB1YmxpYyBrZXkgZnJvbSBKV0tTIGNvbXBvbmVudHMgdXNpbmcgTm9kZS5qcyBjcnlwdG9cbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyZWF0ZVB1YmxpY0tleSh7XG4gICAgICAgIGtleToge1xuICAgICAgICAgIGt0eTogandrc0tleS5rdHksXG4gICAgICAgICAgbjogandrc0tleS5uLFxuICAgICAgICAgIGU6IGp3a3NLZXkuZSxcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBcImp3a1wiLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4cG9ydCBhcyBQRU0gZm9ybWF0XG4gICAgICByZXR1cm4gcHVibGljS2V5LmV4cG9ydCh7IHR5cGU6IFwic3BraVwiLCBmb3JtYXQ6IFwicGVtXCIgfSkgYXMgc3RyaW5nO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb252ZXJ0IEpXS1Mga2V5IHRvIFBFTTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzdGF0aXN0aWNzIGZvciBtb25pdG9yaW5nXG4gICAqL1xuICBnZXRDYWNoZVN0YXRzKCk6IFJlY29yZDxzdHJpbmcsIENhY2hlU3RhdHM+IHtcbiAgICBjb25zdCBzdGF0czogUmVjb3JkPHN0cmluZywgQ2FjaGVTdGF0cz4gPSB7fTtcblxuICAgIGZvciAoY29uc3QgW3VybCwgY2FjaGVkXSBvZiB0aGlzLmtleUNhY2hlLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgY2lyY3VpdFN0YXRlID0gdGhpcy5jaXJjdWl0QnJlYWtlcnMuZ2V0KHVybCk7XG4gICAgICBjb25zdCByYXRlTGltaXQgPSB0aGlzLnJhdGVMaW1pdHMuZ2V0KHVybCk7XG5cbiAgICAgIHN0YXRzW3VybF0gPSB7XG4gICAgICAgIGtleUNvdW50OiBjYWNoZWQua2V5cy5sZW5ndGgsXG4gICAgICAgIGxhc3RGZXRjaDogbmV3IERhdGUoY2FjaGVkLmxhc3RGZXRjaCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZXhwaXJ5OiBuZXcgRGF0ZShjYWNoZWQuZXhwaXJ5KS50b0lTT1N0cmluZygpLFxuICAgICAgICBleHBpcmVkOiBEYXRlLm5vdygpID4gY2FjaGVkLmV4cGlyeSxcbiAgICAgICAgZmFpbHVyZUNvdW50OiBjYWNoZWQuZmFpbHVyZUNvdW50LFxuICAgICAgICBjaXJjdWl0QnJlYWtlclN0YXRlOiBjaXJjdWl0U3RhdGU/LnN0YXRlIHx8IFwiVU5LTk9XTlwiLFxuICAgICAgICByYXRlTGltaXRDb3VudDogcmF0ZUxpbWl0Py5jb3VudCB8fCAwLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBNY3BTZXJ2ZXIgfSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJ3aW5zdG9uXCI7XG5pbXBvcnQgeyBBUFBfSU5TVUZGSUNJRU5UX1BFUk1JU1NJT05TLCBBUFBfSU5WQUxJRF9TRVJWRVIgfSBmcm9tIFwiLi4vdHlwZXMvZXJyb3IudHlwZXMuanNcIjtcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSBcIi4uL3V0aWxzL2Nvbm5lY3Rpb24uanNcIjtcbmltcG9ydCB7IENhY2hlSXRlbVR5cGUsIGNhY2hlR2V0T3JBZGQgfSBmcm9tIFwiLi9jYWNoZS5zZXJ2aWNlLmpzXCI7XG5cbmludGVyZmFjZSBTZXJ2ZXJBY2Nlc3NSZXN1bHQge1xuICB1c2VyTm90Rm91bmQ/OiBib29sZWFuO1xuICBlcnJvcj86IHtcbiAgICBjb2RlOiBudW1iZXI7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVTZXJ2ZXJBY2Nlc3MoXG4gIGRiOiBEYXRhYmFzZSxcbiAgbG9nZ2VyOiBMb2dnZXIsXG4gIHNlcnZlcklkOiBzdHJpbmcsXG4gIHVzZXJFbWFpbDogc3RyaW5nLFxuKTogUHJvbWlzZTxTZXJ2ZXJBY2Nlc3NSZXN1bHQ+IHtcbiAgbG9nZ2VyLmRlYnVnKGBWYWxpZGF0aW5nIHNlcnZlciBhY2Nlc3MgZm9yIHVzZXIgJHt1c2VyRW1haWx9IGFuZCBzZXJ2ZXIgJHtzZXJ2ZXJJZH1gKTtcblxuICByZXR1cm4gYXdhaXQgY2FjaGVHZXRPckFkZDxTZXJ2ZXJBY2Nlc3NSZXN1bHQ+KFxuICAgIHsgdHlwZTogQ2FjaGVJdGVtVHlwZS5TRVJWRVJfQUNDRVNTLCBpZHM6IFtzZXJ2ZXJJZCwgdXNlckVtYWlsXSB9LFxuICAgIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IGNhY2hlR2V0T3JBZGQ8TWNwU2VydmVyIHwgbnVsbD4oXG4gICAgICAgIHsgdHlwZTogQ2FjaGVJdGVtVHlwZS5TRVJWRVIsIGlkczogW3NlcnZlcklkXSB9LFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGRiLm1jcFNlcnZlci5maW5kRmlyc3Qoe1xuICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgaWQ6IHNlcnZlcklkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICk7XG5cbiAgICAgIGlmICghc2VydmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IEFQUF9JTlZBTElEX1NFUlZFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBTZXJ2ZXIgbm90IGZvdW5kOiAke3NlcnZlcklkfWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZXJ2ZXIuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBjb2RlOiBBUFBfSU5WQUxJRF9TRVJWRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBgU2VydmVyIGlzIG5vdCBlbmFibGVkOiAke3NlcnZlcklkfWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLmRlYnVnKGBMb29raW5nIGZvciB1c2VyIHdpdGggZW1haWw6ICR7dXNlckVtYWlsfSBhbmQgdGVuYW50SWQ6ICR7c2VydmVyLnRlbmFudElkfWApO1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiLmVuZFVzZXIuZmluZEZpcnN0KHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBlbWFpbDogdXNlckVtYWlsLFxuICAgICAgICAgIHRlbmFudElkOiBzZXJ2ZXIudGVuYW50SWQsXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICByZXR1cm4geyB1c2VyTm90Rm91bmQ6IHRydWUgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF1c2VyLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgY29kZTogQVBQX0lOU1VGRklDSUVOVF9QRVJNSVNTSU9OUyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBVc2VyICR7dXNlckVtYWlsfSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBzZXJ2ZXI6ICR7c2VydmVySWR9YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgKTtcbn1cbiIsICJpbXBvcnQgeyBTZXJ2ZXJBdXRoVHlwZSB9IGZyb20gXCJAYWdlbnRicmlkZ2UvYXBpXCI7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IGlzQXBwUmVxdWVzdCB9IGZyb20gXCIuLi8uLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5pbXBvcnQge1xuICBBdXRoUHJvdmlkZXIsXG4gIENyZWF0ZVByb3ZpZGVyUmVxdWVzdCxcbiAgSVNlcnZlckF1dGhTdHJhdGVneSxcbiAgU2VydmVyQXV0aENvbmZpZyxcbiAgU2VydmVyQXV0aFJlc3VsdCxcbiAgVXBkYXRlUHJvdmlkZXJSZXF1ZXN0LFxuICBWYWxpZGF0aW9uUmVzdWx0LFxufSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9hdXRoLXN0cmF0ZWd5LmludGVyZmFjZS5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVTZXJ2ZXJBY2Nlc3MgfSBmcm9tIFwiLi4vbWNwLWFjY2Vzcy5zZXJ2aWNlLmpzXCI7XG5cbi8qKlxuICogQmFzZUF1dGhTdHJhdGVneSBpbXBsZW1lbnRzIHRoZSBleGlzdGluZyBBZ2VudEJyaWRnZSBhdXRoZW50aWNhdGlvbiBsb2dpY1xuICogVGhpcyB3cmFwcyB0aGUgY3VycmVudCB1c2VyL3RlbmFudCB2YWxpZGF0aW9uIHRoYXQgd2FzIGFscmVhZHkgaW4gcGxhY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VBdXRoU3RyYXRlZ3kgaW1wbGVtZW50cyBJU2VydmVyQXV0aFN0cmF0ZWd5IHtcbiAgYXN5bmMgYXV0aGVudGljYXRlKHJlcTogUmVxdWVzdCwgY29uZmlnOiBTZXJ2ZXJBdXRoQ29uZmlnKTogUHJvbWlzZTxTZXJ2ZXJBdXRoUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIHByb3BlciByZXF1ZXN0IGNvbnRleHRcbiAgICAgIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIHJlcXVlc3QgY29udGV4dCBmb3IgYXV0aGVudGljYXRpb25cIixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCBhbmQgdmVyaWZ5IHVzZXIgdG9rZW4gZnJvbSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcS5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aChcIkJlYXJlciBcIikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogXCJObyBhdXRob3JpemF0aW9uIGhlYWRlciBwcm92aWRlZCBmb3IgQkFTRSBhdXRoZW50aWNhdGlvblwiLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbiA9IGF1dGhIZWFkZXIuc3BsaXQoXCIgXCIpWzFdO1xuXG4gICAgICAvLyBJbXBvcnQgSldUIHNlcnZpY2UgZm9yIHRva2VuIHZlcmlmaWNhdGlvblxuICAgICAgY29uc3QgeyB2ZXJpZnlFbmRVc2VyVG9rZW4gfSA9IGF3YWl0IGltcG9ydChcIi4uL2p3dC5zZXJ2aWNlLmpzXCIpO1xuXG4gICAgICAvLyBWZXJpZnkgdGhlIHVzZXIgdG9rZW5cbiAgICAgIGNvbnN0IGRlY29kZWQgPSBhd2FpdCB2ZXJpZnlFbmRVc2VyVG9rZW4odG9rZW4pO1xuICAgICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiSW52YWxpZCBvciBleHBpcmVkIHVzZXIgdG9rZW5cIixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlckVtYWlsID0gZGVjb2RlZC5lbWFpbDtcbiAgICAgIGlmICghdXNlckVtYWlsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiTm8gdXNlciBlbWFpbCBmb3VuZCBpbiB0b2tlblwiLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgZXhpc3RpbmcgQWdlbnRCcmlkZ2UgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgY29uc3QgYWNjZXNzUmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVTZXJ2ZXJBY2Nlc3MocmVxLmRiLCByZXEubG9nZ2VyLCBjb25maWcuc2VydmVySWQsIHVzZXJFbWFpbCk7XG5cbiAgICAgIC8vIEhhbmRsZSB2YWxpZGF0aW9uIHJlc3VsdHNcbiAgICAgIGlmIChhY2Nlc3NSZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogYWNjZXNzUmVzdWx0LmVycm9yLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChhY2Nlc3NSZXN1bHQudXNlck5vdEZvdW5kKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGBVc2VyICR7dXNlckVtYWlsfSBub3QgZm91bmQgb3IgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gc2VydmVyYCxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gU3VjY2VzcyAtIGdldCB1c2VyIGFuZCB0ZW5hbnQgaW5mbyBmb3IgY29udGV4dFxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHJlcS5kYi5lbmRVc2VyLmZpbmRGaXJzdCh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgZW1haWw6IHVzZXJFbWFpbCxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgdGVuYW50SWQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdXNlckNvbnRleHQ6IHtcbiAgICAgICAgICB1c2VySWQ6IHVzZXI/LmlkLFxuICAgICAgICAgIHRlbmFudElkOiB1c2VyPy50ZW5hbnRJZCxcbiAgICAgICAgICBhdXRoVHlwZTogU2VydmVyQXV0aFR5cGUuQkFTRSxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB2YWxpZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogYEJhc2UgYXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlnOiBTZXJ2ZXJBdXRoQ29uZmlnKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PiB7XG4gICAgLy8gQkFTRSBhdXRoZW50aWNhdGlvbiBkb2Vzbid0IHJlcXVpcmUgYW55IHNwZWNpYWwgY29uZmlndXJhdGlvblxuICAgIC8vIEl0IHVzZXMgdGhlIGV4aXN0aW5nIEFnZW50QnJpZGdlIHVzZXIvdGVuYW50IHZhbGlkYXRpb25cbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHJvdmlkZXJzIGZvciBCQVNFIGF1dGggKHJldHVybnMgZW1wdHkgYXJyYXkgYXMgQkFTRSBhdXRoIGRvZXNuJ3QgdXNlIHByb3ZpZGVycylcbiAgICovXG4gIGFzeW5jIGdldFByb3ZpZGVycyhzZXJ2ZXJJZDogc3RyaW5nKTogUHJvbWlzZTxBdXRoUHJvdmlkZXJbXT4ge1xuICAgIC8vIEJBU0UgYXV0aGVudGljYXRpb24gZG9lc24ndCB1c2UgcHJvdmlkZXJzXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBwcm92aWRlciBmb3IgQkFTRSBhdXRoIChub3QgYXBwbGljYWJsZSlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVByb3ZpZGVyKHNlcnZlcklkOiBzdHJpbmcsIHByb3ZpZGVyRGF0YTogQ3JlYXRlUHJvdmlkZXJSZXF1ZXN0KTogUHJvbWlzZTxBdXRoUHJvdmlkZXI+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCQVNFIGF1dGhlbnRpY2F0aW9uIGRvZXMgbm90IHN1cHBvcnQgcHJvdmlkZXJzXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwcm92aWRlciBmb3IgQkFTRSBhdXRoIChub3QgYXBwbGljYWJsZSlcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVByb3ZpZGVyKFxuICAgIHNlcnZlcklkOiBzdHJpbmcsXG4gICAgcHJvdmlkZXJJZDogc3RyaW5nLFxuICAgIHByb3ZpZGVyRGF0YTogVXBkYXRlUHJvdmlkZXJSZXF1ZXN0LFxuICApOiBQcm9taXNlPEF1dGhQcm92aWRlcj4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJBU0UgYXV0aGVudGljYXRpb24gZG9lcyBub3Qgc3VwcG9ydCBwcm92aWRlcnNcIik7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIHByb3ZpZGVyIGZvciBCQVNFIGF1dGggKG5vdCBhcHBsaWNhYmxlKVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUHJvdmlkZXIoc2VydmVySWQ6IHN0cmluZywgcHJvdmlkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQkFTRSBhdXRoZW50aWNhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IHByb3ZpZGVyc1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgQkFTRSBjb25maWd1cmF0aW9uIHVwZGF0ZSAobm8gc3BlY2lhbCBjb25maWcgbmVlZGVkKVxuICAgKi9cbiAgYXN5bmMgaGFuZGxlQ29uZmlnVXBkYXRlKFxuICAgIHNlcnZlcklkOiBzdHJpbmcsXG4gICAgY29uZmlnOiB7IGF1dGhUeXBlOiBTZXJ2ZXJBdXRoVHlwZTsgand0UHJvdmlkZXJJZD86IHN0cmluZyB9LFxuICApOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAvLyBCQVNFIGF1dGhlbnRpY2F0aW9uIGRvZXNuJ3QgcmVxdWlyZSBhdXRoIGNvbmZpZ1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgU2VydmVyQXV0aFR5cGUgfSBmcm9tIFwiQGFnZW50YnJpZGdlL2FwaVwiO1xuaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJ3aW5zdG9uXCI7XG5pbXBvcnQge1xuICBDcmVhdGVKd3RQcm92aWRlclJlcXVlc3QsXG4gIElTZXJ2ZXJBdXRoU3RyYXRlZ3ksXG4gIEp3dFByb3ZpZGVyLFxuICBTZXJ2ZXJBdXRoQ29uZmlnLFxuICBTZXJ2ZXJBdXRoUmVzdWx0LFxuICBVcGRhdGVKd3RQcm92aWRlclJlcXVlc3QsXG4gIFZhbGlkYXRpb25SZXN1bHQsXG59IGZyb20gXCIuLi9pbnRlcmZhY2VzL2F1dGgtc3RyYXRlZ3kuaW50ZXJmYWNlLmpzXCI7XG5pbXBvcnQgeyBKd3RBdXRoU2VydmljZSB9IGZyb20gXCIuLi9qd3QtYXV0aC5zZXJ2aWNlLmpzXCI7XG5cbi8qKlxuICogSnd0QXV0aFN0cmF0ZWd5IGltcGxlbWVudHMgSldUIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gdXNpbmcgSldUIGVuZHBvaW50c1xuICogVGhpcyB2YWxpZGF0ZXMgSldUIHRva2VucyB1c2luZyB0aGUgY29uZmlndXJlZCBKV1QgcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEp3dEF1dGhTdHJhdGVneSBpbXBsZW1lbnRzIElTZXJ2ZXJBdXRoU3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGp3dFNlcnZpY2U6IEp3dEF1dGhTZXJ2aWNlLFxuICAgIHByaXZhdGUgZGI6IFByaXNtYUNsaWVudCxcbiAgICBwcml2YXRlIGxvZ2dlcj86IExvZ2dlcixcbiAgKSB7fVxuXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZShyZXE6IFJlcXVlc3QsIGNvbmZpZzogU2VydmVyQXV0aENvbmZpZyk6IFByb21pc2U8U2VydmVyQXV0aFJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGF0ZSBjb25maWd1cmF0aW9uXG4gICAgICBpZiAoIWNvbmZpZy5qd3RQcm92aWRlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBcIkpXVCBwcm92aWRlciBub3QgY29uZmlndXJlZCBmb3IgdGhpcyBzZXJ2ZXJcIixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25maWcuand0UHJvdmlkZXIuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBcIkpXVCBwcm92aWRlciBpcyBkaXNhYmxlZFwiLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IEpXVCB0b2tlbiBmcm9tIHJlcXVlc3RcbiAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5leHRyYWN0Snd0VG9rZW4ocmVxKTtcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogXCJObyBKV1QgdG9rZW4gZm91bmQgaW4gcmVxdWVzdC4gRXhwZWN0ZWQgQXV0aG9yaXphdGlvbiBoZWFkZXIgd2l0aCBCZWFyZXIgdG9rZW4uXCIsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIEpXVCBzaWduYXR1cmUgdXNpbmcgSldLU1xuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuand0U2VydmljZS52YWxpZGF0ZUp3dFNpZ25hdHVyZSh0b2tlbiwgY29uZmlnLmp3dFByb3ZpZGVyLmp3a3NVcmwpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogdmFsaWRhdGlvblJlc3VsdC5lcnJvciB8fCBcIkpXVCBzaWduYXR1cmUgdmFsaWRhdGlvbiBmYWlsZWRcIixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCB1c2VyIGluZm9ybWF0aW9uIGZyb20gdmFsaWRhdGVkIEpXVCB0b2tlblxuICAgICAgbGV0IHVzZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgbGV0IHRlbmFudElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnBheWxvYWQgJiYgdHlwZW9mIHZhbGlkYXRpb25SZXN1bHQucGF5bG9hZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdmFsaWRhdGlvblJlc3VsdC5wYXlsb2FkIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICB1c2VySWQgPSAocGF5bG9hZC5pZCBhcyBzdHJpbmcpIHx8IChwYXlsb2FkLnN1YiBhcyBzdHJpbmcpO1xuICAgICAgICB0ZW5hbnRJZCA9IHBheWxvYWQudGVuYW50SWQgYXMgc3RyaW5nO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkpXVCBhdXRoZW50aWNhdGlvbiBleHRyYWN0ZWQgdXNlciBjb250ZXh0XCIsIHtcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgcHJvdmlkZXJJZDogY29uZmlnLmp3dFByb3ZpZGVyLmlkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3VjY2VzczogcmV0dXJuIGF1dGggcmVzdWx0IHdpdGggSldUIGNvbnRleHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHVzZXJDb250ZXh0OiB7XG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIHRlbmFudElkLFxuICAgICAgICAgIGF1dGhUeXBlOiBTZXJ2ZXJBdXRoVHlwZS5KV1QsXG4gICAgICAgICAgb3JpZ2luYWxUb2tlbjogdG9rZW4sXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgcHJvdmlkZXJJZDogY29uZmlnLmp3dFByb3ZpZGVyLmlkLFxuICAgICAgICAgIHZhbGlkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiSldUIGF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiLCB7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBKV1QgYXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlnOiBTZXJ2ZXJBdXRoQ29uZmlnKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgaWYgSldUIHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWRcbiAgICBpZiAoIWNvbmZpZy5qd3RQcm92aWRlcikge1xuICAgICAgZXJyb3JzLnB1c2goXCJKV1QgcHJvdmlkZXIgaXMgcmVxdWlyZWQgZm9yIEpXVCBhdXRoZW50aWNhdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVmFsaWRhdGUgSldUIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgIGlmICghY29uZmlnLmp3dFByb3ZpZGVyLmp3a3NVcmwpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goXCJKV0tTIFVSTCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIFVSTCBmb3JtYXRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgVVJMKGNvbmZpZy5qd3RQcm92aWRlci5qd2tzVXJsKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goXCJJbnZhbGlkIEpXS1MgVVJMIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmZpZy5qd3RQcm92aWRlci5lbmFibGVkKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFwiSldUIHByb3ZpZGVyIGlzIGRpc2FibGVkXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IEpXS1MgZW5kcG9pbnQgYWNjZXNzaWJpbGl0eSAob3B0aW9uYWwgdmFsaWRhdGlvbilcbiAgICAgIGlmIChjb25maWcuand0UHJvdmlkZXIuandrc1VybCAmJiBjb25maWcuand0UHJvdmlkZXIuZW5hYmxlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuand0U2VydmljZS5mZXRjaEp3a3NLZXlzKGNvbmZpZy5qd3RQcm92aWRlci5qd2tzVXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYEpXS1MgZW5kcG9pbnQgdGVzdCBmYWlsZWQ6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycyA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBKV1QgcHJvdmlkZXJzIGZvciBhIHNlcnZlclxuICAgKi9cbiAgYXN5bmMgZ2V0UHJvdmlkZXJzKHNlcnZlcklkOiBzdHJpbmcpOiBQcm9taXNlPEp3dFByb3ZpZGVyW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXJzID0gYXdhaXQgdGhpcy5kYi5zZXJ2ZXJKd3RQcm92aWRlci5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlOiB7IHNlcnZlcklkIH0sXG4gICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvdmlkZXJzIGFzIEp3dFByb3ZpZGVyW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byBnZXQgSldUIHByb3ZpZGVyc1wiLCB7IHNlcnZlcklkLCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgSldUIHByb3ZpZGVyIGZvciBhIHNlcnZlclxuICAgKi9cbiAgYXN5bmMgY3JlYXRlUHJvdmlkZXIoc2VydmVySWQ6IHN0cmluZywgcHJvdmlkZXJEYXRhOiBDcmVhdGVKd3RQcm92aWRlclJlcXVlc3QpOiBQcm9taXNlPEp3dFByb3ZpZGVyPiB7XG4gICAgY29uc3QgeyBuYW1lLCBqd2tzVXJsLCBlbmFibGVkID0gdHJ1ZSB9ID0gcHJvdmlkZXJEYXRhO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBzZXJ2ZXIgdG8gZXh0cmFjdCB0ZW5hbnRJZFxuICAgICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5kYi5tY3BTZXJ2ZXIuZmluZFVuaXF1ZSh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiBzZXJ2ZXJJZCB9LFxuICAgICAgICBzZWxlY3Q6IHsgdGVuYW50SWQ6IHRydWUgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXNlcnZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciAke3NlcnZlcklkfSBub3QgZm91bmRgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmRiLnNlcnZlckp3dFByb3ZpZGVyLmNyZWF0ZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgICB0ZW5hbnRJZDogc2VydmVyLnRlbmFudElkLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgandrc1VybCxcbiAgICAgICAgICBlbmFibGVkLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm92aWRlciBhcyBKd3RQcm92aWRlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBKV1QgcHJvdmlkZXJcIiwgeyBzZXJ2ZXJJZCwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIEpXVCBwcm92aWRlciBmb3IgYSBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVByb3ZpZGVyKFxuICAgIHNlcnZlcklkOiBzdHJpbmcsXG4gICAgcHJvdmlkZXJJZDogc3RyaW5nLFxuICAgIHByb3ZpZGVyRGF0YTogVXBkYXRlSnd0UHJvdmlkZXJSZXF1ZXN0LFxuICApOiBQcm9taXNlPEp3dFByb3ZpZGVyPiB7XG4gICAgY29uc3QgeyBuYW1lLCBqd2tzVXJsLCBlbmFibGVkIH0gPSBwcm92aWRlckRhdGE7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmRiLnNlcnZlckp3dFByb3ZpZGVyLnVwZGF0ZSh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgaWQ6IHByb3ZpZGVySWQsXG4gICAgICAgICAgc2VydmVySWQsIC8vIEVuc3VyZSBwcm92aWRlciBiZWxvbmdzIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLihuYW1lICE9PSB1bmRlZmluZWQgJiYgeyBuYW1lIH0pLFxuICAgICAgICAgIC4uLihqd2tzVXJsICE9PSB1bmRlZmluZWQgJiYgeyBqd2tzVXJsIH0pLFxuICAgICAgICAgIC4uLihlbmFibGVkICE9PSB1bmRlZmluZWQgJiYgeyBlbmFibGVkIH0pLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm92aWRlciBhcyBKd3RQcm92aWRlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBKV1QgcHJvdmlkZXJcIiwgeyBzZXJ2ZXJJZCwgcHJvdmlkZXJJZCwgZXJyb3IgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIEpXVCBwcm92aWRlciBmb3IgYSBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIGRlbGV0ZVByb3ZpZGVyKHNlcnZlcklkOiBzdHJpbmcsIHByb3ZpZGVySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmRiLnNlcnZlckp3dFByb3ZpZGVyLmRlbGV0ZSh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgaWQ6IHByb3ZpZGVySWQsXG4gICAgICAgICAgc2VydmVySWQsIC8vIEVuc3VyZSBwcm92aWRlciBiZWxvbmdzIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmxvZ2dlcj8uZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIEpXVCBwcm92aWRlclwiLCB7IHNlcnZlcklkLCBwcm92aWRlcklkLCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgSldUIGNvbmZpZ3VyYXRpb24gdXBkYXRlXG4gICAqL1xuICBhc3luYyBoYW5kbGVDb25maWdVcGRhdGUoXG4gICAgc2VydmVySWQ6IHN0cmluZyxcbiAgICBjb25maWc6IHsgYXV0aFR5cGU6IFNlcnZlckF1dGhUeXBlOyBqd3RQcm92aWRlcklkPzogc3RyaW5nIH0sXG4gICk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGlmICghY29uZmlnLmp3dFByb3ZpZGVySWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBleGlzdGluZ0F1dGhDb25maWcgPSBhd2FpdCB0aGlzLmRiLnNlcnZlckF1dGhDb25maWcuZmluZFVuaXF1ZSh7XG4gICAgICAgIHdoZXJlOiB7IHNlcnZlcklkIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKGV4aXN0aW5nQXV0aENvbmZpZykge1xuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgYXV0aCBjb25maWdcbiAgICAgICAgYXdhaXQgdGhpcy5kYi5zZXJ2ZXJBdXRoQ29uZmlnLnVwZGF0ZSh7XG4gICAgICAgICAgd2hlcmU6IHsgaWQ6IGV4aXN0aW5nQXV0aENvbmZpZy5pZCB9LFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGF1dGhUeXBlOiBjb25maWcuYXV0aFR5cGUsXG4gICAgICAgICAgICBqd3RQcm92aWRlcklkOiBjb25maWcuand0UHJvdmlkZXJJZCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXV0aENvbmZpZy5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgYXV0aCBjb25maWdcbiAgICAgICAgY29uc3QgbmV3QXV0aENvbmZpZyA9IGF3YWl0IHRoaXMuZGIuc2VydmVyQXV0aENvbmZpZy5jcmVhdGUoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHNlcnZlcklkLFxuICAgICAgICAgICAgYXV0aFR5cGU6IGNvbmZpZy5hdXRoVHlwZSxcbiAgICAgICAgICAgIGp3dFByb3ZpZGVySWQ6IGNvbmZpZy5qd3RQcm92aWRlcklkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3QXV0aENvbmZpZy5pZDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIGhhbmRsZSBKV1QgY29uZmlnIHVwZGF0ZVwiLCB7IHNlcnZlcklkLCBlcnJvciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IEpXVCB0b2tlbiBmcm9tIHZhcmlvdXMgcmVxdWVzdCBsb2NhdGlvbnNcbiAgICogU3VwcG9ydHM6IEF1dGhvcml6YXRpb24gaGVhZGVyIChCZWFyZXIpLCBxdWVyeSBwYXJhbWV0ZXIsIGN1c3RvbSBoZWFkZXJzXG4gICAqL1xuICBwcml2YXRlIGV4dHJhY3RKd3RUb2tlbihyZXE6IFJlcXVlc3QpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAvLyAxLiBDaGVjayBBdXRob3JpemF0aW9uIGhlYWRlciAoQmVhcmVyIHRva2VuKVxuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSByZXEuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgIGlmIChhdXRoSGVhZGVyICYmIGF1dGhIZWFkZXIuc3RhcnRzV2l0aChcIkJlYXJlciBcIikpIHtcbiAgICAgIHJldHVybiBhdXRoSGVhZGVyLnN1YnN0cmluZyg3KTsgLy8gUmVtb3ZlIFwiQmVhcmVyIFwiIHByZWZpeFxuICAgIH1cblxuICAgIC8vIDIuIENoZWNrIGZvciB0b2tlbiBpbiBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgY29uc3QgcXVlcnlUb2tlbiA9IHJlcS5xdWVyeS50b2tlbjtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5VG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBxdWVyeVRva2VuO1xuICAgIH1cblxuICAgIC8vIDMuIENoZWNrIGN1c3RvbSBoZWFkZXIgKHgtYXV0aC10b2tlbilcbiAgICBjb25zdCBjdXN0b21IZWFkZXIgPSByZXEuaGVhZGVyc1tcIngtYXV0aC10b2tlblwiXTtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUhlYWRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGN1c3RvbUhlYWRlcjtcbiAgICB9XG5cbiAgICAvLyA0LiBDaGVjayBib2R5IGZvciB0b2tlbiAoZm9yIFBPU1QgcmVxdWVzdHMpXG4gICAgY29uc3QgYm9keVRva2VuID0gcmVxLmJvZHk/LnRva2VuO1xuICAgIGlmICh0eXBlb2YgYm9keVRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gYm9keVRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgU2VydmVyQXV0aFR5cGUgfSBmcm9tIFwiQGFnZW50YnJpZGdlL2FwaVwiO1xuaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwid2luc3RvblwiO1xuaW1wb3J0IHsgSVNlcnZlckF1dGhTdHJhdGVneSB9IGZyb20gXCIuLi9pbnRlcmZhY2VzL2F1dGgtc3RyYXRlZ3kuaW50ZXJmYWNlLmpzXCI7XG5pbXBvcnQgeyBKd3RBdXRoU2VydmljZSB9IGZyb20gXCIuLi9qd3QtYXV0aC5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBCYXNlQXV0aFN0cmF0ZWd5IH0gZnJvbSBcIi4uL3N0cmF0ZWdpZXMvYmFzZS1hdXRoLnN0cmF0ZWd5LmpzXCI7XG5pbXBvcnQgeyBKd3RBdXRoU3RyYXRlZ3kgfSBmcm9tIFwiLi4vc3RyYXRlZ2llcy9qd3QtYXV0aC5zdHJhdGVneS5qc1wiO1xuXG4vKipcbiAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWdpZXMgYmFzZWQgb24gc2VydmVyIGNvbmZpZ3VyYXRpb25cbiAqIEltcGxlbWVudHMgc3RyYXRlZ3kgcGF0dGVybiB0byBhdm9pZCBoYXJkY29kZWQgaWYvZWxzZSBhdXRoZW50aWNhdGlvbiBsb2dpY1xuICovXG5leHBvcnQgY2xhc3MgQXV0aFN0cmF0ZWd5RmFjdG9yeSB7XG4gIHByaXZhdGUgc3RyYXRlZ2llczogTWFwPFNlcnZlckF1dGhUeXBlLCBJU2VydmVyQXV0aFN0cmF0ZWd5PiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3RvcihkYjogUHJpc21hQ2xpZW50LCBsb2dnZXI/OiBMb2dnZXIpIHtcbiAgICAvLyBJbml0aWFsaXplIGF2YWlsYWJsZSBzdHJhdGVnaWVzXG4gICAgdGhpcy5zdHJhdGVnaWVzLnNldChTZXJ2ZXJBdXRoVHlwZS5CQVNFLCBuZXcgQmFzZUF1dGhTdHJhdGVneSgpKTtcbiAgICB0aGlzLnN0cmF0ZWdpZXMuc2V0KFNlcnZlckF1dGhUeXBlLkpXVCwgbmV3IEp3dEF1dGhTdHJhdGVneShuZXcgSnd0QXV0aFNlcnZpY2UobG9nZ2VyKSwgZGIsIGxvZ2dlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhdXRoZW50aWNhdGlvbiBzdHJhdGVneSBmb3IgdGhlIGdpdmVuIGF1dGggdHlwZVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGF1dGggdHlwZSBpcyBub3Qgc3VwcG9ydGVkXG4gICAqL1xuICBnZXRTdHJhdGVneShhdXRoVHlwZTogU2VydmVyQXV0aFR5cGUpOiBJU2VydmVyQXV0aFN0cmF0ZWd5IHtcbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ2llcy5nZXQoYXV0aFR5cGUpO1xuICAgIGlmICghc3RyYXRlZ3kpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYXV0aGVudGljYXRpb24gc3RyYXRlZ3k6ICR7YXV0aFR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJhdGVneTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdXRoIHR5cGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBpc1N1cHBvcnRlZChhdXRoVHlwZTogU2VydmVyQXV0aFR5cGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdHJhdGVnaWVzLmhhcyhhdXRoVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBzdXBwb3J0ZWQgYXV0aCB0eXBlc1xuICAgKi9cbiAgZ2V0U3VwcG9ydGVkQXV0aFR5cGVzKCk6IFNlcnZlckF1dGhUeXBlW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3RyYXRlZ2llcy5rZXlzKCkpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgUGFyYW1ldGVyTG9jYXRpb24sIFNlcnZlckF1dGhUeXBlLCBVcGRhdGVTZXJ2ZXJBdXRoQ29uZmlnUmVxdWVzdCB9IGZyb20gXCJAYWdlbnRicmlkZ2UvYXBpXCI7XG5pbXBvcnQgeyBQcmlzbWFDbGllbnQgfSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcbmltcG9ydCB7IFJlcXVlc3QgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIndpbnN0b25cIjtcbmltcG9ydCB7IEF1dGhTdHJhdGVneUZhY3RvcnkgfSBmcm9tIFwiLi9mYWN0b3JpZXMvYXV0aC1zdHJhdGVneS5mYWN0b3J5LmpzXCI7XG5pbXBvcnQge1xuICBBdXRoUHJvdmlkZXIsXG4gIENyZWF0ZVByb3ZpZGVyUmVxdWVzdCxcbiAgU2VydmVyQXV0aENvbmZpZyxcbiAgU2VydmVyQXV0aFJlc3VsdCxcbiAgVXBkYXRlUHJvdmlkZXJSZXF1ZXN0LFxufSBmcm9tIFwiLi9pbnRlcmZhY2VzL2F1dGgtc3RyYXRlZ3kuaW50ZXJmYWNlLmpzXCI7XG5cbmludGVyZmFjZSBKd3RLZXkge1xuICBrdHk6IHN0cmluZztcbiAgdXNlPzogc3RyaW5nO1xuICBhbGc/OiBzdHJpbmc7XG4gIGtpZD86IHN0cmluZztcbiAgbj86IHN0cmluZztcbiAgZT86IHN0cmluZztcbiAgeD86IHN0cmluZztcbiAgeT86IHN0cmluZztcbiAgY3J2Pzogc3RyaW5nO1xuICBrPzogc3RyaW5nO1xuICBkPzogc3RyaW5nO1xuICBwPzogc3RyaW5nO1xuICBxPzogc3RyaW5nO1xuICBkcD86IHN0cmluZztcbiAgZHE/OiBzdHJpbmc7XG4gIHFpPzogc3RyaW5nO1xuICB4NWM/OiBzdHJpbmdbXTtcbiAgeDV0Pzogc3RyaW5nO1xuICBcIng1dCNTMjU2XCI/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBKd3RSZXNwb25zZSB7XG4gIGtleXM6IEp3dEtleVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlckF1dGhDb25maWdSZXNwb25zZSB7XG4gIHNlcnZlcklkOiBzdHJpbmc7XG4gIGF1dGhUeXBlOiBTZXJ2ZXJBdXRoVHlwZTtcbiAgYXV0aENvbmZpZz86IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGF1dGhUeXBlOiBTZXJ2ZXJBdXRoVHlwZTtcbiAgICBqd3RQcm92aWRlcj86IHtcbiAgICAgIGlkOiBzdHJpbmc7XG4gICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICBqd2tzVXJsOiBzdHJpbmc7XG4gICAgICBlbmFibGVkOiBib29sZWFuO1xuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICogU2VydmVyQXV0aFNlcnZpY2UgaW1wbGVtZW50cyBzdHJhdGVneS1iYXNlZCBzZXJ2ZXIgYXV0aGVudGljYXRpb25cbiAqXG4gKiBUaGlzIHNlcnZpY2UgdXNlcyB0aGUgU3RyYXRlZ3kgUGF0dGVybiB0byBoYW5kbGUgZGlmZmVyZW50IGF1dGhlbnRpY2F0aW9uIHR5cGVzXG4gKiBOTyBIQVJEQ09ERUQgSUYvRUxTRSBTVEFURU1FTlRTIC0gYXV0aGVudGljYXRpb24gbWV0aG9kIHNlbGVjdGlvbiBpcyBjb25maWd1cmF0aW9uLWRyaXZlblxuICovXG5leHBvcnQgY2xhc3MgU2VydmVyQXV0aFNlcnZpY2Uge1xuICBwcml2YXRlIHN0cmF0ZWd5RmFjdG9yeTogQXV0aFN0cmF0ZWd5RmFjdG9yeTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRiOiBQcmlzbWFDbGllbnQsXG4gICAgcHJpdmF0ZSBsb2dnZXI/OiBMb2dnZXIsXG4gICkge1xuICAgIC8vIEluaXRpYWxpemUgc3RyYXRlZ3kgZmFjdG9yeSB3aXRoIGFsbCBhdmFpbGFibGUgYXV0aGVudGljYXRpb24gc3RyYXRlZ2llc1xuICAgIHRoaXMuc3RyYXRlZ3lGYWN0b3J5ID0gbmV3IEF1dGhTdHJhdGVneUZhY3RvcnkoZGIsIGxvZ2dlcik7XG4gIH1cblxuICAvKipcbiAgICogQXV0aGVudGljYXRlIGEgc2VydmVyIHJlcXVlc3QgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gc3RyYXRlZ3lcbiAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgU3RyYXRlZ3kgUGF0dGVybiB0byBhdm9pZCBoYXJkY29kZWQgYXV0aGVudGljYXRpb24gbG9naWNcbiAgICovXG4gIGFzeW5jIGF1dGhlbnRpY2F0ZVNlcnZlclJlcXVlc3QocmVxOiBSZXF1ZXN0LCBzZXJ2ZXJJZDogc3RyaW5nKTogUHJvbWlzZTxTZXJ2ZXJBdXRoUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW5nIHNlcnZlciByZXF1ZXN0XCIsIHsgc2VydmVySWQgfSk7XG5cbiAgICAgIC8vIEdldCBzZXJ2ZXIgYXV0aCBjb25maWd1cmF0aW9uIGZyb20gZGF0YWJhc2VcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHRoaXMuZ2V0U2VydmVyQXV0aENvbmZpZyhzZXJ2ZXJJZCk7XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgTm8gYXV0aGVudGljYXRpb24gY29uZmlndXJhdGlvbiBmb3VuZCBmb3Igc2VydmVyOiAke3NlcnZlcklkfWAsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBhcHByb3ByaWF0ZSBzdHJhdGVneSBiYXNlZCBvbiBzdG9yZWQgY29uZmlnIChOTyBIQVJEQ09ERUQgSUYgU1RBVEVNRU5UUylcbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneUZhY3RvcnkuZ2V0U3RyYXRlZ3koY29uZmlnLmF1dGhUeXBlKTtcblxuICAgICAgLy8gRXhlY3V0ZSBhdXRoZW50aWNhdGlvbiB1c2luZyBzdHJhdGVneVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RyYXRlZ3kuYXV0aGVudGljYXRlKHJlcSwgY29uZmlnKTtcblxuICAgICAgdGhpcy5sb2dnZXI/LmRlYnVnKFwiQXV0aGVudGljYXRpb24gcmVzdWx0XCIsIHtcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIGF1dGhUeXBlOiBjb25maWcuYXV0aFR5cGUsXG4gICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byBhdXRoZW50aWNhdGUgc2VydmVyIHJlcXVlc3RcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBgQXV0aGVudGljYXRpb24gZmFpbGVkOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNlcnZlciBhdXRoZW50aWNhdGlvbiBjb25maWd1cmF0aW9uXG4gICAqL1xuICBhc3luYyBnZXRTZXJ2ZXJBdXRoQ29uZmlnKHNlcnZlcklkOiBzdHJpbmcpOiBQcm9taXNlPFNlcnZlckF1dGhDb25maWcgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkdldHRpbmcgc2VydmVyIGF1dGggY29uZmlnXCIsIHsgc2VydmVySWQgfSk7XG5cbiAgICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuZGIubWNwU2VydmVyLmZpbmRGaXJzdCh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiBzZXJ2ZXJJZCB9LFxuICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgYXV0aENvbmZpZzoge1xuICAgICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgICBqd3RQcm92aWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXNlcnZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBub3QgZm91bmQ6ICR7c2VydmVySWR9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGV4cGxpY2l0IGF1dGggY29uZmlnIGV4aXN0cywgY3JlYXRlIGRlZmF1bHQgQkFTRSBhdXRoIGNvbmZpZ1xuICAgICAgaWYgKCFzZXJ2ZXIuYXV0aENvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBgZGVmYXVsdC0ke3NlcnZlcklkfWAsXG4gICAgICAgICAgc2VydmVySWQ6IHNlcnZlci5pZCxcbiAgICAgICAgICBhdXRoVHlwZTogKHNlcnZlci5hdXRoVHlwZSBhcyBTZXJ2ZXJBdXRoVHlwZSkgfHwgU2VydmVyQXV0aFR5cGUuQkFTRSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHNlcnZlci5hdXRoQ29uZmlnLmlkLFxuICAgICAgICBzZXJ2ZXJJZDogc2VydmVyLmlkLFxuICAgICAgICBhdXRoVHlwZTogc2VydmVyLmF1dGhDb25maWcuYXV0aFR5cGUgYXMgU2VydmVyQXV0aFR5cGUsXG4gICAgICAgIGp3dFByb3ZpZGVySWQ6IHNlcnZlci5hdXRoQ29uZmlnLmp3dFByb3ZpZGVySWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBqd3RQcm92aWRlcjogc2VydmVyLmF1dGhDb25maWcuand0UHJvdmlkZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIGdldCBzZXJ2ZXIgYXV0aCBjb25maWdcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzZXJ2ZXIgYXV0aGVudGljYXRpb24gY29uZmlndXJhdGlvblxuICAgKi9cbiAgYXN5bmMgdXBkYXRlU2VydmVyQXV0aENvbmZpZyhcbiAgICBzZXJ2ZXJJZDogc3RyaW5nLFxuICAgIGNvbmZpZzogVXBkYXRlU2VydmVyQXV0aENvbmZpZ1JlcXVlc3QsXG4gICk6IFByb21pc2U8U2VydmVyQXV0aENvbmZpZ1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIlVwZGF0aW5nIHNlcnZlciBhdXRoIGNvbmZpZ1wiLCB7IHNlcnZlcklkLCBjb25maWcgfSk7XG5cbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIGF1dGggdHlwZSBpcyBzdXBwb3J0ZWRcbiAgICAgIGlmICghdGhpcy5zdHJhdGVneUZhY3RvcnkuaXNTdXBwb3J0ZWQoY29uZmlnLmF1dGhUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGF1dGhlbnRpY2F0aW9uIHR5cGU6ICR7Y29uZmlnLmF1dGhUeXBlfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgYXV0aCBjb25maWcgY3JlYXRpb24vdXBkYXRlIHVzaW5nIHN0cmF0ZWd5IHBhdHRlcm5cbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneUZhY3RvcnkuZ2V0U3RyYXRlZ3koY29uZmlnLmF1dGhUeXBlKTtcbiAgICAgIGNvbnN0IGF1dGhDb25maWdJZCA9IGF3YWl0IHN0cmF0ZWd5LmhhbmRsZUNvbmZpZ1VwZGF0ZShzZXJ2ZXJJZCwge1xuICAgICAgICBhdXRoVHlwZTogY29uZmlnLmF1dGhUeXBlLFxuICAgICAgICBqd3RQcm92aWRlcklkOiBjb25maWcuand0UHJvdmlkZXJJZCB8fCB1bmRlZmluZWQsXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIHNlcnZlciBhdXRoIHR5cGUgYW5kIGNvbmZpZ1xuICAgICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5kYi5tY3BTZXJ2ZXIudXBkYXRlKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHNlcnZlcklkIH0sXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhdXRoVHlwZTogY29uZmlnLmF1dGhUeXBlLFxuICAgICAgICAgIGF1dGhDb25maWdJZCxcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIGF1dGhDb25maWc6IHtcbiAgICAgICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICAgICAgand0UHJvdmlkZXI6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gQXV0b21hdGljYWxseSBhZGQgSldUIGhlYWRlcnMgdG8gYWxsIHRvb2xzIHdoZW4gSldUIGF1dGggdHlwZSBpcyBzZXRcbiAgICAgIGlmIChjb25maWcuYXV0aFR5cGUgPT09IFNlcnZlckF1dGhUeXBlLkpXVCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuYWRkSnd0SGVhZGVyc1RvQWxsVG9vbHMoc2VydmVySWQpO1xuICAgICAgICAgIHRoaXMubG9nZ2VyPy5pbmZvKFwiQXV0b21hdGljYWxseSBhZGRlZCBKV1QgaGVhZGVycyB0byBhbGwgdG9vbHMgYWZ0ZXIgc2V0dGluZyBKV1QgYXV0aCB0eXBlXCIsIHsgc2VydmVySWQgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXI/Lndhcm4oXCJGYWlsZWQgdG8gYXV0b21hdGljYWxseSBhZGQgSldUIGhlYWRlcnMgdG8gdG9vbHNcIiwgeyBzZXJ2ZXJJZCwgZXJyb3IgfSk7XG4gICAgICAgICAgLy8gRG9uJ3QgZmFpbCB0aGUgYXV0aCBjb25maWcgdXBkYXRlIGlmIGhlYWRlciBhZGRpdGlvbiBmYWlsc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlcnZlcklkOiBzZXJ2ZXIuaWQsXG4gICAgICAgIGF1dGhUeXBlOiBzZXJ2ZXIuYXV0aFR5cGUgYXMgU2VydmVyQXV0aFR5cGUsXG4gICAgICAgIGF1dGhDb25maWc6IHNlcnZlci5hdXRoQ29uZmlnXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIGlkOiBzZXJ2ZXIuYXV0aENvbmZpZy5pZCxcbiAgICAgICAgICAgICAgYXV0aFR5cGU6IHNlcnZlci5hdXRoQ29uZmlnLmF1dGhUeXBlIGFzIFNlcnZlckF1dGhUeXBlLFxuICAgICAgICAgICAgICBqd3RQcm92aWRlcjogc2VydmVyLmF1dGhDb25maWcuand0UHJvdmlkZXJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcnZlci5hdXRoQ29uZmlnLmp3dFByb3ZpZGVyLmlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXJ2ZXIuYXV0aENvbmZpZy5qd3RQcm92aWRlci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBqd2tzVXJsOiBzZXJ2ZXIuYXV0aENvbmZpZy5qd3RQcm92aWRlci5qd2tzVXJsLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBzZXJ2ZXIuYXV0aENvbmZpZy5qd3RQcm92aWRlci5lbmFibGVkLFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBzZXJ2ZXIgYXV0aCBjb25maWdcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN1cHBvcnRlZCBhdXRoZW50aWNhdGlvbiB0eXBlc1xuICAgKiBSZXR1cm5zIGFsbCBhdXRoZW50aWNhdGlvbiB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgc3RyYXRlZ3kgZmFjdG9yeVxuICAgKi9cbiAgZ2V0U3VwcG9ydGVkQXV0aFR5cGVzKCk6IFNlcnZlckF1dGhUeXBlW10ge1xuICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5RmFjdG9yeS5nZXRTdXBwb3J0ZWRBdXRoVHlwZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXV0aCBwcm92aWRlcnMgZm9yIGEgc2VydmVyIChzdHJhdGVneS1iYXNlZClcbiAgICovXG4gIGFzeW5jIGdldEF1dGhQcm92aWRlcnMoc2VydmVySWQ6IHN0cmluZyk6IFByb21pc2U8QXV0aFByb3ZpZGVyW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgdGhpcy5nZXRTZXJ2ZXJBdXRoQ29uZmlnKHNlcnZlcklkKTtcbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWd5RmFjdG9yeS5nZXRTdHJhdGVneShjb25maWcuYXV0aFR5cGUpO1xuICAgICAgcmV0dXJuIGF3YWl0IHN0cmF0ZWd5LmdldFByb3ZpZGVycyhzZXJ2ZXJJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byBnZXQgYXV0aCBwcm92aWRlcnNcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhdXRoIHByb3ZpZGVyIGZvciBhIHNlcnZlciAoc3RyYXRlZ3ktYmFzZWQpXG4gICAqL1xuICBhc3luYyBjcmVhdGVBdXRoUHJvdmlkZXIoc2VydmVySWQ6IHN0cmluZywgcHJvdmlkZXJEYXRhOiBDcmVhdGVQcm92aWRlclJlcXVlc3QpOiBQcm9taXNlPEF1dGhQcm92aWRlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25maWcgPSBhd2FpdCB0aGlzLmdldFNlcnZlckF1dGhDb25maWcoc2VydmVySWQpO1xuICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aGVudGljYXRpb24gY29uZmlndXJhdGlvbiBmb3VuZFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWd5RmFjdG9yeS5nZXRTdHJhdGVneShjb25maWcuYXV0aFR5cGUpO1xuICAgICAgcmV0dXJuIGF3YWl0IHN0cmF0ZWd5LmNyZWF0ZVByb3ZpZGVyKHNlcnZlcklkLCBwcm92aWRlckRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICB0aGlzLmxvZ2dlcj8uZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGF1dGggcHJvdmlkZXJcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhdXRoIHByb3ZpZGVyIGZvciBhIHNlcnZlciAoc3RyYXRlZ3ktYmFzZWQpXG4gICAqL1xuICBhc3luYyB1cGRhdGVBdXRoUHJvdmlkZXIoXG4gICAgc2VydmVySWQ6IHN0cmluZyxcbiAgICBwcm92aWRlcklkOiBzdHJpbmcsXG4gICAgcHJvdmlkZXJEYXRhOiBVcGRhdGVQcm92aWRlclJlcXVlc3QsXG4gICk6IFByb21pc2U8QXV0aFByb3ZpZGVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHRoaXMuZ2V0U2VydmVyQXV0aENvbmZpZyhzZXJ2ZXJJZCk7XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhdXRoZW50aWNhdGlvbiBjb25maWd1cmF0aW9uIGZvdW5kXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ3lGYWN0b3J5LmdldFN0cmF0ZWd5KGNvbmZpZy5hdXRoVHlwZSk7XG4gICAgICByZXR1cm4gYXdhaXQgc3RyYXRlZ3kudXBkYXRlUHJvdmlkZXIoc2VydmVySWQsIHByb3ZpZGVySWQsIHByb3ZpZGVyRGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgYXV0aCBwcm92aWRlclwiLCB7XG4gICAgICAgIHNlcnZlcklkLFxuICAgICAgICBwcm92aWRlcklkLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGF1dGggcHJvdmlkZXIgZm9yIGEgc2VydmVyIChzdHJhdGVneS1iYXNlZClcbiAgICovXG4gIGFzeW5jIGRlbGV0ZUF1dGhQcm92aWRlcihzZXJ2ZXJJZDogc3RyaW5nLCBwcm92aWRlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgdGhpcy5nZXRTZXJ2ZXJBdXRoQ29uZmlnKHNlcnZlcklkKTtcbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGF1dGhlbnRpY2F0aW9uIGNvbmZpZ3VyYXRpb24gZm91bmRcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneUZhY3RvcnkuZ2V0U3RyYXRlZ3koY29uZmlnLmF1dGhUeXBlKTtcbiAgICAgIGF3YWl0IHN0cmF0ZWd5LmRlbGV0ZVByb3ZpZGVyKHNlcnZlcklkLCBwcm92aWRlcklkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBhdXRoIHByb3ZpZGVyXCIsIHtcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgSldUIHByb3ZpZGVycyBmb3IgYSBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIGdldEp3dFByb3ZpZGVycyhzZXJ2ZXJJZDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkdldHRpbmcgSldUIHByb3ZpZGVyc1wiLCB7IHNlcnZlcklkIH0pO1xuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5zZXJ2ZXJKd3RQcm92aWRlci5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlOiB7IHNlcnZlcklkIH0sXG4gICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byBnZXQgSldUIHByb3ZpZGVyc1wiLCB7XG4gICAgICAgIHNlcnZlcklkLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEpXVCBwcm92aWRlciBmb3IgYSBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUp3dFByb3ZpZGVyKHNlcnZlcklkOiBzdHJpbmcsIGRhdGE6IHsgbmFtZTogc3RyaW5nOyBqd2tzVXJsOiBzdHJpbmc7IGVuYWJsZWQ/OiBib29sZWFuIH0pIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5sb2dnZXI/LmRlYnVnKFwiQ3JlYXRpbmcgSldUIHByb3ZpZGVyXCIsIHsgc2VydmVySWQsIGRhdGEgfSk7XG5cbiAgICAgIC8vIEdldCBzZXJ2ZXIgdG8gdmFsaWRhdGUgaXQgZXhpc3RzIGFuZCBnZXQgdGVuYW50SWRcbiAgICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuZGIubWNwU2VydmVyLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogc2VydmVySWQgfSxcbiAgICAgICAgc2VsZWN0OiB7IHRlbmFudElkOiB0cnVlIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzZXJ2ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgbm90IGZvdW5kOiAke3NlcnZlcklkfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5zZXJ2ZXJKd3RQcm92aWRlci5jcmVhdGUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc2VydmVySWQsXG4gICAgICAgICAgdGVuYW50SWQ6IHNlcnZlci50ZW5hbnRJZCxcbiAgICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgICAgandrc1VybDogZGF0YS5qd2tzVXJsLFxuICAgICAgICAgIGVuYWJsZWQ6IGRhdGEuZW5hYmxlZCA/PyB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgSldUIHByb3ZpZGVyXCIsIHtcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBKV1QgcHJvdmlkZXJcbiAgICovXG4gIGFzeW5jIHVwZGF0ZUp3dFByb3ZpZGVyKFxuICAgIHNlcnZlcklkOiBzdHJpbmcsXG4gICAgcHJvdmlkZXJJZDogc3RyaW5nLFxuICAgIGRhdGE6IHsgbmFtZT86IHN0cmluZzsgandrc1VybD86IHN0cmluZzsgZW5hYmxlZD86IGJvb2xlYW4gfSxcbiAgKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIlVwZGF0aW5nIEpXVCBwcm92aWRlclwiLCB7IHNlcnZlcklkLCBwcm92aWRlcklkLCBkYXRhIH0pO1xuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5kYi5zZXJ2ZXJKd3RQcm92aWRlci51cGRhdGUoe1xuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGlkOiBwcm92aWRlcklkLFxuICAgICAgICAgIHNlcnZlcklkLCAvLyBFbnN1cmUgdGhlIHByb3ZpZGVyIGJlbG9uZ3MgdG8gdGhlIHNwZWNpZmllZCBzZXJ2ZXJcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLihkYXRhLm5hbWUgJiYgeyBuYW1lOiBkYXRhLm5hbWUgfSksXG4gICAgICAgICAgLi4uKGRhdGEuandrc1VybCAmJiB7IGp3a3NVcmw6IGRhdGEuandrc1VybCB9KSxcbiAgICAgICAgICAuLi4oZGF0YS5lbmFibGVkICE9PSB1bmRlZmluZWQgJiYgeyBlbmFibGVkOiBkYXRhLmVuYWJsZWQgfSksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBKV1QgcHJvdmlkZXJcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIEpXVCBwcm92aWRlclxuICAgKi9cbiAgYXN5bmMgZGVsZXRlSnd0UHJvdmlkZXIoc2VydmVySWQ6IHN0cmluZywgcHJvdmlkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkRlbGV0aW5nIEpXVCBwcm92aWRlclwiLCB7IHNlcnZlcklkLCBwcm92aWRlcklkIH0pO1xuXG4gICAgICBhd2FpdCB0aGlzLmRiLnNlcnZlckp3dFByb3ZpZGVyLmRlbGV0ZSh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgaWQ6IHByb3ZpZGVySWQsXG4gICAgICAgICAgc2VydmVySWQsIC8vIEVuc3VyZSB0aGUgcHJvdmlkZXIgYmVsb25ncyB0byB0aGUgc3BlY2lmaWVkIHNlcnZlclxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byBkZWxldGUgSldUIHByb3ZpZGVyXCIsIHtcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgSldUIGhlYWRlcnMgdG8gYWxsIHRvb2xzIGZvciBhIHNlcnZlclxuICAgKiBUaGlzIHVwZGF0ZXMgdGhlIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXMgb2YgYWxsIHRvb2xzIHRvIGluY2x1ZGUgQXV0aG9yaXphdGlvbiBoZWFkZXIgd2l0aCBKV1QgdG9rZW5cbiAgICovXG4gIGFzeW5jIGFkZEp3dEhlYWRlcnNUb0FsbFRvb2xzKHNlcnZlcklkOiBzdHJpbmcpOiBQcm9taXNlPHsgdXBkYXRlZFRvb2xzQ291bnQ6IG51bWJlciB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkFkZGluZyBKV1QgaGVhZGVycyB0byBhbGwgdG9vbHMgZm9yIHNlcnZlclwiLCB7IHNlcnZlcklkIH0pO1xuXG4gICAgICAvLyBWZXJpZnkgc2VydmVyIGV4aXN0cyBhbmQgdXNlcyBKV0tTIGF1dGhlbnRpY2F0aW9uXG4gICAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0aGlzLmRiLm1jcFNlcnZlci5maW5kVW5pcXVlKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHNlcnZlcklkIH0sXG4gICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICBhdXRoQ29uZmlnOiB7XG4gICAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICAgIGp3dFByb3ZpZGVyOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghc2VydmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIG5vdCBmb3VuZDogJHtzZXJ2ZXJJZH1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlcnZlci5hdXRoVHlwZSAhPT0gU2VydmVyQXV0aFR5cGUuSldUKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyICR7c2VydmVySWR9IGRvZXMgbm90IHVzZSBKV1QgYXV0aGVudGljYXRpb24uIEN1cnJlbnQgYXV0aCB0eXBlOiAke3NlcnZlci5hdXRoVHlwZX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGFsbCB0b29scyBmb3IgdGhlIHNlcnZlclxuICAgICAgY29uc3QgdG9vbHMgPSBhd2FpdCB0aGlzLmRiLnRvb2wuZmluZE1hbnkoe1xuICAgICAgICB3aGVyZTogeyBzZXJ2ZXJJZCB9LFxuICAgICAgICBzZWxlY3Q6IHsgaWQ6IHRydWUsIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXM6IHRydWUgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodG9vbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyPy5pbmZvKFwiTm8gdG9vbHMgZm91bmQgZm9yIHNlcnZlclwiLCB7IHNlcnZlcklkIH0pO1xuICAgICAgICByZXR1cm4geyB1cGRhdGVkVG9vbHNDb3VudDogMCB9O1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZWFjaCB0b29sJ3MgcmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlcyB0byBpbmNsdWRlIEpXVCBoZWFkZXJcbiAgICAgIGNvbnN0IHVwZGF0ZVByb21pc2VzID0gdG9vbHMubWFwKGFzeW5jICh0b29sKSA9PiB7XG4gICAgICAgIC8vIFBhcnNlIGV4aXN0aW5nIG92ZXJyaWRlcyBvciBzdGFydCB3aXRoIGVtcHR5IG9iamVjdFxuICAgICAgICBjb25zdCBleGlzdGluZ092ZXJyaWRlcyA9IHRvb2wucmVxdWVzdFBhcmFtZXRlck92ZXJyaWRlc1xuICAgICAgICAgID8gKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodG9vbC5yZXF1ZXN0UGFyYW1ldGVyT3ZlcnJpZGVzKSkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pXG4gICAgICAgICAgOiB7fTtcblxuICAgICAgICAvLyBBZGQgb3IgdXBkYXRlIEF1dGhvcml6YXRpb24gaGVhZGVyIHdpdGggSldUIHRlbXBsYXRlXG4gICAgICAgIC8vIFVJIGV4cGVjdHMgUmVxdWVzdFBhcmFtQ29uZmlnIG9iamVjdCB3aXRoIHZhbHVlIGFuZCBsb2NhdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRPdmVycmlkZXMgPSB7XG4gICAgICAgICAgLi4uZXhpc3RpbmdPdmVycmlkZXMsXG4gICAgICAgICAgQXV0aG9yaXphdGlvbjoge1xuICAgICAgICAgICAgdmFsdWU6IFwiQmVhcmVyIHt7YXV0aC5qd3R9fVwiLFxuICAgICAgICAgICAgbG9jYXRpb246IFBhcmFtZXRlckxvY2F0aW9uLkhFQURFUixcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRiLnRvb2wudXBkYXRlKHtcbiAgICAgICAgICB3aGVyZTogeyBpZDogdG9vbC5pZCB9LFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbWV0ZXJPdmVycmlkZXM6IHVwZGF0ZWRPdmVycmlkZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBhbGwgdXBkYXRlc1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodXBkYXRlUHJvbWlzZXMpO1xuXG4gICAgICB0aGlzLmxvZ2dlcj8uaW5mbyhcIlN1Y2Nlc3NmdWxseSBhZGRlZCBKV1QgaGVhZGVycyB0byBhbGwgdG9vbHNcIiwge1xuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgdXBkYXRlZFRvb2xzQ291bnQ6IHRvb2xzLmxlbmd0aCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4geyB1cGRhdGVkVG9vbHNDb3VudDogdG9vbHMubGVuZ3RoIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIHRoaXMubG9nZ2VyPy5lcnJvcihcIkZhaWxlZCB0byBhZGQgSldUIGhlYWRlcnMgdG8gYWxsIHRvb2xzXCIsIHtcbiAgICAgICAgc2VydmVySWQsXG4gICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIEpXS1MgVVJMIGJ5IGZldGNoaW5nIGFuZCBwYXJzaW5nIGl0XG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZUp3a3NVcmwoandrc1VybDogc3RyaW5nKTogUHJvbWlzZTx7IHZhbGlkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsga2V5Q291bnQ/OiBudW1iZXIgfT4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmxvZ2dlcj8uZGVidWcoXCJWYWxpZGF0aW5nIEpXS1MgVVJMXCIsIHsgandrc1VybCB9KTtcblxuICAgICAgLy8gVmFsaWRhdGUgVVJMIGZvcm1hdFxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFVSTChqd2tzVXJsKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogXCJJbnZhbGlkIFVSTCBmb3JtYXRcIixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gRmV0Y2ggSldLUyBmcm9tIHRoZSBVUkxcbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkZldGNoaW5nIEpXS1MgZnJvbSBVUkxcIiwgeyBqd2tzVXJsIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChqd2tzVXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZCB0aW1lb3V0IHRvIHByZXZlbnQgaGFuZ2luZyByZXF1ZXN0c1xuICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTAwMDApLCAvLyAxMCBzZWNvbmQgdGltZW91dFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubG9nZ2VyPy5kZWJ1ZyhcIkpXS1MgZmV0Y2ggcmVzcG9uc2VcIiwge1xuICAgICAgICBqd2tzVXJsLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyPy53YXJuKFwiSldLUyBVUkwgZmV0Y2ggZmFpbGVkXCIsIHtcbiAgICAgICAgICBqd2tzVXJsLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBmZXRjaCBKV0tTOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZSBhcyBKU09OXG4gICAgICBsZXQgandrczogSnd0UmVzcG9uc2U7XG4gICAgICB0cnkge1xuICAgICAgICBqd2tzID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMgSnd0UmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiUmVzcG9uc2UgaXMgbm90IHZhbGlkIEpTT05cIixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgSldLUyBzdHJ1Y3R1cmVcbiAgICAgIGlmICghandrcyB8fCB0eXBlb2YgandrcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogXCJKV0tTIHJlc3BvbnNlIGlzIG5vdCBhIHZhbGlkIG9iamVjdFwiLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoandrcy5rZXlzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogXCJKV0tTIGRvZXMgbm90IGNvbnRhaW4gYSAna2V5cycgYXJyYXlcIixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGp3a3Mua2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiSldLUyBjb250YWlucyBubyBrZXlzXCIsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIGVhY2gga2V5IGhhcyByZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGp3a3Mua2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBqd2tzLmtleXNbaV07XG4gICAgICAgIGlmICgha2V5Lmt0eSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogYEtleSBhdCBpbmRleCAke2l9IGlzIG1pc3NpbmcgcmVxdWlyZWQgJ2t0eScgcHJvcGVydHlgLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIGtleUNvdW50OiBqd2tzLmtleXMubGVuZ3RoLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgdGhpcy5sb2dnZXI/LmVycm9yKFwiRmFpbGVkIHRvIHZhbGlkYXRlIEpXS1MgVVJMXCIsIHtcbiAgICAgICAgandrc1VybCxcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgZXJyb3IgdHlwZXNcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiZmV0Y2hcIikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiTmV0d29yayBlcnJvcjogVW5hYmxlIHRvIGZldGNoIEpXS1MgVVJMXCIsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiVGltZW91dDogSldLUyBVUkwgZGlkIG5vdCByZXNwb25kIHdpdGhpbiAxMCBzZWNvbmRzXCIsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBWYWxpZGF0aW9uIGZhaWxlZDogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IGV4cHJlc3MgZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IG1pcnJvclJlcXVlc3QgfSBmcm9tIFwiLi4vY29udHJvbGxlcnMvbWlycm9yLmNvbnRyb2xsZXIuanNcIjtcbmltcG9ydCB7IGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUgfSBmcm9tIFwiLi4vbWlkZGxld2FyZXMvc2Vzc2lvbi5taWRkbGV3YXJlLmpzXCI7XG5cbmNvbnN0IHJvdXRlciA9IGV4cHJlc3MuUm91dGVyKCk7XG5cbnJvdXRlci5nZXQoXCIvXCIsIGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUsIG1pcnJvclJlcXVlc3QpO1xuXG5leHBvcnQgZGVmYXVsdCByb3V0ZXI7XG4iLCAiaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IHsgTmV4dEZ1bmN0aW9uLCBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBTdGF0dXNDb2RlcyB9IGZyb20gXCJodHRwLXN0YXR1cy1jb2Rlc1wiO1xuaW1wb3J0IHsgVVJMIH0gZnJvbSBcInVybFwiO1xuaW1wb3J0IHsgaXNBcHBSZXF1ZXN0LCBUeXBlR3VhcmRFcnJvciB9IGZyb20gXCIuLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWlycm9yUmVxdWVzdChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UsIG5leHQ6IE5leHRGdW5jdGlvbik6IFByb21pc2U8dm9pZD4ge1xuICBpZiAoIWlzQXBwUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSByZXEucXVlcnkudXJsIGFzIHN0cmluZztcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBcIkludmFsaWQgVVJMIHByb3ZpZGVkXCIsIHVybCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBVUkwodXJsKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogXCJJbnZhbGlkIFVSTCBwcm92aWRlZFwiLCB1cmwgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQodXJsLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi95YW1sLGFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTZXQgdGhlIHNhbWUgY29udGVudCB0eXBlIGFzIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICAgIHJlcy5zZXQoXCJDb250ZW50LVR5cGVcIiwgcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcImFwcGxpY2F0aW9uL3lhbWxcIik7XG4gICAgcmVzLnN0YXR1cygyMDApLnNlbmQocmVzcG9uc2UuZGF0YSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhlcnJvcik7XG4gICAgbmV4dChlcnJvcik7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBSb3V0ZXIgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHtcbiAgYXV0aG9yaXplLFxuICBkeW5hbWljQ2xpZW50UmVnaXN0ZXIsXG4gIGV4Y2hhbmdlVG9rZW4sXG4gIGdldE9BdXRoU2VydmVySW5mbyxcbiAgaGFuZGxlQ2FsbGJhY2ssXG59IGZyb20gXCIuLi9jb250cm9sbGVycy9vYXV0aC5jb250cm9sbGVyLmpzXCI7XG5pbXBvcnQgeyBzZXJ2ZXJJZE1pZGRsZXdhcmUgfSBmcm9tIFwiLi4vbWlkZGxld2FyZXMvc2VydmVySWQubWlkZGxld2FyZS5qc1wiO1xuXG5jb25zdCByb3V0ZXI6IFJvdXRlciA9IFJvdXRlcigpO1xuXG5yb3V0ZXIuZ2V0KFwiLy53ZWxsLWtub3duL29hdXRoLWF1dGhvcml6YXRpb24tc2VydmVyXCIsIGdldE9BdXRoU2VydmVySW5mbyk7XG5yb3V0ZXIuZ2V0KFwiL2FwaS9vYXV0aC9hdXRob3JpemVcIiwgc2VydmVySWRNaWRkbGV3YXJlLCBhdXRob3JpemUpO1xucm91dGVyLnBvc3QoXCIvYXBpL29hdXRoL3Rva2VuXCIsIGV4Y2hhbmdlVG9rZW4pO1xucm91dGVyLmdldChcIi9hcGkvb2F1dGgvY2FsbGJhY2tcIiwgaGFuZGxlQ2FsbGJhY2spO1xucm91dGVyLnBvc3QoXCIvYXBpL29hdXRoL3JlZ2lzdGVyXCIsIGR5bmFtaWNDbGllbnRSZWdpc3Rlcik7XG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlcjtcbiIsICJpbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgU3RhdHVzQ29kZXMgfSBmcm9tIFwiaHR0cC1zdGF0dXMtY29kZXNcIjtcbmltcG9ydCB7IENhY2hlSXRlbVR5cGUsIGNsZWFyQ2FjaGVCeVBhcnRpYWxLZXkgfSBmcm9tIFwiLi4vc2VydmljZXMvY2FjaGUuc2VydmljZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlRW5kVXNlcklmTm90RXhpc3RzLCBnZXRFbmRVc2VyQnlFbWFpbEFuZFNlcnZlcklkIH0gZnJvbSBcIi4uL3NlcnZpY2VzL2VuZHVzZXIuc2VydmljZS5qc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVFbmRVc2VyVG9rZW4sIHZlcmlmeUFkbWluVG9rZW4gfSBmcm9tIFwiLi4vc2VydmljZXMvand0LnNlcnZpY2UuanNcIjtcbmltcG9ydCB7XG4gIGNhbGxiYWNrVXJsLFxuICBkZWNvZGVEYXRhLFxuICBlbmNvZGVEYXRhLFxuICBFTkRVU0VSX1NDT1BFLFxuICBleGNoYW5nZUNvZGVGb3JUb2tlbixcbiAgZ2V0QXV0aG9yaXplVXJsLFxuICBnZXRIb3N0VXJsLFxuICBwZXJzaXN0VG9rZW4sXG4gIFN0YXRlRGF0YSxcbiAgVE9PTF9TQ09QRSxcbn0gZnJvbSBcIi4uL3NlcnZpY2VzL29hdXRoLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IGVuZHVzZXJTaGFyZWRTZWNyZXQsIFNJR05BVFVSRV9FWFBJUkFUSU9OX01TRUMsIHNpZ25EYXRhIH0gZnJvbSBcIi4uL3NlcnZpY2VzL293bmlkLnNlY3JldC5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBPQXV0aEVycm9yIH0gZnJvbSBcIi4uL3R5cGVzL2Vycm9yLnR5cGVzLmpzXCI7XG5pbXBvcnQgeyBpc0FwcFJlcXVlc3QsIGlzV2l0aFNlcnZlcklkUmVxdWVzdCwgVHlwZUd1YXJkRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuaW1wb3J0IHsgRW5kVXNlclNob3J0U2Vzc2lvbiB9IGZyb20gXCIuL293bmlkLmNvbnRyb2xsZXIuanNcIjtcblxuY29uc3QgQ09OU09MRV9VUkwgPSBwcm9jZXNzLmVudi5DT05TT0xFX1VSTCB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDIwMFwiO1xuY29uc3QgQ09OU09MRV9BVVRIX1BBVEggPSBcIi9sb2dpblwiO1xuY29uc3QgQ09OU09MRV9TVUNDRVNTX1BBVEggPSBcIi9vYXV0aC9zdWNjZXNzXCI7XG5jb25zdCBDT05TT0xFX0ZBSUxVUkVfUEFUSCA9IFwiL29hdXRoL2NhbGxiYWNrXCI7XG5cbmNvbnN0IFNUVURJT19SRURJUkVDVF9PUklHSU5TID0gW1wiYWdlbnRwYXNzLmFpXCIsIFwiYWdlbnRwYXNzLnN0dWRpb1wiXTtcbmNvbnN0IEFMTE9XRURfUkVESVJFQ1RfT1JJR0lOUyA9IFtcImh0dHBzOi8vY2xhdWRlLmFpXCIsIFwiaHR0cDovL2xvY2FsaG9zdFwiLCBcImh0dHA6Ly8xMjcuMC4wLjFcIiwgXCJjdXJzb3I6Ly9cIl07XG5cbi8qKlxuID4gT0F1dGggMi4wIEF1dGhvcml6YXRpb24gQ29kZSBGbG93IEltcGxlbWVudGF0aW9uXG4gKiBEaXNjb3Zlcnk6IGBnZXRPQXV0aFNlcnZlckluZm9gXG4gKiBbT3B0aW9uYWxdIGR5bmFtaWMgY2xpZW50IHJlZ2lzdHJhdGlvbjogYGR5bmFtaWNDbGllbnRSZWdpc3RlcmBcbiAqIEluaXRpYXRlIGF1dGhvcml6YXRpb246IGBhdXRob3JpemVgIC0+IE9ubHkgYXBwbGljYWJsZSB0byBgZW5kdXNlcmAgZmxvdy4gUmVkaXJlY3RzIHRvIGNvbnNvbGUgYXBwIHdpdGggc3RhdGUgZGVzY3JpYmluZyB0aGUgcmVxdWVzdCAoY2xpZW50X2lkLCByZWRpcmVjdF91cmksIGV0Yy4pXG4gKiBDb25zb2xlIGFwcCByZWRpcmVjdHMgYmFjayB0bzogYGhhbmRsZUNhbGxiYWNrYCB3aGljaCB0aGVuIHJlZGlyZWN0cyBiYWNrIHRvIHRoZSBvcmlnaW5hbCByZWRpcmVjdCB1cmkgd2l0aCB0aGUgY29kZS5cbiAqICogTk9URTogaW4gY2FzZSBvZiBcInRvb2xcIiBhdXRoLCB0aGUgcmVxdWVzdCBpc24ndCByZWRpcmVjdGVkIGZyb20gY29uc29sZSwgYnV0IGZyb20gZXh0ZXJuYWwgcHJvdmlkZXIuIFRoZSBjb2RlIGlzIGV4Y2hhbmdlZCBmb3IgYSB0b2tlbiBhbmQgc3RvcmVkIGluIHRoZSBkYXRhYmFzZSBhbmQgYXV0aCBpcyBjb25zaWRlcmVkIGNvbXBsZXRlZC5cbiAqIEV4Y2hhbmdlIGNvZGUgZm9yIHRva2VuOiBgZXhjaGFuZ2VUb2tlbmAgZG9lc24ndCBhY3R1YWxseSBleGNoYW5nZSwgYXMgaXQgd2FzIGRvbmUgaW4gcHJldmlvdXMgc3RlcCwgc28gaXRzIGEgbm8tb3AuXG4gKi9cblxuaW50ZXJmYWNlIEVuZFVzZXJUb2tlblJlc3BvbnNlIHtcbiAgYWNjZXNzX3Rva2VuOiBzdHJpbmc7XG4gIG9yaWdpbmFsX3JlZGlyZWN0X3VyaTogc3RyaW5nIHwgbnVsbDtcbiAgdG9rZW5fdHlwZTogXCJCZWFyZXJcIjtcbn1cblxuY29uc3QgaXNSZWRpcmVjdFVyaUFsbG93ZWQgPSAocmVxOiBSZXF1ZXN0LCB1cmlzOiBzdHJpbmdbXSkgPT5cbiAgdXJpcy5ldmVyeShcbiAgICAodXJpOiBzdHJpbmcpID0+XG4gICAgICBbLi4uQUxMT1dFRF9SRURJUkVDVF9PUklHSU5TLCBnZXRIb3N0VXJsKHJlcSwgdHJ1ZSksIGdldEhvc3RVcmwocmVxLCBmYWxzZSldLnNvbWUoKGFsbG93ZWQpID0+XG4gICAgICAgIHVyaS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoYWxsb3dlZC50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICkgfHwgU1RVRElPX1JFRElSRUNUX09SSUdJTlMuc29tZSgodXJsKSA9PiBuZXcgVVJMKHVyaSkuaG9zdG5hbWUuZW5kc1dpdGgodXJsKSksXG4gICk7XG5cbmV4cG9ydCBjb25zdCBnZXRPQXV0aFNlcnZlckluZm8gPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRIb3N0VXJsKHJlcSwgdHJ1ZSk7XG4gIGNvbnN0IGlzc3VlciA9IG5ldyBVUkwoYmFzZVVybCkub3JpZ2luO1xuXG4gIHJlcy5qc29uKHtcbiAgICBpc3N1ZXIsXG4gICAgYXV0aG9yaXphdGlvbl9lbmRwb2ludDogYCR7aXNzdWVyfS9hcGkvb2F1dGgvYXV0aG9yaXplYCxcbiAgICB0b2tlbl9lbmRwb2ludDogYCR7aXNzdWVyfS9hcGkvb2F1dGgvdG9rZW5gLFxuICAgIHJlZ2lzdHJhdGlvbl9lbmRwb2ludDogYCR7aXNzdWVyfS9hcGkvb2F1dGgvcmVnaXN0ZXJgLFxuICAgIHNjb3Blc19zdXBwb3J0ZWQ6IFtcInByb2ZpbGVcIiwgXCJlbWFpbFwiLCBcIm9wZW5pZFwiXSxcbiAgICByZXNwb25zZV90eXBlc19zdXBwb3J0ZWQ6IFtcImNvZGVcIl0sXG4gICAgZ3JhbnRfdHlwZXNfc3VwcG9ydGVkOiBbXCJhdXRob3JpemF0aW9uX2NvZGVcIiwgXCJyZWZyZXNoX3Rva2VuXCJdLFxuICAgIHRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWQ6IFtcImNsaWVudF9zZWNyZXRfcG9zdFwiXSxcbiAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2RzX3N1cHBvcnRlZDogW1wiUzI1NlwiXSxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXV0aG9yaXplID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzV2l0aFNlcnZlcklkUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgc2VydmVySWQgfSA9IHJlcTtcbiAgICBjb25zdCB7IHJlZGlyZWN0X3VyaSwgc3RhdGU6IGNsaWVudFN0YXRlLCByZXNwb25zZV90eXBlLCBjbGllbnRfaWQsIHByb3ZpZGVyX2lkLCBhZG1pbl9hdXRoIH0gPSByZXEucXVlcnk7XG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhcIk9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdCByZWNlaXZlZFwiLCB7XG4gICAgICBzZXJ2ZXJJZCxcbiAgICAgIHJlZGlyZWN0X3VyaSxcbiAgICAgIGNsaWVudFN0YXRlLFxuICAgICAgcmVzcG9uc2VfdHlwZSxcbiAgICAgIGNsaWVudF9pZCxcbiAgICAgIHByb3ZpZGVyX2lkLFxuICAgICAgc2NvcGU6IHJlcS5xdWVyeS5zY29wZSxcbiAgICB9KTtcbiAgICBjb25zdCBzY29wZSA9IHJlcS5xdWVyeS5zY29wZSA9PT0gVE9PTF9TQ09QRSA/IFRPT0xfU0NPUEUgOiBFTkRVU0VSX1NDT1BFO1xuXG4gICAgaWYgKCFzZXJ2ZXJJZCkge1xuICAgICAgcmVxLmxvZ2dlci53YXJuKFwiU2VydmVyIElEIG5vdCBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwiU2VydmVyIElEIGlzIHJlcXVpcmVkXCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHJlcS5kYi5tY3BTZXJ2ZXIuZmluZFVuaXF1ZSh7XG4gICAgICB3aGVyZToge1xuICAgICAgICBpZDogc2VydmVySWQsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmICghc2VydmVyKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5OT1RfRk9VTkQpLmpzb24oeyBlcnJvcjogYFNlcnZlciAnJHtzZXJ2ZXJJZH0nIG5vdCBmb3VuZGAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdF91cmkpIHtcbiAgICAgIHJlcS5sb2dnZXIud2FybihcIk1pc3NpbmcgcmVkaXJlY3RfdXJpIGluIGF1dGhvcml6YXRpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwicmVkaXJlY3RfdXJpIGlzIHJlcXVpcmVkXCIgfSk7XG4gICAgfVxuICAgIGlmICghaXNSZWRpcmVjdFVyaUFsbG93ZWQocmVxLCBbcmVkaXJlY3RfdXJpIGFzIHN0cmluZ10pKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7XG4gICAgICAgIGVycm9yOiBcImludmFsaWRfcmVkaXJlY3RfdXJpXCIsXG4gICAgICAgIGVycm9yX2Rlc2NyaXB0aW9uOiBcIlJlZGlyZWN0IFVSSSBtdXN0IGJlIG9uZSBvZiB0aGUgYWxsb3dlZCBvcmlnaW5zXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgdXNlcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBpZiAoYWRtaW5fYXV0aCkge1xuICAgICAgY29uc3QgYWRtaW5DbGFpbXMgPSBhd2FpdCB2ZXJpZnlBZG1pblRva2VuKGFkbWluX2F1dGggYXMgc3RyaW5nKTtcbiAgICAgIGlmICghYWRtaW5DbGFpbXMpIHtcbiAgICAgICAgcmVxLmxvZ2dlci53YXJuKFwiSW52YWxpZCBhZG1pbiB0b2tlbiBwcm92aWRlZFwiKTtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuVU5BVVRIT1JJWkVEKS5qc29uKHsgZXJyb3I6IFwiSW52YWxpZCBhZG1pbiB0b2tlblwiIH0pO1xuICAgICAgfVxuICAgICAgdXNlcklkID0gKGF3YWl0IGNyZWF0ZUVuZFVzZXJJZk5vdEV4aXN0cyhyZXEuZGIsIHNlcnZlci50ZW5hbnRJZCwgYWRtaW5DbGFpbXMuZW1haWwpKS5pZDtcbiAgICB9XG5cbiAgICBpZiAocHJvdmlkZXJfaWQpIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcmVxLmRiLm9BdXRoUHJvdmlkZXIuZmluZEZpcnN0T3JUaHJvdyh7XG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgaWQ6IHByb3ZpZGVyX2lkIGFzIHN0cmluZyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBhdXRoVXJsID0gZ2V0QXV0aG9yaXplVXJsKFxuICAgICAgICByZXEsXG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAoY2xpZW50U3RhdGUgYXMgc3RyaW5nKSB8fCBcIlwiLFxuICAgICAgICBzZXJ2ZXJJZCEsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgc2NvcGUgYXMgc3RyaW5nLFxuICAgICAgICByZXEuaXAgfHwgbnVsbCxcbiAgICAgICAgcmVkaXJlY3RfdXJpIGFzIHN0cmluZyxcbiAgICAgICAgY2xpZW50X2lkIGFzIHN0cmluZyxcbiAgICAgICAgcmVzcG9uc2VfdHlwZSBhcyBzdHJpbmcsXG4gICAgICApO1xuXG4gICAgICByZXEubG9nZ2VyLmRlYnVnKFwiUmVkaXJlY3RpbmcgdG8gT0F1dGggcHJvdmlkZXJcIiwge1xuICAgICAgICBwcm92aWRlcjogcHJvdmlkZXIubmFtZSxcbiAgICAgICAgcmVkaXJlY3RVcmk6IGF1dGhVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgb3JpZ2luYWxSZWRpcmVjdFVyaTogcmVkaXJlY3RfdXJpLFxuICAgICAgICBjbGllbnRJZDogY2xpZW50X2lkLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXMucmVkaXJlY3QoYXV0aFVybC50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZURhdGE6IFN0YXRlRGF0YSA9IHtcbiAgICAgIHJlZGlyZWN0VXJpOiByZWRpcmVjdF91cmkgYXMgc3RyaW5nLFxuICAgICAgY2xpZW50U3RhdGU6IChjbGllbnRTdGF0ZSBhcyBzdHJpbmcpIHx8IFwiXCIsXG4gICAgICBjbGllbnRJZDogY2xpZW50X2lkIGFzIHN0cmluZyxcbiAgICAgIHNlcnZlcklkOiBzZXJ2ZXJJZCEsXG4gICAgICBzY29wZTogc2NvcGUgYXMgc3RyaW5nLFxuICAgICAgcHJvdmlkZXJJZDogbnVsbCxcbiAgICAgIG9yaWdpbkFkZHJlc3M6IHJlcS5pcCB8fCBudWxsLFxuICAgICAgdXNlcklkLFxuICAgIH07XG4gICAgY29uc3Qgc3RhdGVQYXJhbSA9IGVuY29kZURhdGEoc3RhdGVEYXRhKTtcblxuICAgIGNvbnN0IGNvbnNvbGVVcmwgPSBuZXcgVVJMKGAke0NPTlNPTEVfVVJMfSR7Q09OU09MRV9BVVRIX1BBVEh9YCk7XG5cbiAgICBjb25zb2xlVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzY29wZVwiLCBFTkRVU0VSX1NDT1BFKTtcbiAgICBjb25zb2xlVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzdGF0ZVwiLCBzdGF0ZVBhcmFtKTtcbiAgICBjb25zb2xlVXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJyZWRpcmVjdF91cmlcIiwgY2FsbGJhY2tVcmwocmVxKSk7XG4gICAgY29uc29sZVVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwic2VydmVyX2lkXCIsIHNlcnZlcklkIHx8IFwiXCIpO1xuICAgIGNvbnNvbGVVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInNlcnZlcl9uYW1lXCIsIHNlcnZlci5uYW1lKTtcblxuICAgIHJlcS5sb2dnZXIuZGVidWcoXCJSZWRpcmVjdGluZyB0byBjb25zb2xlIHRvIGNob29zZSBwcm92aWRlclwiLCB7XG4gICAgICByZWRpcmVjdFVyaTogY29uc29sZVVybC50b1N0cmluZygpLFxuICAgICAgb3JpZ2luYWxSZWRpcmVjdFVyaTogcmVkaXJlY3RfdXJpLFxuICAgICAgY2xpZW50SWQ6IGNsaWVudF9pZCxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXMucmVkaXJlY3QoY29uc29sZVVybC50b1N0cmluZygpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRXJyb3IgaW4gT0F1dGggYXV0aG9yaXplIGVuZHBvaW50XCIsIGVycm9yKTtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBPQXV0aEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRmFpbGVkIHRvIHByb2Nlc3MgYXV0aG9yaXphdGlvbiByZXF1ZXN0XCI7XG4gICAgcmV0dXJuIHJlcy5yZWRpcmVjdChgJHtDT05TT0xFX1VSTH0ke0NPTlNPTEVfRkFJTFVSRV9QQVRIfT9lcnJvcj0ke2VuY29kZVVSSUNvbXBvbmVudChtZXNzYWdlKX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGhhbmRsZUNhbGxiYWNrID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQXBwUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgY29kZSwgc3RhdGUsIGVycm9yIH0gPSByZXEucXVlcnk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJPQXV0aCBjYWxsYmFjayByZWNlaXZlZCB3aXRoIGVycm9yXCIsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IGVycm9yIH0pO1xuICAgIH1cblxuICAgIGlmICghY29kZSkge1xuICAgICAgcmVxLmxvZ2dlci5lcnJvcihcIk9BdXRoIGNhbGxiYWNrIHJlY2VpdmVkIHdpdGhvdXQgY29kZVwiKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwiTm8gY29kZSByZWNlaXZlZCBmcm9tIE9BdXRoIHByb3ZpZGVyXCIgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgcmVxLmxvZ2dlci5lcnJvcihcIk9BdXRoIGNhbGxiYWNrIHJlY2VpdmVkIHdpdGhvdXQgc3RhdGVcIik7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBcIk5vIHN0YXRlIHJlY2VpdmVkIGZyb20gT0F1dGggcHJvdmlkZXJcIiB9KTtcbiAgICB9XG5cbiAgICBsZXQgc3RhdGVEYXRhOiBTdGF0ZURhdGE7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXRlRGF0YSA9IGRlY29kZURhdGEoc3RhdGUgYXMgc3RyaW5nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0YXRlIHBhcmFtZXRlclwiLCBlKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwiSW52YWxpZCBzdGF0ZSBwYXJhbWV0ZXJcIiB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlZGlyZWN0VXJpLCBjbGllbnRTdGF0ZSwgY2xpZW50SWQsIHNlcnZlcklkLCBzY29wZSwgcHJvdmlkZXJJZCB9ID0gc3RhdGVEYXRhO1xuXG4gICAgaWYgKHN0YXRlRGF0YS5zY29wZSA9PT0gVE9PTF9TQ09QRSAmJiBwcm92aWRlcklkKSB7XG4gICAgICByZXEubG9nZ2VyLmRlYnVnKFwiRXhjaGFuZ2luZyBjb2RlIGZvciB0b2tlbiB3aXRoIHByb3ZpZGVyIGZvciB0b29sIHNjb3BlXCIpO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCByZXEuZGIub0F1dGhQcm92aWRlci5maW5kRmlyc3RPclRocm93KHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBpZDogcHJvdmlkZXJJZCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdG9rZW5EYXRhID0gYXdhaXQgZXhjaGFuZ2VDb2RlRm9yVG9rZW4ocmVxLmxvZ2dlciwgcHJvdmlkZXIsIGNvZGUgYXMgc3RyaW5nLCBjYWxsYmFja1VybChyZXEpKTtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IHN0YXRlRGF0YS51c2VySWQhO1xuICAgICAgYXdhaXQgcGVyc2lzdFRva2VuKHJlcS5kYiwgcmVxLmxvZ2dlciwgdXNlcklkLCBwcm92aWRlcklkLCB0b2tlbkRhdGEsIHN0YXRlRGF0YS5vcmlnaW5BZGRyZXNzKTtcbiAgICAgIGlmIChzdGF0ZURhdGEucmVkaXJlY3RVcmkpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSBuZXcgVVJMKHN0YXRlRGF0YS5yZWRpcmVjdFVyaSk7XG4gICAgICAgIHJlZGlyZWN0VXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJzdGF0ZVwiLCBzdGF0ZURhdGEuY2xpZW50U3RhdGUpO1xuICAgICAgICByZXR1cm4gcmVzLnJlZGlyZWN0KHJlZGlyZWN0VXJsLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZWRpcmVjdChgJHtDT05TT0xFX1VSTH0ke0NPTlNPTEVfU1VDQ0VTU19QQVRIfWApO1xuICAgIH1cblxuICAgIGlmICghcmVkaXJlY3RVcmkpIHtcbiAgICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJTdGF0ZSBwYXJhbWV0ZXIgbWlzc2luZyByZWRpcmVjdFVyaVwiKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwiSW52YWxpZCBzdGF0ZSBwYXJhbWV0ZXIgc3RydWN0dXJlXCIgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVkaXJlY3RVcmwgPSBuZXcgVVJMKHJlZGlyZWN0VXJpKTtcbiAgICByZWRpcmVjdFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicG9zdEF1dGhSZWRpcmVjdFVyaVwiLCBgJHtDT05TT0xFX1VSTH0ke0NPTlNPTEVfU1VDQ0VTU19QQVRIfWApO1xuXG4gICAgaWYgKHNjb3BlID09PSBFTkRVU0VSX1NDT1BFKSB7XG4gICAgICBjb25zdCBzaG9ydFNlc3Npb24gPSBkZWNvZGVEYXRhPEVuZFVzZXJTaG9ydFNlc3Npb24+KGNvZGUgYXMgc3RyaW5nKTtcbiAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IGF3YWl0IGVuZHVzZXJTaGFyZWRTZWNyZXQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgTWF0aC5hYnMoRGF0ZS5ub3coKSAtIHNob3J0U2Vzc2lvbi50aW1lc3RhbXApID4gU0lHTkFUVVJFX0VYUElSQVRJT05fTVNFQyB8fFxuICAgICAgICBzaWduRGF0YShzaGFyZWRTZWNyZXQsIGAke3Nob3J0U2Vzc2lvbi5lbWFpbH0uJHtzaG9ydFNlc3Npb24udGltZXN0YW1wfWApICE9PSBzaG9ydFNlc3Npb24uc2lnbmF0dXJlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuVU5BVVRIT1JJWkVEKS5qc29uKHsgZXJyb3I6IFwiSW52YWxpZCBvciBleHBpcmVkIHNob3J0IHNlc3Npb24gc2lnbmF0dXJlXCIgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGp0aSA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0RW5kVXNlckJ5RW1haWxBbmRTZXJ2ZXJJZChyZXEuZGIsIHNob3J0U2Vzc2lvbi5lbWFpbCwgc3RhdGVEYXRhLnNlcnZlcklkISk7XG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgZXJyb3I6IFwiVXNlciBub3QgZm91bmRcIiB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2VuZXJhdGVFbmRVc2VyVG9rZW4odXNlciwganRpKTtcblxuICAgICAgYXdhaXQgcGVyc2lzdFRva2VuKFxuICAgICAgICByZXEuZGIsXG4gICAgICAgIHJlcS5sb2dnZXIsXG4gICAgICAgIHVzZXIuaWQsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHtcbiAgICAgICAgICBhY2Nlc3NUb2tlbjogdG9rZW4sXG4gICAgICAgICAgc2NvcGU6IEVORFVTRVJfU0NPUEUsXG4gICAgICAgICAgZXhwaXJlc0luOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgICBzdGF0ZURhdGEub3JpZ2luQWRkcmVzcyxcbiAgICAgICAganRpLFxuICAgICAgKTtcbiAgICAgIGNsZWFyQ2FjaGVCeVBhcnRpYWxLZXkoQ2FjaGVJdGVtVHlwZS5FTkRVU0VSX1RPS0VOLCB1c2VyLmVtYWlsKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhOiBFbmRVc2VyVG9rZW5SZXNwb25zZSA9IHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlbixcbiAgICAgICAgb3JpZ2luYWxfcmVkaXJlY3RfdXJpOiBzdGF0ZURhdGEucmVkaXJlY3RVcmksXG4gICAgICAgIHRva2VuX3R5cGU6IFwiQmVhcmVyXCIsXG4gICAgICB9O1xuICAgICAgY29uc3QgdG9rZW5Bc0NvZGUgPSBlbmNvZGVEYXRhKHJlc3BvbnNlRGF0YSk7XG4gICAgICByZWRpcmVjdFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY29kZVwiLCB0b2tlbkFzQ29kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc2VydmVySWQpIHtcbiAgICAgICAgcmVxLmxvZ2dlci5lcnJvcihcIlN0YXRlIHBhcmFtZXRlciBtaXNzaW5nIHNlcnZlcklkXCIpO1xuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBcIkludmFsaWQgc3RhdGUgcGFyYW1ldGVyIHN0cnVjdHVyZVwiIH0pO1xuICAgICAgfVxuXG4gICAgICByZXEubG9nZ2VyLmRlYnVnKFwiT0F1dGggY2FsbGJhY2sgcmVjZWl2ZWRcIiwge1xuICAgICAgICByZWRpcmVjdFVyaSxcbiAgICAgICAgY2xpZW50U3RhdGUsXG4gICAgICAgIGNsaWVudElkLFxuICAgICAgICBzZXJ2ZXJJZCxcbiAgICAgICAgY29kZVJlY2VpdmVkOiAhIWNvZGUsXG4gICAgICB9KTtcblxuICAgICAgcmVkaXJlY3RVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImNvZGVcIiwgY29kZSBhcyBzdHJpbmcpO1xuICAgIH1cblxuICAgIGlmIChjbGllbnRTdGF0ZSkge1xuICAgICAgcmVkaXJlY3RVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInN0YXRlXCIsIGNsaWVudFN0YXRlIGFzIHN0cmluZyk7XG4gICAgfVxuXG4gICAgaWYgKGNsaWVudElkKSB7XG4gICAgICByZWRpcmVjdFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiY2xpZW50X2lkXCIsIGNsaWVudElkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLnJlZGlyZWN0KHJlZGlyZWN0VXJsLnRvU3RyaW5nKCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJFcnJvciBpbiBPQXV0aCBjYWxsYmFjayBoYW5kbGluZ1wiLCBlcnJvcik7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgT0F1dGhFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBwcm9jZXNzIE9BdXRoIGNhbGxiYWNrXCI7XG4gICAgcmV0dXJuIHJlcy5yZWRpcmVjdChgJHtDT05TT0xFX1VSTH0ke0NPTlNPTEVfRkFJTFVSRV9QQVRIfT9lcnJvcj0ke2VuY29kZVVSSUNvbXBvbmVudChtZXNzYWdlKX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGV4Y2hhbmdlVG9rZW4gPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgY29kZSB9ID0gcmVxLmJvZHk7XG4gICAgaWYgKCFjb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgT0F1dGhFcnJvcihcIk1pc3NpbmcgY29kZVwiLCBTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCwgXCJpbnZhbGlkX3JlcXVlc3RcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlZFJlc3BvbnNlID0gZGVjb2RlRGF0YShjb2RlIGFzIHN0cmluZyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKGRlY29kZWRSZXNwb25zZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkVycm9yIGluIHRva2VuIGV4Y2hhbmdlXCIsIGVycm9yKTtcbiAgICBpZiAoYXhpb3MuaXNBeGlvc0Vycm9yKGVycm9yKSAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoZXJyb3IucmVzcG9uc2Uuc3RhdHVzKS5qc29uKGVycm9yLnJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gZXhjaGFuZ2UgdG9rZW5cIiB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGR5bmFtaWNDbGllbnRSZWdpc3RlciA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FwcFJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHRyeSB7XG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhcIk9BdXRoIGNsaWVudCByZWdpc3RyYXRpb24gcmVxdWVzdCByZWNlaXZlZFwiLCB7XG4gICAgICBib2R5OiByZXEuYm9keSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGNsaWVudF9pZCxcbiAgICAgIGNsaWVudF9uYW1lID0gXCJEeW5hbWljYWxseSBSZWdpc3RlcmVkIENsaWVudFwiLFxuICAgICAgcmVkaXJlY3RfdXJpcyA9IFtdLFxuICAgICAgZ3JhbnRfdHlwZXMgPSBbXCJhdXRob3JpemF0aW9uX2NvZGVcIl0sXG4gICAgICByZXNwb25zZV90eXBlcyA9IFtcImNvZGVcIl0sXG4gICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCA9IFwibm9uZVwiLFxuICAgICAgc29mdHdhcmVfaWQsXG4gICAgfSA9IHJlcS5ib2R5O1xuXG4gICAgaWYgKCFyZWRpcmVjdF91cmlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJpbnZhbGlkX3JlZGlyZWN0X3VyaVwiLFxuICAgICAgICBlcnJvcl9kZXNjcmlwdGlvbjogXCJBdCBsZWFzdCBvbmUgcmVkaXJlY3RfdXJpIG11c3QgYmUgcHJvdmlkZWRcIixcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzUmVkaXJlY3RVcmlBbGxvd2VkKHJlcSwgcmVkaXJlY3RfdXJpcykpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHtcbiAgICAgICAgZXJyb3I6IFwiaW52YWxpZF9yZWRpcmVjdF91cmlcIixcbiAgICAgICAgZXJyb3JfZGVzY3JpcHRpb246IFwiUmVkaXJlY3QgVVJJIG11c3QgYmUgb25lIG9mIHRoZSBhbGxvd2VkIG9yaWdpbnNcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZ2lzdHJhdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNsaWVudElkID0gY2xpZW50X2lkIHx8IGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoXCJoZXhcIik7XG5cbiAgICBjb25zdCBjbGllbnQgPSB7XG4gICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgY2xpZW50X3NlY3JldDogXCJcIiwgLy8gTm8gY2xpZW50IHNlY3JldCBmb3IgcHVibGljIGNsaWVudHNcbiAgICAgIGNsaWVudF9uYW1lLFxuICAgICAgcmVkaXJlY3RfdXJpczogQXJyYXkuaXNBcnJheShyZWRpcmVjdF91cmlzKSA/IHJlZGlyZWN0X3VyaXMgOiBbcmVkaXJlY3RfdXJpc10sXG4gICAgICBncmFudF90eXBlczogQXJyYXkuaXNBcnJheShncmFudF90eXBlcykgPyBncmFudF90eXBlcyA6IFtncmFudF90eXBlc10sXG4gICAgICByZXNwb25zZV90eXBlczogQXJyYXkuaXNBcnJheShyZXNwb25zZV90eXBlcykgPyByZXNwb25zZV90eXBlcyA6IFtyZXNwb25zZV90eXBlc10sXG4gICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCxcbiAgICAgIHJlZ2lzdHJhdGlvbl90aW1lOiByZWdpc3RyYXRpb25UaW1lLFxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAuLi5jbGllbnQsXG4gICAgICBjbGllbnRfaWRfaXNzdWVkX2F0OiBNYXRoLmZsb29yKHJlZ2lzdHJhdGlvblRpbWUgLyAxMDAwKSxcbiAgICB9O1xuXG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhcIk5ldyBPQXV0aCBjbGllbnQgcmVnaXN0ZXJlZFwiLCB7XG4gICAgICBjbGllbnRJZCxcbiAgICAgIGNsaWVudE5hbWU6IGNsaWVudF9uYW1lLFxuICAgICAgc29mdHdhcmVJZDogc29mdHdhcmVfaWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5DUkVBVEVEKS5qc29uKHJlc3BvbnNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRXJyb3IgaW4gcmVnaXN0cmF0aW9uIGVuZHBvaW50XCIsIGVycm9yKTtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gcHJvY2VzcyByZWdpc3RyYXRpb24gcmVxdWVzdFwiIH0pO1xuICB9XG59O1xuIiwgImltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSBcIi4uL3V0aWxzL2Nvbm5lY3Rpb24uanNcIjtcblxuY29uc3QgZ2V0U2VydmVyQnlJZCA9IGFzeW5jIChkYjogRGF0YWJhc2UsIHNlcnZlcklkOiBzdHJpbmcpID0+XG4gIGF3YWl0IGRiLm1jcFNlcnZlci5maW5kVW5pcXVlKHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IHNlcnZlcklkLFxuICAgIH0sXG4gIH0pO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRW5kVXNlcklmTm90RXhpc3RzKGRiOiBEYXRhYmFzZSwgdGVuYW50SWQ6IHN0cmluZywgZW1haWw6IHN0cmluZykge1xuICByZXR1cm4gZGIuZW5kVXNlci51cHNlcnQoe1xuICAgIHdoZXJlOiB7XG4gICAgICBlbWFpbF90ZW5hbnRJZDoge1xuICAgICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgdGVuYW50SWQ6IHRlbmFudElkLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHVwZGF0ZToge30sXG4gICAgY3JlYXRlOiB7XG4gICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgIHRlbmFudElkOiB0ZW5hbnRJZCxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXRFbmRVc2VyT3duSWREYXRhKGRiOiBEYXRhYmFzZSwgc2VydmVySWQ6IHN0cmluZywgZW1haWw6IHN0cmluZywgb3duSWREYXRhOiBzdHJpbmcpIHtcbiAgY29uc3Qgc2VydmVyID0gYXdhaXQgZ2V0U2VydmVyQnlJZChkYiwgc2VydmVySWQpO1xuXG4gIGlmICghc2VydmVyKSB7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcIk5PVF9GT1VORFwiLCBlcnJvcjogXCJTZXJ2ZXIgbm90IGZvdW5kXCIgfTtcbiAgfVxuXG4gIGF3YWl0IGRiLmVuZFVzZXIudXBzZXJ0KHtcbiAgICB3aGVyZToge1xuICAgICAgZW1haWxfdGVuYW50SWQ6IHtcbiAgICAgICAgZW1haWw6IGVtYWlsLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHRlbmFudElkOiBzZXJ2ZXIudGVuYW50SWQsXG4gICAgICB9LFxuICAgIH0sXG4gICAgdXBkYXRlOiB7XG4gICAgICBvd25pZERhdGE6IG93bklkRGF0YSxcbiAgICB9LFxuICAgIGNyZWF0ZToge1xuICAgICAgZW1haWw6IGVtYWlsLnRvTG93ZXJDYXNlKCksXG4gICAgICB0ZW5hbnRJZDogc2VydmVyLnRlbmFudElkLFxuICAgICAgb3duaWREYXRhOiBvd25JZERhdGEsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiB7IHN0YXR1czogXCJOT19DT05URU5UXCIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVuZFVzZXJPd25JZERhdGEoZGI6IERhdGFiYXNlLCBzZXJ2ZXJJZDogc3RyaW5nLCBlbWFpbDogc3RyaW5nKSB7XG4gIGNvbnN0IHNlcnZlciA9IGF3YWl0IGdldFNlcnZlckJ5SWQoZGIsIHNlcnZlcklkKTtcblxuICBpZiAoIXNlcnZlcikge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJOT1RfRk9VTkRcIiwgZXJyb3I6IFwiU2VydmVyIG5vdCBmb3VuZFwiIH07XG4gIH1cblxuICBjb25zdCB1c2VyID0gYXdhaXQgZGIuZW5kVXNlci5maW5kVW5pcXVlKHtcbiAgICB3aGVyZToge1xuICAgICAgZW1haWxfdGVuYW50SWQ6IHtcbiAgICAgICAgZW1haWw6IGVtYWlsLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHRlbmFudElkOiBzZXJ2ZXIudGVuYW50SWQsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuXG4gIGlmICghdXNlcikge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJOT19DT05URU5UXCIgfTtcbiAgfVxuXG4gIGlmICghdXNlci5lbmFibGVkKSB7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcIkxPQ0tFRFwiLCBlcnJvcjogXCJVc2VyIG5vdCBlbmFibGVkXCIgfTtcbiAgfVxuXG4gIGlmICh1c2VyLm93bmlkRGF0YSkge1xuICAgIHJldHVybiB7IHN0YXR1czogXCJPS1wiLCBkYXRhOiB7IG93bklkRGF0YTogdXNlci5vd25pZERhdGEgfSB9O1xuICB9XG5cbiAgcmV0dXJuIHsgc3RhdHVzOiBcIk5PX0NPTlRFTlRcIiB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRW5kVXNlclNlc3Npb24oXG4gIGRiOiBEYXRhYmFzZSxcbiAgc2VydmVySWQ6IHN0cmluZyxcbiAgZW1haWw6IHN0cmluZyxcbiAgY3JlYXRlVG9rZW46ICgpID0+IFByb21pc2U8c3RyaW5nPixcbikge1xuICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCBnZXRTZXJ2ZXJCeUlkKGRiLCBzZXJ2ZXJJZCk7XG5cbiAgaWYgKCFzZXJ2ZXIpIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwiTk9UX0ZPVU5EXCIsIGVycm9yOiBcIlNlcnZlciBub3QgZm91bmRcIiB9O1xuICB9XG5cbiAgYXdhaXQgZGIuZW5kVXNlci51cHNlcnQoe1xuICAgIHdoZXJlOiB7XG4gICAgICBlbWFpbF90ZW5hbnRJZDoge1xuICAgICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgdGVuYW50SWQ6IHNlcnZlci50ZW5hbnRJZCxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB1cGRhdGU6IHt9LFxuICAgIGNyZWF0ZToge1xuICAgICAgZW1haWw6IGVtYWlsLnRvTG93ZXJDYXNlKCksXG4gICAgICBlbWFpbFZlcmlmaWVkOiB0cnVlLFxuICAgICAgdGVuYW50SWQ6IHNlcnZlci50ZW5hbnRJZCxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIHsgc3RhdHVzOiBcIk9LXCIsIGRhdGE6IHsgdG9rZW46IGF3YWl0IGNyZWF0ZVRva2VuKCkgfSB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0RW5kVXNlckJ5RW1haWxBbmRTZXJ2ZXJJZCA9IGFzeW5jIChkYjogRGF0YWJhc2UsIGVtYWlsOiBzdHJpbmcsIHNlcnZlcklkOiBzdHJpbmcpID0+IHtcbiAgY29uc3Qgc2VydmVyID0gYXdhaXQgZ2V0U2VydmVyQnlJZChkYiwgc2VydmVySWQpO1xuICBpZiAoIXNlcnZlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBhd2FpdCBkYi5lbmRVc2VyLmZpbmRVbmlxdWUoe1xuICAgIHdoZXJlOiB7XG4gICAgICBlbWFpbF90ZW5hbnRJZDoge1xuICAgICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgdGVuYW50SWQ6IHNlcnZlci50ZW5hbnRJZCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59O1xuIiwgImltcG9ydCAqIGFzIGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgeyBnZXRBcHBTZWNyZXRzIH0gZnJvbSBcIi4vc2VjcmV0cy5zZXJ2aWNlLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBTSUdOQVRVUkVfRVhQSVJBVElPTl9NU0VDID0gNjAgKiAxMDAwOyAvLyAxIG1pbnV0ZVxuXG5leHBvcnQgY29uc3QgYWRtaW5TaGFyZWRTZWNyZXQgPSBhc3luYyAoKSA9PlxuICBwcm9jZXNzLmVudi5PV05JRF9BRE1JTl9TSEFSRURfU0VDUkVUIHx8IChhd2FpdCBnZXRBcHBTZWNyZXRzKCkpLm93bmlkQWRtaW5TaGFyZWRTZWNyZXQ7XG5leHBvcnQgY29uc3QgZW5kdXNlclNoYXJlZFNlY3JldCA9IGFzeW5jICgpID0+XG4gIHByb2Nlc3MuZW52Lk9XTklEX0VORFVTRVJfU0hBUkVEX1NFQ1JFVCB8fCAoYXdhaXQgZ2V0QXBwU2VjcmV0cygpKS5vd25pZEVuZHVzZXJTaGFyZWRTZWNyZXQ7XG5leHBvcnQgY29uc3QgYW50aHJvcGljQXBpS2V5ID0gYXN5bmMgKCkgPT4gcHJvY2Vzcy5lbnYuQU5USFJPUElDX0FQSV9LRVkgfHwgKGF3YWl0IGdldEFwcFNlY3JldHMoKSkuYW50aHJvcGljQXBpS2V5O1xuZXhwb3J0IGNvbnN0IG9wZW5haUFwaUtleSA9IGFzeW5jICgpID0+IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZIHx8IChhd2FpdCBnZXRBcHBTZWNyZXRzKCkpLm9wZW5haUFwaUtleTtcblxuZXhwb3J0IGNvbnN0IHNpZ25EYXRhID0gKHNoYXJlZFNlY3JldDogc3RyaW5nLCBkYXRhOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIEJ1ZmZlci5mcm9tKHNoYXJlZFNlY3JldCwgXCJiYXNlNjRcIikpO1xuICBobWFjLnVwZGF0ZShkYXRhKTtcbiAgcmV0dXJuIGhtYWMuZGlnZXN0KFwiYmFzZTY0XCIpO1xufTtcbiIsICJpbXBvcnQgZXhwcmVzcyBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgY29uZmlnLCBjcmVhdGVTZXNzaW9uLCBnZXREYXRhLCBzZXREYXRhIH0gZnJvbSBcIi4uL2NvbnRyb2xsZXJzL293bmlkLmNvbnRyb2xsZXIuanNcIjtcbmltcG9ydCB7IG93bmlkQWRtaW5NaWRkbGV3YXJlLCBvd25pZEVuZFVzZXJNaWRkbGV3YXJlIH0gZnJvbSBcIi4uL21pZGRsZXdhcmVzL293bmlkLm1pZGRsZXdhcmUuanNcIjtcblxuY29uc3Qgcm91dGVyID0gZXhwcmVzcy5Sb3V0ZXIoKTtcblxucm91dGVyLmdldChcIi9jb25maWdcIiwgY29uZmlnKTtcblxucm91dGVyLnBvc3QoXCIvYWRtaW4vc2V0T3duSUREYXRhQnlMb2dpbklkXCIsIG93bmlkQWRtaW5NaWRkbGV3YXJlLCBzZXREYXRhKTtcbnJvdXRlci5wb3N0KFwiL2FkbWluL2dldE93bklERGF0YUJ5TG9naW5JZFwiLCBvd25pZEFkbWluTWlkZGxld2FyZSwgZ2V0RGF0YSk7XG5yb3V0ZXIucG9zdChcIi9hZG1pbi9nZXRTZXNzaW9uQnlMb2dpbklkXCIsIG93bmlkQWRtaW5NaWRkbGV3YXJlLCBjcmVhdGVTZXNzaW9uKTtcblxucm91dGVyLnBvc3QoXCIvZW5kdXNlci9zZXRPd25JRERhdGFCeUxvZ2luSWRcIiwgb3duaWRFbmRVc2VyTWlkZGxld2FyZSwgc2V0RGF0YSk7XG5yb3V0ZXIucG9zdChcIi9lbmR1c2VyL2dldE93bklERGF0YUJ5TG9naW5JZFwiLCBvd25pZEVuZFVzZXJNaWRkbGV3YXJlLCBnZXREYXRhKTtcbnJvdXRlci5wb3N0KFwiL2VuZHVzZXIvZ2V0U2Vzc2lvbkJ5TG9naW5JZFwiLCBvd25pZEVuZFVzZXJNaWRkbGV3YXJlLCBjcmVhdGVTZXNzaW9uKTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIiwgImltcG9ydCB7IE93bklkQ29uZmlnIH0gZnJvbSBcIkBhZ2VudGJyaWRnZS9hcGlcIjtcbmltcG9ydCB7IFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IFN0YXR1c0NvZGVzIH0gZnJvbSBcImh0dHAtc3RhdHVzLWNvZGVzXCI7XG5pbXBvcnQgeyBjcmVhdGVBZG1pblNlc3Npb24sIGdldEFkbWluT3duSWREYXRhLCBzZXRBZG1pbk93bklkRGF0YSB9IGZyb20gXCIuLi9zZXJ2aWNlcy9hZG1pbnMuc2VydmljZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlRW5kVXNlclNlc3Npb24sIGdldEVuZFVzZXJPd25JZERhdGEsIHNldEVuZFVzZXJPd25JZERhdGEgfSBmcm9tIFwiLi4vc2VydmljZXMvZW5kdXNlci5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVEYXRhIH0gZnJvbSBcIi4uL3NlcnZpY2VzL29hdXRoLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IGVuZHVzZXJTaGFyZWRTZWNyZXQsIHNpZ25EYXRhIH0gZnJvbSBcIi4uL3NlcnZpY2VzL293bmlkLnNlY3JldC5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBpc0FwcFJlcXVlc3QsIFR5cGVHdWFyZEVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL3JlcS1ndWFyZHMuanNcIjtcblxuZXhwb3J0IHR5cGUgRW5kVXNlclNob3J0U2Vzc2lvbiA9IHtcbiAgZW1haWw6IHN0cmluZztcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgY29uc3Qgc2VydmVySWQgPSByZXEucXVlcnkuc2VydmVyX2lkIGFzIHN0cmluZyB8IG51bGw7XG4gIGNvbnN0IGNvbmZpZzogT3duSWRDb25maWcgPSBzZXJ2ZXJJZFxuICAgID8ge1xuICAgICAgICBhcHBJZDogcHJvY2Vzcy5lbnYuT1dOSURfRU5EVVNFUl9BUFBfSUQgYXMgc3RyaW5nLFxuICAgICAgICBlbnY6IHByb2Nlc3MuZW52Lk9XTklEX0VORFVTRVJfRU5WIGFzIE93bklkQ29uZmlnLmVudixcbiAgICAgIH1cbiAgICA6IHtcbiAgICAgICAgYXBwSWQ6IHByb2Nlc3MuZW52Lk9XTklEX0FETUlOX0FQUF9JRCBhcyBzdHJpbmcsXG4gICAgICAgIGVudjogcHJvY2Vzcy5lbnYuT1dOSURfQURNSU5fRU5WIGFzIE93bklkQ29uZmlnLmVudixcbiAgICAgIH07XG4gIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuT0spLmpzb24oY29uZmlnKTtcbn07XG5cbmNvbnN0IGdldFNlcnZlcklkID0gKHJlcTogUmVxdWVzdCkgPT4ge1xuICByZXR1cm4gcmVxLmhlYWRlcnNbXCJ4LW93bmlkLXNjb3BlXCJdIGFzIHN0cmluZyB8IG51bGw7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0RGF0YSA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FwcFJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIGNvbnN0IGVtYWlsID0gcmVxLmJvZHkubG9naW5JZC50b0xvd2VyQ2FzZSgpIGFzIHN0cmluZztcbiAgY29uc3Qgb3duSWREYXRhID0gcmVxLmJvZHkub3duSWREYXRhIGFzIHN0cmluZztcbiAgY29uc3Qgc2VydmVySWQgPSBnZXRTZXJ2ZXJJZChyZXEpO1xuXG4gIHJlcS5sb2dnZXIuZGVidWcoXCJTZXR0aW5nIG93bmlkIGRhdGFcIiwge1xuICAgIGVtYWlsOiBlbWFpbCxcbiAgICBvd25JZERhdGE6IG93bklkRGF0YSxcbiAgICBzZXJ2ZXJJZCxcbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gc2VydmVySWRcbiAgICA/IGF3YWl0IHNldEVuZFVzZXJPd25JZERhdGEocmVxLmRiLCBzZXJ2ZXJJZCwgZW1haWwsIG93bklkRGF0YSlcbiAgICA6IGF3YWl0IHNldEFkbWluT3duSWREYXRhKHJlcS5kYiwgZW1haWwsIG93bklkRGF0YSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSBcIk5PVF9GT1VORFwiKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgfVxuICByZXR1cm4gcmVzLnNlbmRTdGF0dXMoU3RhdHVzQ29kZXMuTk9fQ09OVEVOVCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RGF0YSA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FwcFJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIGNvbnN0IGVtYWlsID0gcmVxLmJvZHkubG9naW5JZC50b0xvd2VyQ2FzZSgpIGFzIHN0cmluZztcbiAgY29uc3Qgc2VydmVySWQgPSBnZXRTZXJ2ZXJJZChyZXEpO1xuXG4gIHJlcS5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIG93bmlkIGRhdGFcIiwge1xuICAgIGVtYWlsLFxuICAgIHNlcnZlcklkLFxuICB9KTtcblxuICBjb25zdCByZXN1bHQgPSBzZXJ2ZXJJZFxuICAgID8gYXdhaXQgZ2V0RW5kVXNlck93bklkRGF0YShyZXEuZGIsIHNlcnZlcklkLCBlbWFpbClcbiAgICA6IGF3YWl0IGdldEFkbWluT3duSWREYXRhKHJlcS5kYiwgcmVxLmxvZ2dlciwgZW1haWwpO1xuXG4gIHN3aXRjaCAocmVzdWx0LnN0YXR1cykge1xuICAgIGNhc2UgXCJOT1RfRk9VTkRcIjpcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk5PVF9GT1VORCkuanNvbih7IGVycm9yOiByZXN1bHQuZXJyb3IgfSk7XG4gICAgY2FzZSBcIkxPQ0tFRFwiOlxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTE9DS0VEKS5qc29uKHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICBjYXNlIFwiT0tcIjpcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk9LKS5qc29uKHJlc3VsdC5kYXRhKTtcbiAgICBjYXNlIFwiTk9fQ09OVEVOVFwiOlxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9fQ09OVEVOVCkuc2VuZCgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc3RhdHVzOiAke3Jlc3VsdC5zdGF0dXN9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUVuZFVzZXJTZXNzaW9uU2lnbmF0dXJlID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcpID0+IHtcbiAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gYXdhaXQgZW5kdXNlclNoYXJlZFNlY3JldCgpO1xuICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICBjb25zdCBkYXRhOiBFbmRVc2VyU2hvcnRTZXNzaW9uID0ge1xuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgIGVtYWlsLFxuICAgIHNpZ25hdHVyZTogc2lnbkRhdGEoc2hhcmVkU2VjcmV0LCBgJHtlbWFpbH0uJHt0aW1lc3RhbXB9YCksXG4gIH07XG4gIHJldHVybiBlbmNvZGVEYXRhKGRhdGEpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlc3Npb24gPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuICBjb25zdCBlbWFpbCA9IHJlcS5ib2R5LmxvZ2luSWQudG9Mb3dlckNhc2UoKSBhcyBzdHJpbmc7XG4gIGNvbnN0IHNlcnZlcklkID0gZ2V0U2VydmVySWQocmVxKTtcblxuICByZXEubG9nZ2VyLmRlYnVnKFwiQ3JlYXRpbmcgc2Vzc2lvblwiLCB7XG4gICAgZW1haWwsXG4gICAgc2VydmVySWQsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHNlcnZlcklkXG4gICAgPyBhd2FpdCBjcmVhdGVFbmRVc2VyU2Vzc2lvbihyZXEuZGIsIHNlcnZlcklkLCBlbWFpbCwgKCkgPT4gY3JlYXRlRW5kVXNlclNlc3Npb25TaWduYXR1cmUoZW1haWwpKVxuICAgIDogYXdhaXQgY3JlYXRlQWRtaW5TZXNzaW9uKHJlcS5kYiwgcmVxLmxvZ2dlciwgZW1haWwpO1xuXG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSBcIk5PVF9GT1VORFwiKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgfVxuXG4gIHJldHVybiByZXMuanNvbihyZXN1bHQuZGF0YSk7XG59O1xuIiwgImltcG9ydCB7IE5leHRGdW5jdGlvbiwgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgU3RhdHVzQ29kZXMgfSBmcm9tIFwiaHR0cC1zdGF0dXMtY29kZXNcIjtcbmltcG9ydCB7XG4gIGFkbWluU2hhcmVkU2VjcmV0LFxuICBlbmR1c2VyU2hhcmVkU2VjcmV0LFxuICBTSUdOQVRVUkVfRVhQSVJBVElPTl9NU0VDLFxuICBzaWduRGF0YSxcbn0gZnJvbSBcIi4uL3NlcnZpY2VzL293bmlkLnNlY3JldC5zZXJ2aWNlLmpzXCI7XG5cbmNvbnN0IG93bmlkTWlkZGxld2FyZSA9IChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UsIG5leHQ6IE5leHRGdW5jdGlvbiwgc2hhcmVkU2VjcmV0OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcS5ib2R5KTtcbiAgY29uc3Qgb3duSWRTaWduYXR1cmUgPSByZXEuaGVhZGVyc1tcIm93bmlkLXNpZ25hdHVyZVwiXSBhcyBzdHJpbmc7XG4gIGNvbnN0IG93bklkVGltZXN0YW1wID0gcmVxLmhlYWRlcnNbXCJvd25pZC10aW1lc3RhbXBcIl0gYXMgc3RyaW5nO1xuICBpZiAoIW93bklkU2lnbmF0dXJlIHx8ICFvd25JZFRpbWVzdGFtcCkge1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogXCJNaXNzaW5nIE93bklEIHNpZ25hdHVyZSBvciB0aW1lc3RhbXBcIiB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGF0YVRvU2lnbiA9IGAke2JvZHl9LiR7b3duSWRUaW1lc3RhbXB9YDtcblxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG5cbiAgY29uc3Qgb3duSWRUaW1lc3RhbXBNcyA9IHBhcnNlSW50KG93bklkVGltZXN0YW1wKTtcblxuICBpZiAoTWF0aC5hYnMoY3VycmVudFRpbWUgLSBvd25JZFRpbWVzdGFtcE1zKSA+IFNJR05BVFVSRV9FWFBJUkFUSU9OX01TRUMpIHtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwiU2lnbmF0dXJlIGhhcyBleHBpcmVkXCIgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYWN0dWFsU2lnbmF0dXJlID0gc2lnbkRhdGEoc2hhcmVkU2VjcmV0LCBkYXRhVG9TaWduKTtcbiAgaWYgKGFjdHVhbFNpZ25hdHVyZSAhPT0gb3duSWRTaWduYXR1cmUpIHtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwiSW52YWxpZCBzaWduYXR1cmVcIiB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBuZXh0KCk7XG59O1xuXG5leHBvcnQgY29uc3Qgb3duaWRBZG1pbk1pZGRsZXdhcmUgPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlLCBuZXh0OiBOZXh0RnVuY3Rpb24pID0+IHtcbiAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gYXdhaXQgYWRtaW5TaGFyZWRTZWNyZXQoKTtcbiAgcmV0dXJuIG93bmlkTWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgc2hhcmVkU2VjcmV0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBvd25pZEVuZFVzZXJNaWRkbGV3YXJlID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSwgbmV4dDogTmV4dEZ1bmN0aW9uKSA9PiB7XG4gIGNvbnN0IHNoYXJlZFNlY3JldCA9IGF3YWl0IGVuZHVzZXJTaGFyZWRTZWNyZXQoKTtcbiAgcmV0dXJuIG93bmlkTWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgc2hhcmVkU2VjcmV0KTtcbn07XG4iLCAiaW1wb3J0IHsgUm91dGVyIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZVByb3ZpZGVyLFxuICBkZWxldGVQcm92aWRlcixcbiAgZ2V0UHJvdmlkZXIsXG4gIGdldFByb3ZpZGVycyxcbiAgdXBkYXRlUHJvdmlkZXIsXG59IGZyb20gXCIuLi9jb250cm9sbGVycy9vYXV0aC1wcm92aWRlcnMuY29udHJvbGxlci5qc1wiO1xuXG5jb25zdCByb3V0ZXI6IFJvdXRlciA9IFJvdXRlcigpO1xuXG5yb3V0ZXIuZ2V0KFwiL1wiLCBnZXRQcm92aWRlcnMpO1xucm91dGVyLnBvc3QoXCIvXCIsIGNyZWF0ZVByb3ZpZGVyKTtcbnJvdXRlci5nZXQoXCIvOnByb3ZpZGVySWRcIiwgZ2V0UHJvdmlkZXIpO1xucm91dGVyLnB1dChcIi86cHJvdmlkZXJJZFwiLCB1cGRhdGVQcm92aWRlcik7XG5yb3V0ZXIuZGVsZXRlKFwiLzpwcm92aWRlcklkXCIsIGRlbGV0ZVByb3ZpZGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIiwgImltcG9ydCB7IENyZWF0ZVByb3ZpZGVyUmVxdWVzdCwgT0F1dGhQcm92aWRlciwgVXBkYXRlUHJvdmlkZXJSZXF1ZXN0IH0gZnJvbSBcIkBhZ2VudGJyaWRnZS9hcGlcIjtcbmltcG9ydCB7IE9BdXRoUHJvdmlkZXIgYXMgUHJpc21hT0F1dGhQcm92aWRlciB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgU3RhdHVzQ29kZXMgfSBmcm9tIFwiaHR0cC1zdGF0dXMtY29kZXNcIjtcbmltcG9ydCBvbWl0IGZyb20gXCJsb2Rhc2gvb21pdC5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQUdFX1NJWkUgfSBmcm9tIFwiLi4vdXRpbHMvY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBpc0FkbWluUmVxdWVzdCwgVHlwZUd1YXJkRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5jb25zdCBtYXBQcm92aWRlciA9IChwcm92aWRlcjogUHJpc21hT0F1dGhQcm92aWRlcik6IE9BdXRoUHJvdmlkZXIgPT4gKHtcbiAgLi4ub21pdChwcm92aWRlciwgW1wiY2xpZW50U2VjcmV0XCJdKSxcbiAgY29udGVudFR5cGU6IHByb3ZpZGVyLmNvbnRlbnRUeXBlIHx8IHVuZGVmaW5lZCxcbiAgcmVmcmVzaFVybDogcHJvdmlkZXIucmVmcmVzaFVybCB8fCB1bmRlZmluZWQsXG4gIGNyZWF0ZWRBdDogcHJvdmlkZXIuY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gIHVwZGF0ZWRBdDogcHJvdmlkZXIudXBkYXRlZEF0LnRvSVNPU3RyaW5nKCksXG59KTtcblxuZXhwb3J0IGNvbnN0IGdldFByb3ZpZGVycyA9IGFzeW5jIChcbiAgcmVxOiBSZXF1ZXN0PFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIG9iamVjdCwgb2JqZWN0LCB7IHBhZ2U/OiBzdHJpbmc7IGxpbWl0Pzogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgY29uc3QgcGFnZSA9IHJlcS5xdWVyeS5wYWdlID8gcGFyc2VJbnQocmVxLnF1ZXJ5LnBhZ2UgYXMgc3RyaW5nKSA6IDE7XG4gIGNvbnN0IGxpbWl0ID0gcmVxLnF1ZXJ5LmxpbWl0ID8gcGFyc2VJbnQocmVxLnF1ZXJ5LmxpbWl0IGFzIHN0cmluZykgOiBERUZBVUxUX1BBR0VfU0laRTtcbiAgcmVxLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgYWxsIHByb3ZpZGVyc1wiLCB7IHF1ZXJ5OiByZXEucXVlcnksIHRlbmFudElkOiByZXEuYWRtaW4udGVuYW50SWQgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm92aWRlcnM6IE9BdXRoUHJvdmlkZXJbXSA9IChcbiAgICAgIGF3YWl0IHJlcS5kYi5vQXV0aFByb3ZpZGVyLmZpbmRNYW55KHtcbiAgICAgICAgc2tpcDogKHBhZ2UgLSAxKSAqIGxpbWl0LFxuICAgICAgICB0YWtlOiBsaW1pdCxcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICB0ZW5hbnRJZDogcmVxLmFkbWluLnRlbmFudElkLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApLm1hcChtYXBQcm92aWRlcik7XG4gICAgcmVzLmpzb24oeyBkYXRhOiBwcm92aWRlcnMgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgcHJvdmlkZXJzXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byBnZXQgcHJvdmlkZXJzXCIgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQcm92aWRlciA9IGFzeW5jIChcbiAgcmVxOiBSZXF1ZXN0PFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIG9iamVjdCwgQ3JlYXRlUHJvdmlkZXJSZXF1ZXN0PixcbiAgcmVzOiBSZXNwb25zZSxcbikgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuaW5mbyhcIkNyZWF0aW5nIG5ldyBwcm92aWRlclwiLCB7IGJvZHk6IHJlcS5ib2R5IH0pO1xuICB0cnkge1xuICAgIGlmICghcmVxLmFkbWluLnRlbmFudElkKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5VTkFVVEhPUklaRUQpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJ1bmF1dGhvcml6ZWRcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJUZW5hbnQgSUQgaXMgcmVxdWlyZWRcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3ZpZGVyOiBPQXV0aFByb3ZpZGVyID0gbWFwUHJvdmlkZXIoXG4gICAgICBhd2FpdCByZXEuZGIub0F1dGhQcm92aWRlci5jcmVhdGUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4ucmVxLmJvZHksXG4gICAgICAgICAgY2xpZW50U2VjcmV0OiByZXEuYm9keS5jbGllbnRTZWNyZXQgfHwgXCJcIixcbiAgICAgICAgICB0ZW5hbnQ6IHsgY29ubmVjdDogeyBpZDogcmVxLmFkbWluLnRlbmFudElkIH0gfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5DUkVBVEVEKS5qc29uKHByb3ZpZGVyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBwcm92aWRlclwiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gY3JlYXRlIHByb3ZpZGVyXCIgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRQcm92aWRlciA9IGFzeW5jIChyZXE6IFJlcXVlc3Q8eyBwcm92aWRlcklkOiBzdHJpbmcgfT4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyBwcm92aWRlclwiLCB7IHByb3ZpZGVySWQ6IHJlcS5wYXJhbXMucHJvdmlkZXJJZCwgdGVuYW50SWQ6IHJlcS5hZG1pbi50ZW5hbnRJZCB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYlByb3ZpZGVyID0gYXdhaXQgcmVxLmRiLm9BdXRoUHJvdmlkZXIuZmluZFVuaXF1ZSh7XG4gICAgICB3aGVyZTogeyBpZDogcmVxLnBhcmFtcy5wcm92aWRlcklkLCB0ZW5hbnRJZDogcmVxLmFkbWluLnRlbmFudElkIH0sXG4gICAgfSk7XG4gICAgY29uc3QgcHJvdmlkZXI6IE9BdXRoUHJvdmlkZXIgfCBudWxsID0gZGJQcm92aWRlciA/IG1hcFByb3ZpZGVyKGRiUHJvdmlkZXIpIDogbnVsbDtcbiAgICByZXMuanNvbihwcm92aWRlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgcHJvdmlkZXJcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHsgZXJyb3I6IFwiRmFpbGVkIHRvIGdldCBwcm92aWRlclwiIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlUHJvdmlkZXIgPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdDx7IHByb3ZpZGVySWQ6IHN0cmluZyB9LCBvYmplY3QsIFVwZGF0ZVByb3ZpZGVyUmVxdWVzdD4sXG4gIHJlczogUmVzcG9uc2UsXG4pID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmluZm8oXCJVcGRhdGluZyBwcm92aWRlclwiLCB7XG4gICAgcHJvdmlkZXJJZDogcmVxLnBhcmFtcy5wcm92aWRlcklkLFxuICAgIGJvZHk6IHJlcS5ib2R5LFxuICAgIHRlbmFudElkOiByZXEuYWRtaW4udGVuYW50SWQsXG4gIH0pO1xuICB0cnkge1xuICAgIGNvbnN0IHByb3ZpZGVyOiBPQXV0aFByb3ZpZGVyID0gbWFwUHJvdmlkZXIoXG4gICAgICBhd2FpdCByZXEuZGIub0F1dGhQcm92aWRlci51cGRhdGUoe1xuICAgICAgICB3aGVyZTogeyBpZDogcmVxLnBhcmFtcy5wcm92aWRlcklkLCB0ZW5hbnRJZDogcmVxLmFkbWluLnRlbmFudElkIH0sXG4gICAgICAgIGRhdGE6IHJlcS5ib2R5LFxuICAgICAgfSksXG4gICAgKTtcblxuICAgIHJlcy5qc29uKHByb3ZpZGVyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm92aWRlclwiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gdXBkYXRlIHByb3ZpZGVyXCIgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVQcm92aWRlciA9IGFzeW5jIChyZXE6IFJlcXVlc3Q8eyBwcm92aWRlcklkOiBzdHJpbmcgfT4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmluZm8oXCJEZWxldGluZyBwcm92aWRlclwiLCB7IHByb3ZpZGVySWQ6IHJlcS5wYXJhbXMucHJvdmlkZXJJZCwgdGVuYW50SWQ6IHJlcS5hZG1pbi50ZW5hbnRJZCB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb25uZWN0ZWRUb29sc0NvdW50ID0gYXdhaXQgcmVxLmRiLnRvb2wuY291bnQoe1xuICAgICAgd2hlcmU6IHsgb0F1dGhQcm92aWRlcklkOiByZXEucGFyYW1zLnByb3ZpZGVySWQgfSxcbiAgICB9KTtcblxuICAgIGlmIChjb25uZWN0ZWRUb29sc0NvdW50ID4gMCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJDYW5ub3QgZGVsZXRlIHByb3ZpZGVyIHRoYXQgaXMgY29ubmVjdGVkIHRvIHRvb2xzXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBhd2FpdCByZXEuZGIub0F1dGhQcm92aWRlci5kZWxldGUoe1xuICAgICAgd2hlcmU6IHsgaWQ6IHJlcS5wYXJhbXMucHJvdmlkZXJJZCwgdGVuYW50SWQ6IHJlcS5hZG1pbi50ZW5hbnRJZCB9LFxuICAgIH0pO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9fQ09OVEVOVCkuc2VuZCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIHByb3ZpZGVyXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byBkZWxldGUgcHJvdmlkZXJcIiB9KTtcbiAgfVxufTtcbiIsICJpbXBvcnQgeyBSb3V0ZXIgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlQXV0aFByb3ZpZGVyLFxuICBkZWxldGVBdXRoUHJvdmlkZXIsXG4gIGdldEF1dGhQcm92aWRlcnMsXG4gIGdldFNlcnZlckF1dGhDb25maWcsXG4gIHVwZGF0ZUF1dGhQcm92aWRlcixcbiAgdXBkYXRlU2VydmVyQXV0aENvbmZpZyxcbiAgdmFsaWRhdGVKd2tzVXJsLFxufSBmcm9tIFwiLi4vY29udHJvbGxlcnMvc2VydmVyLWF1dGguY29udHJvbGxlci5qc1wiO1xuXG5jb25zdCByb3V0ZXIgPSBSb3V0ZXIoKTtcblxuLy8gU2VydmVyIGF1dGggY29uZmlndXJhdGlvbiByb3V0ZXNcbnJvdXRlci5nZXQoXCIvOnNlcnZlcklkL2F1dGhcIiwgZ2V0U2VydmVyQXV0aENvbmZpZyk7XG5yb3V0ZXIucHV0KFwiLzpzZXJ2ZXJJZC9hdXRoXCIsIHVwZGF0ZVNlcnZlckF1dGhDb25maWcpO1xuXG4vLyBBdXRoIHByb3ZpZGVyIHJvdXRlcyAoc3RyYXRlZ3ktYmFzZWQpXG5yb3V0ZXIuZ2V0KFwiLzpzZXJ2ZXJJZC9hdXRoLXByb3ZpZGVyc1wiLCBnZXRBdXRoUHJvdmlkZXJzKTtcbnJvdXRlci5wb3N0KFwiLzpzZXJ2ZXJJZC9hdXRoLXByb3ZpZGVyc1wiLCBjcmVhdGVBdXRoUHJvdmlkZXIpO1xucm91dGVyLnB1dChcIi86c2VydmVySWQvYXV0aC1wcm92aWRlcnMvOnByb3ZpZGVySWRcIiwgdXBkYXRlQXV0aFByb3ZpZGVyKTtcbnJvdXRlci5kZWxldGUoXCIvOnNlcnZlcklkL2F1dGgtcHJvdmlkZXJzLzpwcm92aWRlcklkXCIsIGRlbGV0ZUF1dGhQcm92aWRlcik7XG5cbi8vIEpXS1MgdmFsaWRhdGlvbiByb3V0ZSAobm90IHNlcnZlci1zcGVjaWZpYylcbnJvdXRlci5wb3N0KFwiL3ZhbGlkYXRlLWp3a3NcIiwgdmFsaWRhdGVKd2tzVXJsKTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIiwgImltcG9ydCB7IFVwZGF0ZVNlcnZlckF1dGhDb25maWdSZXF1ZXN0IH0gZnJvbSBcIkBhZ2VudGJyaWRnZS9hcGlcIjtcbmltcG9ydCB7IFJlcXVlc3QsIFJlc3BvbnNlIH0gZnJvbSBcImV4cHJlc3NcIjtcbmltcG9ydCB7IFN0YXR1c0NvZGVzIH0gZnJvbSBcImh0dHAtc3RhdHVzLWNvZGVzXCI7XG5pbXBvcnQgeyBTZXJ2ZXJBdXRoU2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlcy9zZXJ2ZXItYXV0aC5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBpc0FkbWluUmVxdWVzdCwgVHlwZUd1YXJkRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0U2VydmVyQXV0aENvbmZpZyA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgc2VydmVySWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgY29uc3Qgc2VydmVyQXV0aFNlcnZpY2UgPSBuZXcgU2VydmVyQXV0aFNlcnZpY2UocmVxLmRiLCByZXEubG9nZ2VyKTtcbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCBzZXJ2ZXJBdXRoU2VydmljZS5nZXRTZXJ2ZXJBdXRoQ29uZmlnKHNlcnZlcklkKTtcbiAgICByZXMuanNvbihjb25maWcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBzZXJ2ZXIgYXV0aCBjb25maWdcIiwgeyBlcnJvcjogZXJyb3JNZXNzYWdlIH0pO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHsgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCIgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTZXJ2ZXJBdXRoQ29uZmlnID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBzZXJ2ZXJJZCB9ID0gcmVxLnBhcmFtcztcbiAgICBjb25zdCB1cGRhdGVSZXF1ZXN0OiBVcGRhdGVTZXJ2ZXJBdXRoQ29uZmlnUmVxdWVzdCA9IHJlcS5ib2R5O1xuICAgIGNvbnN0IHNlcnZlckF1dGhTZXJ2aWNlID0gbmV3IFNlcnZlckF1dGhTZXJ2aWNlKHJlcS5kYiwgcmVxLmxvZ2dlcik7XG4gICAgY29uc3QgY29uZmlnID0gYXdhaXQgc2VydmVyQXV0aFNlcnZpY2UudXBkYXRlU2VydmVyQXV0aENvbmZpZyhzZXJ2ZXJJZCwgdXBkYXRlUmVxdWVzdCk7XG4gICAgcmVzLmpzb24oY29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgc2VydmVyIGF1dGggY29uZmlnXCIsIHsgZXJyb3I6IGVycm9yTWVzc2FnZSB9KTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QXV0aFByb3ZpZGVycyA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgc2VydmVySWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgY29uc3Qgc2VydmVyQXV0aFNlcnZpY2UgPSBuZXcgU2VydmVyQXV0aFNlcnZpY2UocmVxLmRiLCByZXEubG9nZ2VyKTtcbiAgICBjb25zdCBwcm92aWRlcnMgPSBhd2FpdCBzZXJ2ZXJBdXRoU2VydmljZS5nZXRBdXRoUHJvdmlkZXJzKHNlcnZlcklkKTtcbiAgICByZXMuanNvbihwcm92aWRlcnMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBhdXRoIHByb3ZpZGVyc1wiLCB7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSk7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUF1dGhQcm92aWRlciA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgc2VydmVySWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgY29uc3QgcHJvdmlkZXJEYXRhID0gcmVxLmJvZHk7XG4gICAgY29uc3Qgc2VydmVyQXV0aFNlcnZpY2UgPSBuZXcgU2VydmVyQXV0aFNlcnZpY2UocmVxLmRiLCByZXEubG9nZ2VyKTtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHNlcnZlckF1dGhTZXJ2aWNlLmNyZWF0ZUF1dGhQcm92aWRlcihzZXJ2ZXJJZCwgcHJvdmlkZXJEYXRhKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkNSRUFURUQpLmpzb24ocHJvdmlkZXIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBhdXRoIHByb3ZpZGVyXCIsIHsgZXJyb3I6IGVycm9yTWVzc2FnZSB9KTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlQXV0aFByb3ZpZGVyID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBzZXJ2ZXJJZCwgcHJvdmlkZXJJZCB9ID0gcmVxLnBhcmFtcztcbiAgICBjb25zdCBwcm92aWRlckRhdGEgPSByZXEuYm9keTtcbiAgICBjb25zdCBzZXJ2ZXJBdXRoU2VydmljZSA9IG5ldyBTZXJ2ZXJBdXRoU2VydmljZShyZXEuZGIsIHJlcS5sb2dnZXIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgc2VydmVyQXV0aFNlcnZpY2UudXBkYXRlQXV0aFByb3ZpZGVyKHNlcnZlcklkLCBwcm92aWRlcklkLCBwcm92aWRlckRhdGEpO1xuICAgIHJlcy5qc29uKHByb3ZpZGVyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgYXV0aCBwcm92aWRlclwiLCB7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSk7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUF1dGhQcm92aWRlciA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgc2VydmVySWQsIHByb3ZpZGVySWQgfSA9IHJlcS5wYXJhbXM7XG4gICAgY29uc3Qgc2VydmVyQXV0aFNlcnZpY2UgPSBuZXcgU2VydmVyQXV0aFNlcnZpY2UocmVxLmRiLCByZXEubG9nZ2VyKTtcbiAgICBhd2FpdCBzZXJ2ZXJBdXRoU2VydmljZS5kZWxldGVBdXRoUHJvdmlkZXIoc2VydmVySWQsIHByb3ZpZGVySWQpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9fQ09OVEVOVCkuc2VuZCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSBhdXRoIHByb3ZpZGVyXCIsIHsgZXJyb3I6IGVycm9yTWVzc2FnZSB9KTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVKd2tzVXJsID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBqd2tzVXJsIH0gPSByZXEuYm9keTtcblxuICAgIGlmICghandrc1VybCB8fCB0eXBlb2Ygandrc1VybCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IFwiSldLUyBVUkwgaXMgcmVxdWlyZWRcIixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlckF1dGhTZXJ2aWNlID0gbmV3IFNlcnZlckF1dGhTZXJ2aWNlKHJlcS5kYiwgcmVxLmxvZ2dlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmVyQXV0aFNlcnZpY2UudmFsaWRhdGVKd2tzVXJsKGp3a3NVcmwpO1xuICAgIHJlcy5qc29uKHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gdmFsaWRhdGUgSldLUyBVUkxcIiwgeyBlcnJvcjogZXJyb3JNZXNzYWdlIH0pO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHtcbiAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiLFxuICAgIH0pO1xuICB9XG59O1xuIiwgImltcG9ydCB7IFJvdXRlciB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVFeGFtcGxlU2VydmVyLFxuICBjcmVhdGVTZXJ2ZXIsXG4gIGNyZWF0ZVNlcnZlckZyb21PcGVuQXBpLFxuICBjcmVhdGVUb29sLFxuICBjcmVhdGVUb29sc0Zyb21PcGVuQXBpLFxuICBkZWxldGVTZXJ2ZXIsXG4gIGRlbGV0ZVRvb2wsXG4gIGRpc2FibGVUb29sLFxuICBlbmFibGVUb29sLFxuICBnZXRTZXJ2ZXIsXG4gIGdldFNlcnZlcnMsXG4gIGdldFRvb2wsXG4gIGxpc3RUb29scyxcbiAgcnVuVG9vbCxcbiAgdXBkYXRlU2VydmVyLFxuICB1cGRhdGVUb29sLFxufSBmcm9tIFwiLi4vY29udHJvbGxlcnMvc2VydmVycy5jb250cm9sbGVyLmpzXCI7XG5cbmNvbnN0IHJvdXRlcjogUm91dGVyID0gUm91dGVyKCk7XG5cbi8vIFNlcnZlciBNYW5hZ2VtZW50XG5yb3V0ZXIuZ2V0KFwiL1wiLCBnZXRTZXJ2ZXJzKTtcbnJvdXRlci5wb3N0KFwiL1wiLCBjcmVhdGVTZXJ2ZXIpO1xucm91dGVyLmdldChcIi86c2VydmVySWRcIiwgZ2V0U2VydmVyKTtcbnJvdXRlci5wdXQoXCIvOnNlcnZlcklkXCIsIHVwZGF0ZVNlcnZlcik7XG5yb3V0ZXIuZGVsZXRlKFwiLzpzZXJ2ZXJJZFwiLCBkZWxldGVTZXJ2ZXIpO1xuXG4vLyBUb29scyBNYW5hZ2VtZW50XG5yb3V0ZXIuZ2V0KFwiLzpzZXJ2ZXJJZC90b29sc1wiLCBsaXN0VG9vbHMpO1xucm91dGVyLnBvc3QoXCIvOnNlcnZlcklkL3Rvb2xzXCIsIGNyZWF0ZVRvb2wpO1xucm91dGVyLnBvc3QoXCIvOnNlcnZlcklkL3Rvb2xzL2ltcG9ydC9vcGVuYXBpXCIsIGNyZWF0ZVRvb2xzRnJvbU9wZW5BcGkpO1xucm91dGVyLmdldChcIi86c2VydmVySWQvdG9vbHMvOnRvb2xJZFwiLCBnZXRUb29sKTtcbnJvdXRlci5wdXQoXCIvOnNlcnZlcklkL3Rvb2xzLzp0b29sSWRcIiwgdXBkYXRlVG9vbCk7XG5yb3V0ZXIuZGVsZXRlKFwiLzpzZXJ2ZXJJZC90b29scy86dG9vbElkXCIsIGRlbGV0ZVRvb2wpO1xucm91dGVyLnBvc3QoXCIvOnNlcnZlcklkL3Rvb2xzLzp0b29sSWQvcnVuXCIsIHJ1blRvb2wpO1xucm91dGVyLnB1dChcIi86c2VydmVySWQvdG9vbHMvOnRvb2xJZC9lbmFibGVcIiwgZW5hYmxlVG9vbCk7XG5yb3V0ZXIucHV0KFwiLzpzZXJ2ZXJJZC90b29scy86dG9vbElkL2Rpc2FibGVcIiwgZGlzYWJsZVRvb2wpO1xuXG4vLyBJbXBvcnQgTWFuYWdlbWVudFxucm91dGVyLnBvc3QoXCIvaW1wb3J0L29wZW5hcGlcIiwgY3JlYXRlU2VydmVyRnJvbU9wZW5BcGkpO1xucm91dGVyLnBvc3QoXCIvZXhhbXBsZVwiLCBjcmVhdGVFeGFtcGxlU2VydmVyKTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIiwgImltcG9ydCB7IENyZWF0ZVNlcnZlclJlcXVlc3QsIENyZWF0ZVRvb2xSZXF1ZXN0LCBUb29sUnVuUmVxdWVzdCwgVXBkYXRlU2VydmVyUmVxdWVzdCB9IGZyb20gXCJAYWdlbnRicmlkZ2UvYXBpXCI7XG5pbXBvcnQgeyBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBTdGF0dXNDb2RlcyB9IGZyb20gXCJodHRwLXN0YXR1cy1jb2Rlc1wiO1xuaW1wb3J0IHlhbWwgZnJvbSBcImpzLXlhbWxcIjtcbmltcG9ydCB7IGV4ZWN1dGVBcGlSZXF1ZXN0IH0gZnJvbSBcIi4uL3NlcnZpY2VzL2FwaS1leGVjL2FwaS10b29sLWV4ZWN1dG9yLmpzXCI7XG5pbXBvcnQgeyBDYWNoZUl0ZW1UeXBlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL2NhY2hlLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IGdldFVzZXJVc2VhYmxlVG9rZW5zLCByZWZyZXNoQW5kUGVyc2lzdEFjY2Vzc1Rva2VuIH0gZnJvbSBcIi4uL3NlcnZpY2VzL29hdXRoLnNlcnZpY2UuanNcIjtcbmltcG9ydCAqIGFzIHNlcnZlcnNTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9zZXJ2ZXJzLnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IE9wZW5BcGlEb2N1bWVudCwgdmFsaWRhdGVPcGVuQXBpQ29udGVudCB9IGZyb20gXCIuLi91dGlscy9vcGVuYXBpLmpzXCI7XG5pbXBvcnQgeyBpc0FkbWluUmVxdWVzdCwgVHlwZUd1YXJkRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0U2VydmVycyA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyBhbGwgc2VydmVycyBmb3IgdGVuYW50XCIsIHsgdGVuYW50SWQ6IHJlcS5hZG1pbi50ZW5hbnRJZCB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IHNlcnZlcnMgPSBhd2FpdCBzZXJ2ZXJzU2VydmljZS5nZXRTZXJ2ZXJzRm9yVGVuYW50KHJlcS5kYiwgcmVxLmFkbWluLnRlbmFudElkIGFzIHN0cmluZyk7XG4gICAgcmVzLmpzb24oc2VydmVycyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgc2VydmVyc1wiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oe1xuICAgICAgZXJyb3I6IFwic2VydmVyX2xpc3RfZmFpbGVkXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIkZhaWxlZCB0byBnZXQgc2VydmVyc1wiLFxuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2VydmVyID0gYXN5bmMgKFxuICByZXE6IFJlcXVlc3Q8UmVjb3JkPHN0cmluZywgc3RyaW5nPiwgb2JqZWN0LCBDcmVhdGVTZXJ2ZXJSZXF1ZXN0PixcbiAgcmVzOiBSZXNwb25zZSxcbikgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuICB0cnkge1xuICAgIHJlcS5sb2dnZXIuaW5mbyhcIkNyZWF0aW5nIG5ldyBzZXJ2ZXJcIiwgeyBib2R5OiByZXEuYm9keSB9KTtcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCBzZXJ2ZXJzU2VydmljZS5jcmVhdGVTZXJ2ZXIocmVxLmRiLCByZXEuYWRtaW4udGVuYW50SWQsIHtcbiAgICAgIG5hbWU6IHJlcS5ib2R5Lm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogcmVxLmJvZHkuZGVzY3JpcHRpb24sXG4gICAgICBlbmFibGVkOiByZXEuYm9keS5lbmFibGVkID8/IHRydWUsXG4gICAgICBiYXNlVXJsOiByZXEuYm9keS5iYXNlVXJsLFxuICAgIH0pO1xuXG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5DUkVBVEVEKS5qc29uKHNlcnZlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgc2VydmVyXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBlcnJvcjogXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiRmFpbGVkIHRvIGNyZWF0ZSBzZXJ2ZXJcIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFNlcnZlciA9IGFzeW5jIChyZXE6IFJlcXVlc3Q8eyBzZXJ2ZXJJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHRyeSB7XG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhcIkdldHRpbmcgc2VydmVyXCIsIHsgc2VydmVySWQ6IHJlcS5wYXJhbXMuc2VydmVySWQgfSk7XG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgc2VydmVyc1NlcnZpY2UuZ2V0U2VydmVyQnlJZChyZXEuZGIsIHJlcS5hZG1pbi50ZW5hbnRJZCwgcmVxLnBhcmFtcy5zZXJ2ZXJJZCk7XG4gICAgaWYgKCFzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk5PVF9GT1VORCkuanNvbih7XG4gICAgICAgIGVycm9yOiBcInNlcnZlcl9ub3RfZm91bmRcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogYFNlcnZlciBub3QgZm91bmQ6ICR7cmVxLnBhcmFtcy5zZXJ2ZXJJZH1gLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzLmpzb24oc2VydmVyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBzZXJ2ZXJcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHtcbiAgICAgIGVycm9yOiBcImludGVybmFsX3NlcnZlcl9lcnJvclwiLFxuICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJGYWlsZWQgdG8gZ2V0IHNlcnZlclwiLFxuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlU2VydmVyID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmcgfSwgb2JqZWN0LCBVcGRhdGVTZXJ2ZXJSZXF1ZXN0PiwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuICByZXEubG9nZ2VyLmluZm8oXCJVcGRhdGluZyBzZXJ2ZXJcIiwgeyBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgYm9keTogcmVxLmJvZHkgfSk7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgc2VydmVyc1NlcnZpY2UudXBkYXRlU2VydmVyQnlJZChyZXEuZGIsIHJlcS5hZG1pbi50ZW5hbnRJZCwgcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgcmVxLmJvZHkpO1xuXG4gICAgY29uc3QgeyBjbGVhckNhY2hlLCBjbGVhckNhY2hlQnlQYXJ0aWFsS2V5IH0gPSBhd2FpdCBpbXBvcnQoXCIuLi9zZXJ2aWNlcy9jYWNoZS5zZXJ2aWNlLmpzXCIpO1xuICAgIGNsZWFyQ2FjaGUoeyB0eXBlOiBDYWNoZUl0ZW1UeXBlLlNFUlZFUiwgaWRzOiBbc2VydmVyLmlkXSB9KTtcbiAgICBjbGVhckNhY2hlQnlQYXJ0aWFsS2V5KENhY2hlSXRlbVR5cGUuU0VSVkVSX0FDQ0VTUywgc2VydmVyLmlkKTtcblxuICAgIHJlcy5qc29uKHNlcnZlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgc2VydmVyXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBlcnJvcjogXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiRmFpbGVkIHRvIHVwZGF0ZSBzZXJ2ZXJcIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVNlcnZlciA9IGFzeW5jIChyZXE6IFJlcXVlc3Q8eyBzZXJ2ZXJJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHJlcS5sb2dnZXIuaW5mbyhcIkRlbGV0aW5nIHNlcnZlclwiLCB7IHNlcnZlcklkOiByZXEucGFyYW1zLnNlcnZlcklkIH0pO1xuXG4gIC8vIEdldCBzZXJ2ZXIgZGF0YSBiZWZvcmUgZGVsZXRpbmcgdG8gYWNjZXNzIHRoZSB0ZW5hbnRJZFxuICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCBzZXJ2ZXJzU2VydmljZS5nZXRTZXJ2ZXJTbGltKHJlcS5kYiwgcmVxLmFkbWluLnRlbmFudElkLCByZXEucGFyYW1zLnNlcnZlcklkKTtcblxuICBpZiAoc2VydmVyKSB7XG4gICAgYXdhaXQgc2VydmVyc1NlcnZpY2UuZGVsZXRlU2VydmVyQnlJZChyZXEuZGIsIHJlcS5hZG1pbi50ZW5hbnRJZCwgcmVxLnBhcmFtcy5zZXJ2ZXJJZCk7XG5cbiAgICBjb25zdCB7IGNsZWFyQ2FjaGUsIGNsZWFyQ2FjaGVCeVBhcnRpYWxLZXkgfSA9IGF3YWl0IGltcG9ydChcIi4uL3NlcnZpY2VzL2NhY2hlLnNlcnZpY2UuanNcIik7XG4gICAgY2xlYXJDYWNoZSh7IHR5cGU6IENhY2hlSXRlbVR5cGUuU0VSVkVSLCBpZHM6IFtzZXJ2ZXIuaWRdIH0pO1xuICAgIGNsZWFyQ2FjaGVCeVBhcnRpYWxLZXkoQ2FjaGVJdGVtVHlwZS5TRVJWRVJfQUNDRVNTLCBzZXJ2ZXIuaWQpO1xuXG4gICAgcmVxLmxvZ2dlci5kZWJ1ZyhcIlNlcnZlciBkZWxldGVkIGFuZCBjYWNoZXMgY2xlYXJlZFwiLCB7IHNlcnZlcklkOiByZXEucGFyYW1zLnNlcnZlcklkIH0pO1xuICB9XG5cbiAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5OT19DT05URU5UKS5zZW5kKCk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2VydmVyRnJvbU9wZW5BcGkgPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHJlcS5sb2dnZXIuaW5mbyhcIkNyZWF0aW5nIHNlcnZlciBmcm9tIE9wZW5BUEkgc3BlY2lmaWNhdGlvblwiKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gcmVxLmJvZHk7XG4gICAgaWYgKCFmaWxlQ29udGVudCB8fCAhQnVmZmVyLmlzQnVmZmVyKGZpbGVDb250ZW50KSkge1xuICAgICAgcmVxLmxvZ2dlci53YXJuKFwiT3BlbkFQSSBzcGVjaWZpY2F0aW9uIGZpbGUgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgc2VudCBhcyBvY3RldC1zdHJlYW1cIik7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7XG4gICAgICAgIGVycm9yOiBcImludmFsaWRfcmVxdWVzdFwiLFxuICAgICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIk9wZW5BUEkgc3BlY2lmaWNhdGlvbiBmaWxlIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIHNlbnQgYXMgb2N0ZXQtc3RyZWFtXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgb3BlbkFwaUNvbnRlbnQ6IE9wZW5BcGlEb2N1bWVudDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeWFtbENvbnRlbnQgPSBmaWxlQ29udGVudC50b1N0cmluZyhcInV0ZjhcIik7XG5cbiAgICAgIGlmICgheWFtbENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgIHJlcS5sb2dnZXIud2FybihcIk9wZW5BUEkgY29udGVudCBpcyBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oe1xuICAgICAgICAgIGVycm9yOiBcImludmFsaWRfb3BlbmFwaVwiLFxuICAgICAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiT3BlbkFQSSBjb250ZW50IGlzIGVtcHR5XCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvcGVuQXBpQ29udGVudCA9IHlhbWwubG9hZCh5YW1sQ29udGVudCk7XG5cbiAgICAgIGlmICghKFwib3BlbmFwaVwiIGluIG9wZW5BcGlDb250ZW50KSB8fCAhb3BlbkFwaUNvbnRlbnQub3BlbmFwaS5zdGFydHNXaXRoKFwiM1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVuQVBJIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBPcGVuQVBJIGNvbnRlbnRcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJpbnZhbGlkX29wZW5hcGlcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJJbnZhbGlkIE9wZW5BUEkgZm9ybWF0XCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZU9wZW5BcGlDb250ZW50KG9wZW5BcGlDb250ZW50KTtcbiAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICByZXEubG9nZ2VyLndhcm4odmFsaWRhdGlvbkVycm9yLmVycm9yRGVzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24odmFsaWRhdGlvbkVycm9yKTtcbiAgICB9XG5cbiAgICByZXEubG9nZ2VyLmRlYnVnKFwiUGFyc2VkIE9wZW5BUEkgY29udGVudDpcIiwgb3BlbkFwaUNvbnRlbnQpO1xuICAgIGNvbnN0IHRlbmFudElkID0gcmVxLmFkbWluLnRlbmFudElkITtcblxuICAgIGNvbnN0IHNlbGVjdGVkVG9vbHMgPSByZXEucXVlcnkuc2VsZWN0ZWRUb29sc1xuICAgICAgPyBBcnJheS5pc0FycmF5KHJlcS5xdWVyeS5zZWxlY3RlZFRvb2xzKVxuICAgICAgICA/IChyZXEucXVlcnkuc2VsZWN0ZWRUb29scyBhcyBzdHJpbmdbXSlcbiAgICAgICAgOiBbcmVxLnF1ZXJ5LnNlbGVjdGVkVG9vbHMgYXMgc3RyaW5nXVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2ZXJzU2VydmljZS5jcmVhdGVTZXJ2ZXJGcm9tT3BlbkFwaVNwZWMoXG4gICAgICByZXEuZGIsXG4gICAgICB0ZW5hbnRJZCxcbiAgICAgIHJlcS5xdWVyeS5uYW1lIGFzIHN0cmluZyB8IG51bGwsXG4gICAgICByZXEucXVlcnkuZGVzY3JpcHRpb24gYXMgc3RyaW5nIHwgbnVsbCxcbiAgICAgIG9wZW5BcGlDb250ZW50LFxuICAgICAgc2VsZWN0ZWRUb29scyxcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQ1JFQVRFRCkuanNvbihyZXN1bHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHNlcnZlciBmcm9tIE9wZW5BUElcIiwgZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBlcnJvcjogXCJzZXJ2ZXJfY3JlYXRpb25fZmFpbGVkXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGNyZWF0ZSBzZXJ2ZXIgZnJvbSBPcGVuQVBJXCIsXG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUb29sc0Zyb21PcGVuQXBpID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmcgfT4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgcmVxLmxvZ2dlci5pbmZvKFwiQ3JlYXRpbmcgdG9vbHMgZnJvbSBPcGVuQVBJIHNwZWNpZmljYXRpb25cIiwgeyBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gcmVxLmJvZHk7XG4gICAgaWYgKCFmaWxlQ29udGVudCB8fCAhQnVmZmVyLmlzQnVmZmVyKGZpbGVDb250ZW50KSkge1xuICAgICAgcmVxLmxvZ2dlci53YXJuKFwiT3BlbkFQSSBzcGVjaWZpY2F0aW9uIGZpbGUgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgc2VudCBhcyBvY3RldC1zdHJlYW1cIik7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7XG4gICAgICAgIGVycm9yOiBcImludmFsaWRfcmVxdWVzdFwiLFxuICAgICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIk9wZW5BUEkgc3BlY2lmaWNhdGlvbiBmaWxlIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIHNlbnQgYXMgb2N0ZXQtc3RyZWFtXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgb3BlbkFwaUNvbnRlbnQ6IE9wZW5BcGlEb2N1bWVudDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeWFtbENvbnRlbnQgPSBmaWxlQ29udGVudC50b1N0cmluZyhcInV0ZjhcIik7XG5cbiAgICAgIGlmICgheWFtbENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgIHJlcS5sb2dnZXIud2FybihcIk9wZW5BUEkgY29udGVudCBpcyBlbXB0eVwiKTtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oe1xuICAgICAgICAgIGVycm9yOiBcImludmFsaWRfb3BlbmFwaVwiLFxuICAgICAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiT3BlbkFQSSBjb250ZW50IGlzIGVtcHR5XCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvcGVuQXBpQ29udGVudCA9IHlhbWwubG9hZCh5YW1sQ29udGVudCk7XG5cbiAgICAgIGlmICghKFwib3BlbmFwaVwiIGluIG9wZW5BcGlDb250ZW50KSB8fCAhb3BlbkFwaUNvbnRlbnQub3BlbmFwaS5zdGFydHNXaXRoKFwiM1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGVuQVBJIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBPcGVuQVBJIGNvbnRlbnRcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJpbnZhbGlkX29wZW5hcGlcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJJbnZhbGlkIE9wZW5BUEkgZm9ybWF0XCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZU9wZW5BcGlDb250ZW50KG9wZW5BcGlDb250ZW50KTtcbiAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICByZXEubG9nZ2VyLndhcm4odmFsaWRhdGlvbkVycm9yLmVycm9yRGVzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24odmFsaWRhdGlvbkVycm9yKTtcbiAgICB9XG5cbiAgICByZXEubG9nZ2VyLmRlYnVnKFwiUGFyc2VkIE9wZW5BUEkgY29udGVudDpcIiwgb3BlbkFwaUNvbnRlbnQpO1xuICAgIGNvbnN0IHRlbmFudElkID0gcmVxLmFkbWluLnRlbmFudElkITtcbiAgICBjb25zdCBzZXJ2ZXJJZCA9IHJlcS5wYXJhbXMuc2VydmVySWQ7XG5cbiAgICBjb25zdCBzZWxlY3RlZFRvb2xzID0gcmVxLnF1ZXJ5LnNlbGVjdGVkVG9vbHNcbiAgICAgID8gQXJyYXkuaXNBcnJheShyZXEucXVlcnkuc2VsZWN0ZWRUb29scylcbiAgICAgICAgPyAocmVxLnF1ZXJ5LnNlbGVjdGVkVG9vbHMgYXMgc3RyaW5nW10pXG4gICAgICAgIDogW3JlcS5xdWVyeS5zZWxlY3RlZFRvb2xzIGFzIHN0cmluZ11cbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmVyc1NlcnZpY2UuY3JlYXRlVG9vbHNGcm9tT3BlbkFwaVNwZWMoXG4gICAgICByZXEuZGIsXG4gICAgICB0ZW5hbnRJZCxcbiAgICAgIHNlcnZlcklkLFxuICAgICAgb3BlbkFwaUNvbnRlbnQsXG4gICAgICBzZWxlY3RlZFRvb2xzLFxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5DUkVBVEVEKS5qc29uKHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgdG9vbHMgZnJvbSBPcGVuQVBJXCIsIGVycm9yKTtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oe1xuICAgICAgZXJyb3I6IFwidG9vbHNfY3JlYXRpb25fZmFpbGVkXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGNyZWF0ZSB0b29scyBmcm9tIE9wZW5BUElcIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGxpc3RUb29scyA9IGFzeW5jIChyZXE6IFJlcXVlc3Q8eyBzZXJ2ZXJJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHJlcS5sb2dnZXIuZGVidWcoXCJMaXN0aW5nIHRvb2xzXCIsIHsgc2VydmVySWQ6IHJlcS5wYXJhbXMuc2VydmVySWQgfSk7XG4gIHRyeSB7XG4gICAgY29uc3QgdG9vbHMgPSBhd2FpdCBzZXJ2ZXJzU2VydmljZS5nZXRUb29sc0ZvclNlcnZlcihcbiAgICAgIHJlcS5kYixcbiAgICAgIHJlcS5hZG1pbi50ZW5hbnRJZCxcbiAgICAgIHJlcS5wYXJhbXMuc2VydmVySWQsXG4gICAgICByZXEuYWRtaW4uZW1haWwsXG4gICAgKTtcbiAgICByZXMuanNvbih7IGRhdGE6IHRvb2xzIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbGlzdCB0b29sc1wiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oe1xuICAgICAgZXJyb3I6IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIkZhaWxlZCB0byBsaXN0IHRvb2xzXCIsXG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUb29sID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmcgfSwgb2JqZWN0LCBDcmVhdGVUb29sUmVxdWVzdD4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgcmVxLmxvZ2dlci5pbmZvKFwiQ3JlYXRpbmcgdG9vbFwiLCB7IHNlcnZlcklkOiByZXEucGFyYW1zLnNlcnZlcklkLCBib2R5OiByZXEuYm9keSB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRvb2wgPSBhd2FpdCBzZXJ2ZXJzU2VydmljZS5jcmVhdGVUb29sKHJlcS5kYiwgcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgcmVxLmFkbWluLnRlbmFudElkISwgcmVxLmJvZHkpO1xuXG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5DUkVBVEVEKS5qc29uKHRvb2wpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJFcnJvciBjcmVhdGluZyB0b29sXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBlcnJvcjogXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiRmFpbGVkIHRvIGNyZWF0ZSB0b29sXCIsXG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRUb29sID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmc7IHRvb2xJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHJlcS5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHRvb2xcIiwgeyBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgdG9vbElkOiByZXEucGFyYW1zLnRvb2xJZCB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b29sID0gYXdhaXQgc2VydmVyc1NlcnZpY2UuZ2V0VG9vbEJ5SWQocmVxLmRiLCByZXEuYWRtaW4udGVuYW50SWQsIHJlcS5wYXJhbXMudG9vbElkLCByZXEuYWRtaW4uZW1haWwpO1xuICAgIHJlcy5qc29uKHRvb2wpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHRvb2xcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHtcbiAgICAgIGVycm9yOiBcImludGVybmFsX3NlcnZlcl9lcnJvclwiLFxuICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJGYWlsZWQgdG8gZ2V0IHRvb2xcIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVRvb2wgPSBhc3luYyAocmVxOiBSZXF1ZXN0PHsgc2VydmVySWQ6IHN0cmluZzsgdG9vbElkOiBzdHJpbmcgfT4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgcmVxLmxvZ2dlci5pbmZvKFwiVXBkYXRpbmcgdG9vbFwiLCB7IHNlcnZlcklkOiByZXEucGFyYW1zLnNlcnZlcklkLCB0b29sSWQ6IHJlcS5wYXJhbXMudG9vbElkLCBib2R5OiByZXEuYm9keSB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b29sID0gYXdhaXQgc2VydmVyc1NlcnZpY2UudXBkYXRlVG9vbEJ5SWQocmVxLmRiLCByZXEuYWRtaW4udGVuYW50SWQsIHJlcS5wYXJhbXMudG9vbElkLCByZXEuYm9keSk7XG5cbiAgICByZXMuanNvbih0b29sKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSB0b29sXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBlcnJvcjogXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiRmFpbGVkIHRvIHVwZGF0ZSB0b29sXCIsXG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVUb29sID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmc7IHRvb2xJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHJlcS5sb2dnZXIuaW5mbyhcIkRlbGV0aW5nIHRvb2xcIiwgeyBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgdG9vbElkOiByZXEucGFyYW1zLnRvb2xJZCB9KTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzZXJ2ZXJzU2VydmljZS5kZWxldGVUb29sQnlJZChyZXEuZGIsIHJlcS5hZG1pbi50ZW5hbnRJZCwgcmVxLnBhcmFtcy50b29sSWQpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9fQ09OVEVOVCkuc2VuZCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIHRvb2xcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHtcbiAgICAgIGVycm9yOiBcImludGVybmFsX3NlcnZlcl9lcnJvclwiLFxuICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJGYWlsZWQgdG8gZGVsZXRlIHRvb2xcIixcbiAgICB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJ1blRvb2wgPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmc7IHRvb2xJZDogc3RyaW5nIH0sIG9iamVjdCwgVG9vbFJ1blJlcXVlc3Q+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgY29uc3QgeyBzZXJ2ZXJJZCwgdG9vbElkIH0gPSByZXEucGFyYW1zO1xuICBjb25zdCB7IHBhcmFtZXRlcnMsIGF1dGhvcml6YXRpb24gfSA9IHJlcS5ib2R5O1xuXG4gIHJlcS5sb2dnZXIuaW5mbyhcIlJ1bm5pbmcgdG9vbCBpbiBwbGF5Z3JvdW5kXCIsIHtcbiAgICBzZXJ2ZXJJZCxcbiAgICB0b29sSWQsXG4gICAgaGFzUGFyYW1ldGVyczogISFwYXJhbWV0ZXJzLFxuICAgIGhhc0F1dGg6ICEhYXV0aG9yaXphdGlvbixcbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc3QgdG9vbCA9IGF3YWl0IHJlcS5kYi50b29sLmZpbmRVbmlxdWUoe1xuICAgICAgd2hlcmU6IHtcbiAgICAgICAgaWQ6IHRvb2xJZCxcbiAgICAgICAgdGVuYW50SWQ6IHJlcS5hZG1pbi50ZW5hbnRJZCxcbiAgICAgICAgc2VydmVySWQ6IHNlcnZlcklkLFxuICAgICAgfSxcbiAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgb0F1dGhQcm92aWRlcjogdHJ1ZSxcbiAgICAgICAgc2VydmVyOiB7XG4gICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICBiYXNlVXJsOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmICghdG9vbCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHtcbiAgICAgICAgZXJyb3I6IFwidG9vbF9ub3RfZm91bmRcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogYFRvb2wgbm90IGZvdW5kOiAke3Rvb2xJZH1gLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3BlY1BhcmFtZXRlcnMgPSB0b29sLnBhcmFtZXRlcnMgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRvb2wucGFyYW1ldGVycykpIDoge307XG4gICAgY29uc3QgY2FsbFBhcmFtZXRlcnMgPSB7IC4uLnBhcmFtZXRlcnMgfTtcblxuICAgIGlmICh0b29sLm9BdXRoUHJvdmlkZXIpIHtcbiAgICAgIGNvbnN0IGVuZFVzZXIgPSBhd2FpdCByZXEuZGIuZW5kVXNlci5maW5kVW5pcXVlKHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBlbWFpbF90ZW5hbnRJZDoge1xuICAgICAgICAgICAgZW1haWw6IHJlcS5hZG1pbi5lbWFpbCxcbiAgICAgICAgICAgIHRlbmFudElkOiByZXEuYWRtaW4udGVuYW50SWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFlbmRVc2VyKSB7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLlVOQVVUSE9SSVpFRCkuanNvbih7XG4gICAgICAgICAgZXJyb3I6IFwidW5hdXRob3JpemVkXCIsXG4gICAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogYE5vIHN1ZmZpY2llbnQgYXV0aG9yaXphdGlvbiB0byBydW4gdG9vbDogJHt0b29sSWR9YCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBnZXRVc2VyVXNlYWJsZVRva2VucyhyZXEuZGIsIGVuZFVzZXIuaWQsIHRvb2wub0F1dGhQcm92aWRlci5pZCk7XG4gICAgICBjb25zdCB2YWxpZFRva2VucyA9IHRva2Vucy5maWx0ZXIoKHQpID0+ICF0LmV4cGlyZXNBdCB8fCB0LmV4cGlyZXNBdCA+IG5ldyBEYXRlKCkpO1xuICAgICAgaWYgKHZhbGlkVG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FsbFBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke3ZhbGlkVG9rZW5zWzBdLmFjY2Vzc1Rva2VufWA7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHRva2Vuc1dpdGhSZWZyZXNoID0gdG9rZW5zLmZpbHRlcigodCkgPT4gISF0LnJlZnJlc2hUb2tlbik7XG4gICAgICAgIGlmICh0b2tlbnNXaXRoUmVmcmVzaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuRGF0YSA9IGF3YWl0IHJlZnJlc2hBbmRQZXJzaXN0QWNjZXNzVG9rZW4oXG4gICAgICAgICAgICAgIHJlcS5kYixcbiAgICAgICAgICAgICAgcmVxLmxvZ2dlcixcbiAgICAgICAgICAgICAgZW5kVXNlci5pZCxcbiAgICAgICAgICAgICAgdG9vbC5vQXV0aFByb3ZpZGVyLFxuICAgICAgICAgICAgICB0b2tlbnNXaXRoUmVmcmVzaFswXS5yZWZyZXNoVG9rZW4hLFxuICAgICAgICAgICAgICByZXEuaXAgfHwgbnVsbCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYWxsUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7dG9rZW5EYXRhLmFjY2Vzc1Rva2VufWA7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlcS5sb2dnZXIud2FybihgRmFpbGVkIHRvIHJlZnJlc2ggdG9rZW4gZm9yIHByb3ZpZGVyICR7dG9vbC5vQXV0aFByb3ZpZGVyLm5hbWV9YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuVU5BVVRIT1JJWkVEKS5qc29uKHtcbiAgICAgICAgICAgICAgZXJyb3I6IFwib2F1dGhfYXV0aGVudGljYXRpb25fcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogYE9BdXRoIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkIGZvciAke3Rvb2wubmFtZX0uIFBsZWFzZSBhdXRoZW50aWNhdGUgdmlhIHRoZSBNQ1AgY2xpZW50LmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gdmFsaWQgdG9rZW5zIGFuZCBubyByZWZyZXNoIHRva2VucyAtIHJlcXVpcmUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5VTkFVVEhPUklaRUQpLmpzb24oe1xuICAgICAgICAgICAgZXJyb3I6IFwib2F1dGhfYXV0aGVudGljYXRpb25fcmVxdWlyZWRcIixcbiAgICAgICAgICAgIGVycm9yRGVzY3JpcHRpb246IGBPQXV0aCBhdXRoZW50aWNhdGlvbiByZXF1aXJlZCBmb3IgJHt0b29sLm5hbWV9LiBQbGVhc2UgYXV0aGVudGljYXRlIHZpYSB0aGUgTUNQIGNsaWVudC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZUFwaVJlcXVlc3QoXG4gICAgICB0b29sLFxuICAgICAgdG9vbC5zZXJ2ZXIuYmFzZVVybCxcbiAgICAgIHNwZWNQYXJhbWV0ZXJzLFxuICAgICAgY2FsbFBhcmFtZXRlcnMsXG4gICAgICByZXEubG9nZ2VyLFxuICAgICAgdHJ1ZSxcbiAgICAgIHt9LFxuICAgICk7XG5cbiAgICBjb25zdCBydW50aW1lTXMgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuT0spLmpzb24oe1xuICAgICAgaXNFcnJvcjogcmVzdWx0LmlzRXJyb3IsXG4gICAgICBydW50aW1lTXMsXG4gICAgICBjb250ZW50OlxuICAgICAgICByZXN1bHQuY29udGVudFxuICAgICAgICAgID8uZmlsdGVyKChyZXMpID0+IHJlcy50eXBlID09PSBcInRleHRcIilcbiAgICAgICAgICAubWFwKChyZXMpID0+IHJlcy50ZXh0KVxuICAgICAgICAgIC5qb2luKFwiXFxuXCIpIHx8IFwiPGVtcHR5PlwiLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcnVuIHRvb2xcIiwgZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgcnVudGltZU1zOiAwLFxuICAgICAgY29udGVudDogXCJGYWlsZWQgdG8gcnVuIHRvb2w6IFwiICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIpLFxuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRXhhbXBsZVNlcnZlciA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmluZm8oXCJDcmVhdGluZyBleGFtcGxlIHRvZG9zIHNlcnZlclwiLCB7IHRlbmFudElkOiByZXEuYWRtaW4udGVuYW50SWQgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2ZXJzU2VydmljZS5jcmVhdGVFeGFtcGxlVG9kb3NTZXJ2ZXIocmVxLmRiLCByZXEuYWRtaW4udGVuYW50SWQpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkNSRUFURUQpLmpzb24ocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBleGFtcGxlIHNlcnZlclwiLCBlcnJvcik7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHtcbiAgICAgIGVycm9yOiBcInNlcnZlcl9jcmVhdGlvbl9mYWlsZWRcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gY3JlYXRlIGV4YW1wbGUgc2VydmVyXCIsXG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBlbmFibGVUb29sID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHNlcnZlcklkOiBzdHJpbmc7IHRvb2xJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG4gIHJlcS5sb2dnZXIuaW5mbyhcIkVuYWJsaW5nIHRvb2xcIiwgeyBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgdG9vbElkOiByZXEucGFyYW1zLnRvb2xJZCB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b29sID0gYXdhaXQgc2VydmVyc1NlcnZpY2UudXBkYXRlVG9vbEJ5SWQocmVxLmRiLCByZXEuYWRtaW4udGVuYW50SWQsIHJlcS5wYXJhbXMudG9vbElkLCB7IGVuYWJsZWQ6IHRydWUgfSk7XG4gICAgcmVzLmpzb24odG9vbCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBlbmFibGUgdG9vbFwiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oe1xuICAgICAgZXJyb3I6IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCIsXG4gICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIkZhaWxlZCB0byBlbmFibGUgdG9vbFwiLFxuICAgIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGlzYWJsZVRvb2wgPSBhc3luYyAocmVxOiBSZXF1ZXN0PHsgc2VydmVySWQ6IHN0cmluZzsgdG9vbElkOiBzdHJpbmcgfT4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cbiAgcmVxLmxvZ2dlci5pbmZvKFwiRGlzYWJsaW5nIHRvb2xcIiwgeyBzZXJ2ZXJJZDogcmVxLnBhcmFtcy5zZXJ2ZXJJZCwgdG9vbElkOiByZXEucGFyYW1zLnRvb2xJZCB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0b29sID0gYXdhaXQgc2VydmVyc1NlcnZpY2UudXBkYXRlVG9vbEJ5SWQocmVxLmRiLCByZXEuYWRtaW4udGVuYW50SWQsIHJlcS5wYXJhbXMudG9vbElkLCB7IGVuYWJsZWQ6IGZhbHNlIH0pO1xuICAgIHJlcy5qc29uKHRvb2wpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZGlzYWJsZSB0b29sXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7XG4gICAgICBlcnJvcjogXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIixcbiAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiRmFpbGVkIHRvIGRpc2FibGUgdG9vbFwiLFxuICAgIH0pO1xuICB9XG59O1xuIiwgImltcG9ydCB7IFJvdXRlciB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgKiBhcyB0ZW5hbnRDb250cm9sbGVyIGZyb20gXCIuLi9jb250cm9sbGVycy90ZW5hbnQuY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IHsgcmVxdWlyZUFkbWluIH0gZnJvbSBcIi4uL21pZGRsZXdhcmVzL3JvbGUubWlkZGxld2FyZS5qc1wiO1xuaW1wb3J0IHsgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSB9IGZyb20gXCIuLi9taWRkbGV3YXJlcy9zZXNzaW9uLm1pZGRsZXdhcmUuanNcIjtcblxuY29uc3Qgcm91dGVyID0gUm91dGVyKCk7XG5cbi8vIFJvdXRlcyB0aGF0IHJlcXVpcmUgYWRtaW4gc2Vzc2lvbiBhbmQgYWRtaW4gcm9sZVxucm91dGVyLmdldChcIi91c2Vyc1wiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCB0ZW5hbnRDb250cm9sbGVyLmdldFRlbmFudFVzZXJzKTtcbnJvdXRlci5nZXQoXCIvaW52aXRhdGlvbnNcIiwgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSwgcmVxdWlyZUFkbWluLCB0ZW5hbnRDb250cm9sbGVyLmdldFRlbmFudEludml0YXRpb25zKTtcbnJvdXRlci5wb3N0KFwiL2ludml0YXRpb25zXCIsIGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUsIHJlcXVpcmVBZG1pbiwgdGVuYW50Q29udHJvbGxlci5jcmVhdGVJbnZpdGF0aW9uKTtcbnJvdXRlci5wdXQoXCIvdXNlcnMvOnVzZXJJZC9yb2xlXCIsIGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUsIHJlcXVpcmVBZG1pbiwgdGVuYW50Q29udHJvbGxlci51cGRhdGVVc2VyUm9sZSk7XG5yb3V0ZXIuZGVsZXRlKFwiL3VzZXJzLzp1c2VySWRcIiwgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSwgcmVxdWlyZUFkbWluLCB0ZW5hbnRDb250cm9sbGVyLnJlbW92ZVVzZXJGcm9tVGVuYW50KTtcbnJvdXRlci5kZWxldGUoXCIvaW52aXRhdGlvbnMvOmludml0YXRpb25JZFwiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCByZXF1aXJlQWRtaW4sIHRlbmFudENvbnRyb2xsZXIuY2FuY2VsSW52aXRhdGlvbik7XG5cbi8vIFB1YmxpYyByb3V0ZXMgKGZvciBhY2NlcHRpbmcgaW52aXRhdGlvbnMpXG5yb3V0ZXIuZ2V0KFwiL2ludml0YXRpb25zLzp0b2tlblwiLCB0ZW5hbnRDb250cm9sbGVyLmdldEludml0YXRpb25CeVRva2VuKTtcbnJvdXRlci5wb3N0KFwiL2ludml0YXRpb25zL2FjY2VwdFwiLCB0ZW5hbnRDb250cm9sbGVyLmFjY2VwdEludml0YXRpb24pO1xucm91dGVyLmdldChcIi91c2VyL3RlbmFudHNcIiwgdGVuYW50Q29udHJvbGxlci5nZXRVc2VyVGVuYW50cyk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlcjtcbiIsICJpbXBvcnQgeyBSZXF1ZXN0LCBSZXNwb25zZSB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBTdGF0dXNDb2RlcyB9IGZyb20gXCJodHRwLXN0YXR1cy1jb2Rlc1wiO1xuaW1wb3J0ICogYXMgdGVuYW50U2VydmljZSBmcm9tIFwiLi4vc2VydmljZXMvdGVuYW50LnNlcnZpY2UuanNcIjtcbmltcG9ydCB7IGlzQWRtaW5SZXF1ZXN0LCBpc0FwcFJlcXVlc3QsIFR5cGVHdWFyZEVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL3JlcS1ndWFyZHMuanNcIjtcblxuZXhwb3J0IGNvbnN0IGdldFRlbmFudFVzZXJzID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHRlbmFudCB1c2Vyc1wiKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRlbmFudElkID0gcmVxLmFkbWluLnRlbmFudElkO1xuICAgIGNvbnN0IGN1cnJlbnRVc2VySWQgPSByZXEuYWRtaW4uaWQ7XG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiB2aWV3IG90aGVyIHVzZXJzIChhbGwgcm9sZXMgY2FuIHZpZXcgdXNlcnMpXG4gICAgY29uc3QgdXNlcnMgPSBhd2FpdCB0ZW5hbnRTZXJ2aWNlLmdldFRlbmFudFVzZXJzKHJlcS5kYiwgdGVuYW50SWQsIGN1cnJlbnRVc2VySWQpO1xuICAgIHJlcy5qc29uKHVzZXJzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCB0ZW5hbnQgdXNlcnNcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHsgZXJyb3I6IFwiRmFpbGVkIHRvIGdldCB0ZW5hbnQgdXNlcnNcIiB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFRlbmFudEludml0YXRpb25zID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIHRlbmFudCBpbnZpdGF0aW9uc1wiKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRlbmFudElkID0gcmVxLmFkbWluLnRlbmFudElkO1xuICAgIGNvbnN0IGN1cnJlbnRVc2VySWQgPSByZXEuYWRtaW4uaWQ7XG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiB2aWV3IGludml0YXRpb25zIChvbmx5IGFkbWlucyBjYW4gdmlldyBpbnZpdGF0aW9ucylcbiAgICBjb25zdCBjYW5JbnZpdGUgPSBhd2FpdCB0ZW5hbnRTZXJ2aWNlLmNhbkludml0ZVVzZXJzKHJlcS5kYiwgdGVuYW50SWQsIGN1cnJlbnRVc2VySWQpO1xuICAgIGlmICghY2FuSW52aXRlKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5GT1JCSURERU4pLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJpbnN1ZmZpY2llbnRfcGVybWlzc2lvbnNcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHZpZXcgaW52aXRhdGlvbnNcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGludml0YXRpb25zID0gYXdhaXQgdGVuYW50U2VydmljZS5nZXRUZW5hbnRJbnZpdGF0aW9ucyhyZXEuZGIsIHRlbmFudElkKTtcbiAgICByZXMuanNvbihpbnZpdGF0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgdGVuYW50IGludml0YXRpb25zXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byBnZXQgdGVuYW50IGludml0YXRpb25zXCIgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVJbnZpdGF0aW9uID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuaW5mbyhcIkNyZWF0aW5nIGludml0YXRpb25cIiwgeyBlbWFpbDogcmVxLmJvZHkuZW1haWwsIHJvbGU6IHJlcS5ib2R5LnJvbGUgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0ZW5hbnRJZCA9IHJlcS5hZG1pbi50ZW5hbnRJZDtcbiAgICBjb25zdCBjdXJyZW50VXNlcklkID0gcmVxLmFkbWluLmlkO1xuICAgIGNvbnN0IHsgZW1haWwsIHJvbGUgfSA9IHJlcS5ib2R5O1xuXG4gICAgaWYgKCFlbWFpbCB8fCAhcm9sZSkge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBcIkVtYWlsIGFuZCByb2xlIGFyZSByZXF1aXJlZFwiIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghW1wiYWRtaW5cIiwgXCJtZW1iZXJcIl0uaW5jbHVkZXMocm9sZSkpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogXCJJbnZhbGlkIHJvbGVcIiB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBpbnZpdGUgb3RoZXJzXG4gICAgY29uc3QgY2FuSW52aXRlID0gYXdhaXQgdGVuYW50U2VydmljZS5jYW5JbnZpdGVVc2VycyhyZXEuZGIsIHRlbmFudElkLCBjdXJyZW50VXNlcklkKTtcbiAgICBpZiAoIWNhbkludml0ZSkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuRk9SQklEREVOKS5qc29uKHtcbiAgICAgICAgZXJyb3I6IFwiaW5zdWZmaWNpZW50X3Blcm1pc3Npb25zXCIsXG4gICAgICAgIGVycm9yRGVzY3JpcHRpb246IFwiWW91IGRvbid0IGhhdmUgcGVybWlzc2lvbiB0byBpbnZpdGUgdXNlcnNcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGludml0YXRpb24gPSBhd2FpdCB0ZW5hbnRTZXJ2aWNlLmNyZWF0ZUludml0YXRpb24ocmVxLmRiLCB0ZW5hbnRJZCwgZW1haWwsIHJvbGUsIHJlcS5hZG1pbi5pZCwgcmVxLmxvZ2dlcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5DUkVBVEVEKS5qc29uKGludml0YXRpb24pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcS5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGludml0YXRpb25cIiwgZXJyb3IpO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHsgZXJyb3I6IFwiRmFpbGVkIHRvIGNyZWF0ZSBpbnZpdGF0aW9uXCIgfSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW52aXRhdGlvbkJ5VG9rZW4gPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBcHBSZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuZGVidWcoXCJHZXR0aW5nIGludml0YXRpb24gYnkgdG9rZW5cIik7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IHRva2VuIH0gPSByZXEucGFyYW1zO1xuXG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBcIlRva2VuIGlzIHJlcXVpcmVkXCIgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW52aXRhdGlvbiA9IGF3YWl0IHRlbmFudFNlcnZpY2UuZ2V0SW52aXRhdGlvbkJ5VG9rZW4ocmVxLmRiLCB0b2tlbik7XG4gICAgcmVzLmpzb24oaW52aXRhdGlvbik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgaW52aXRhdGlvbiBieSB0b2tlblwiLCBlcnJvcik7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gZ2V0IGludml0YXRpb25cIiB9KTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhY2NlcHRJbnZpdGF0aW9uID0gYXN5bmMgKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQXBwUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmluZm8oXCJBY2NlcHRpbmcgaW52aXRhdGlvblwiKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgdG9rZW4gfSA9IHJlcS5ib2R5O1xuXG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBcIlRva2VuIGlzIHJlcXVpcmVkXCIgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGVuYW50U2VydmljZS5hY2NlcHRJbnZpdGF0aW9uKHJlcS5kYiwgdG9rZW4pO1xuICAgIHJlcy5qc29uKHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBhY2NlcHQgaW52aXRhdGlvblwiLCBlcnJvcik7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gYWNjZXB0IGludml0YXRpb25cIiB9KTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyUm9sZSA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmluZm8oXCJVcGRhdGluZyB1c2VyIHJvbGVcIiwgeyB1c2VySWQ6IHJlcS5wYXJhbXMudXNlcklkLCByb2xlOiByZXEuYm9keS5yb2xlIH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdGVuYW50SWQgPSByZXEuYWRtaW4udGVuYW50SWQ7XG4gICAgY29uc3QgY3VycmVudFVzZXJJZCA9IHJlcS5hZG1pbi5pZDtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcmVxLnBhcmFtcztcbiAgICBjb25zdCB7IHJvbGUgfSA9IHJlcS5ib2R5O1xuXG4gICAgaWYgKCFyb2xlIHx8ICFbXCJhZG1pblwiLCBcIm1lbWJlclwiLCBcInN1cGVyYWRtaW5cIl0uaW5jbHVkZXMocm9sZSkpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogXCJWYWxpZCByb2xlIGlzIHJlcXVpcmVkXCIgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gbWFuYWdlIHJvbGVzXG4gICAgY29uc3QgY2FuTWFuYWdlUm9sZXMgPSBhd2FpdCB0ZW5hbnRTZXJ2aWNlLmNhbk1hbmFnZVJvbGVzKHJlcS5kYiwgdGVuYW50SWQsIGN1cnJlbnRVc2VySWQpO1xuICAgIGlmICghY2FuTWFuYWdlUm9sZXMpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkZPUkJJRERFTikuanNvbih7XG4gICAgICAgIGVycm9yOiBcImluc3VmZmljaWVudF9wZXJtaXNzaW9uc1wiLFxuICAgICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIllvdSBkb24ndCBoYXZlIHBlcm1pc3Npb24gdG8gbWFuYWdlIHVzZXIgcm9sZXNcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgdXNlcnMgZnJvbSBjaGFuZ2luZyB0aGVpciBvd24gcm9sZVxuICAgIGlmIChjdXJyZW50VXNlcklkID09PSB1c2VySWQpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHtcbiAgICAgICAgZXJyb3I6IFwiaW52YWxpZF9vcGVyYXRpb25cIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJZb3UgY2Fubm90IGNoYW5nZSB5b3VyIG93biByb2xlXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHRlbmFudFNlcnZpY2UudXBkYXRlVXNlclJvbGUocmVxLmRiLCB0ZW5hbnRJZCwgdXNlcklkLCByb2xlKTtcbiAgICByZXMuanNvbih1cGRhdGVkVXNlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgdXNlciByb2xlXCIsIGVycm9yKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byB1cGRhdGUgdXNlciByb2xlXCIgfSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlVXNlckZyb21UZW5hbnQgPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5pbmZvKFwiUmVtb3ZpbmcgdXNlciBmcm9tIHRlbmFudFwiLCB7IHVzZXJJZDogcmVxLnBhcmFtcy51c2VySWQgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0ZW5hbnRJZCA9IHJlcS5hZG1pbi50ZW5hbnRJZDtcbiAgICBjb25zdCBjdXJyZW50VXNlcklkID0gcmVxLmFkbWluLmlkO1xuICAgIGNvbnN0IHsgdXNlcklkIH0gPSByZXEucGFyYW1zO1xuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBjYW4gcmVtb3ZlIG90aGVyIHVzZXJzXG4gICAgY29uc3QgY2FuUmVtb3ZlVXNlcnMgPSBhd2FpdCB0ZW5hbnRTZXJ2aWNlLmNhblJlbW92ZVVzZXJzKHJlcS5kYiwgdGVuYW50SWQsIGN1cnJlbnRVc2VySWQpO1xuICAgIGlmICghY2FuUmVtb3ZlVXNlcnMpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkZPUkJJRERFTikuanNvbih7XG4gICAgICAgIGVycm9yOiBcImluc3VmZmljaWVudF9wZXJtaXNzaW9uc1wiLFxuICAgICAgICBlcnJvckRlc2NyaXB0aW9uOiBcIllvdSBkb24ndCBoYXZlIHBlcm1pc3Npb24gdG8gcmVtb3ZlIHVzZXJzXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHVzZXJzIGZyb20gcmVtb3ZpbmcgdGhlbXNlbHZlc1xuICAgIGlmIChjdXJyZW50VXNlcklkID09PSB1c2VySWQpIHtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHtcbiAgICAgICAgZXJyb3I6IFwiaW52YWxpZF9vcGVyYXRpb25cIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJZb3UgY2Fubm90IHJlbW92ZSB5b3Vyc2VsZiBmcm9tIHRoZSB0ZW5hbnRcIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGF3YWl0IHRlbmFudFNlcnZpY2UucmVtb3ZlVXNlckZyb21UZW5hbnQocmVxLmRiLCB0ZW5hbnRJZCwgdXNlcklkKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk5PX0NPTlRFTlQpLnNlbmQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHJlbW92ZSB1c2VyIGZyb20gdGVuYW50XCIsIGVycm9yKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5CQURfUkVRVUVTVCkuanNvbih7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byByZW1vdmUgdXNlciBmcm9tIHRlbmFudFwiIH0pO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNhbmNlbEludml0YXRpb24gPSBhc3luYyAocmVxOiBSZXF1ZXN0LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5pbmZvKFwiQ2FuY2VsbGluZyBpbnZpdGF0aW9uXCIsIHsgaW52aXRhdGlvbklkOiByZXEucGFyYW1zLmludml0YXRpb25JZCB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRlbmFudElkID0gcmVxLmFkbWluLnRlbmFudElkO1xuICAgIGNvbnN0IGN1cnJlbnRVc2VySWQgPSByZXEuYWRtaW4uaWQ7XG4gICAgY29uc3QgeyBpbnZpdGF0aW9uSWQgfSA9IHJlcS5wYXJhbXM7XG5cbiAgICAvLyBDaGVjayBpZiB1c2VyIGNhbiBtYW5hZ2UgaW52aXRhdGlvbnNcbiAgICBjb25zdCBjYW5JbnZpdGUgPSBhd2FpdCB0ZW5hbnRTZXJ2aWNlLmNhbkludml0ZVVzZXJzKHJlcS5kYiwgdGVuYW50SWQsIGN1cnJlbnRVc2VySWQpO1xuICAgIGlmICghY2FuSW52aXRlKSB7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5GT1JCSURERU4pLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJpbnN1ZmZpY2llbnRfcGVybWlzc2lvbnNcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGNhbmNlbCBpbnZpdGF0aW9uc1wiLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGVuYW50U2VydmljZS5jYW5jZWxJbnZpdGF0aW9uKHJlcS5kYiwgdGVuYW50SWQsIGludml0YXRpb25JZCk7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5OT19DT05URU5UKS5zZW5kKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjYW5jZWwgaW52aXRhdGlvblwiLCBlcnJvcik7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gY2FuY2VsIGludml0YXRpb25cIiB9KTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRVc2VyVGVuYW50cyA9IGFzeW5jIChyZXE6IFJlcXVlc3QsIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyB1c2VyIHRlbmFudHNcIik7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0ZW5hbnRzID0gYXdhaXQgdGVuYW50U2VydmljZS5nZXRVc2VyVGVuYW50cyhyZXEuZGIsIHJlcS5hZG1pbi5pZCk7XG4gICAgcmVzLmpzb24odGVuYW50cyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVxLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgdXNlciB0ZW5hbnRzXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byBnZXQgdXNlciB0ZW5hbnRzXCIgfSk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHsgQWRtaW5Sb2xlLCBJbnZpdGF0aW9uU3RhdHVzLCBUZW5hbnRSb2xlIH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCB7IGFkZERheXMgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJ3aW5zdG9uXCI7XG5pbXBvcnQgeyBEYXRhYmFzZSB9IGZyb20gXCIuLi91dGlscy9jb25uZWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBzZW5kVGVuYW50SW52aXRhdGlvbkVtYWlsIH0gZnJvbSBcIi4vZW1haWwuc2VydmljZS5qc1wiO1xuY29uc3QgYmFzZVVybCA9IHByb2Nlc3MuZW52LkNPTlNPTEVfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo0MjAwXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuYW50VXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIHJvbGU6IEFkbWluUm9sZTtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gIHVwZGF0ZWRBdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbmFudEludml0YXRpb24ge1xuICBpZDogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICByb2xlOiBBZG1pblJvbGU7XG4gIHN0YXR1czogSW52aXRhdGlvblN0YXR1cztcbiAgaW52aXRlZEJ5OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gIH07XG4gIGFjY2VwdGVkQnk/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gIH07XG4gIGV4cGlyZXNBdDogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRlbmFudFVzZXJzKGRiOiBEYXRhYmFzZSwgdGVuYW50SWQ6IHN0cmluZywgY3VycmVudFVzZXJJZD86IHN0cmluZykge1xuICAvLyBHZXQgYWxsIGFkbWlucyAod2hpY2ggbm93IGluY2x1ZGUgbWVtYmVycywgYWRtaW5zLCBhbmQgc3VwZXJhZG1pbnMpXG4gIGNvbnN0IGFkbWlucyA9IGF3YWl0IGRiLmFkbWluLmZpbmRNYW55KHtcbiAgICB3aGVyZTogeyB0ZW5hbnRJZCB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgaWQ6IHRydWUsXG4gICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgIG5hbWU6IHRydWUsXG4gICAgICBnaXZlbk5hbWU6IHRydWUsXG4gICAgICBmYW1pbHlOYW1lOiB0cnVlLFxuICAgICAgcm9sZTogdHJ1ZSxcbiAgICAgIGNyZWF0ZWRBdDogdHJ1ZSxcbiAgICAgIHVwZGF0ZWRBdDogdHJ1ZSxcbiAgICB9LFxuICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImFzY1wiIH0sXG4gIH0pO1xuXG4gIC8vIEZvcm1hdCByZXN1bHRzXG4gIGNvbnN0IHVzZXJzID0gYWRtaW5zLm1hcCgoYWRtaW4pID0+ICh7XG4gICAgaWQ6IGFkbWluLmlkLFxuICAgIGVtYWlsOiBhZG1pbi5lbWFpbCxcbiAgICBuYW1lOiBhZG1pbi5uYW1lIHx8IGAke2FkbWluLmdpdmVuTmFtZSB8fCBcIlwifSAke2FkbWluLmZhbWlseU5hbWUgfHwgXCJcIn1gLnRyaW0oKSB8fCB1bmRlZmluZWQsXG4gICAgcm9sZTogYWRtaW4ucm9sZSxcbiAgICBjcmVhdGVkQXQ6IGFkbWluLmNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogYWRtaW4udXBkYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gIH0pKTtcblxuICAvLyBGaWx0ZXIgb3V0IHRoZSBjdXJyZW50IHVzZXIgaWYgcHJvdmlkZWRcbiAgaWYgKGN1cnJlbnRVc2VySWQpIHtcbiAgICByZXR1cm4gdXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB1c2VyLmlkICE9PSBjdXJyZW50VXNlcklkKTtcbiAgfVxuXG4gIHJldHVybiB1c2Vycztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRlbmFudEludml0YXRpb25zKGRiOiBEYXRhYmFzZSwgdGVuYW50SWQ6IHN0cmluZykge1xuICBjb25zdCBpbnZpdGF0aW9ucyA9IGF3YWl0IGRiLnRlbmFudEludml0YXRpb24uZmluZE1hbnkoe1xuICAgIHdoZXJlOiB7IHRlbmFudElkIH0sXG4gICAgaW5jbHVkZToge1xuICAgICAgaW52aXRlZEJ5OiB7XG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICAgIG5hbWU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYWNjZXB0ZWRCeToge1xuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgICBuYW1lOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9LFxuICB9KTtcblxuICByZXR1cm4gaW52aXRhdGlvbnMubWFwKChpbnYpID0+ICh7XG4gICAgaWQ6IGludi5pZCxcbiAgICBlbWFpbDogaW52LmVtYWlsLFxuICAgIHJvbGU6IGludi5yb2xlLFxuICAgIHN0YXR1czogaW52LnN0YXR1cyxcbiAgICBpbnZpdGVkQnk6IHtcbiAgICAgIGlkOiBpbnYuaW52aXRlZEJ5LmlkLFxuICAgICAgZW1haWw6IGludi5pbnZpdGVkQnkuZW1haWwsXG4gICAgICBuYW1lOiBpbnYuaW52aXRlZEJ5Lm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgYWNjZXB0ZWRCeTogaW52LmFjY2VwdGVkQnlcbiAgICAgID8ge1xuICAgICAgICAgIGlkOiBpbnYuYWNjZXB0ZWRCeS5pZCxcbiAgICAgICAgICBlbWFpbDogaW52LmFjY2VwdGVkQnkuZW1haWwsXG4gICAgICAgICAgbmFtZTogaW52LmFjY2VwdGVkQnkubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkLFxuICAgIGV4cGlyZXNBdDogaW52LmV4cGlyZXNBdC50b0lTT1N0cmluZygpLFxuICAgIGNyZWF0ZWRBdDogaW52LmNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICB9KSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVJbnZpdGF0aW9uKFxuICBkYjogRGF0YWJhc2UsXG4gIHRlbmFudElkOiBzdHJpbmcsXG4gIGVtYWlsOiBzdHJpbmcsXG4gIHJvbGU6IFRlbmFudFJvbGUsXG4gIGludml0ZWRCeUlkOiBzdHJpbmcsXG4gIGxvZ2dlcjogTG9nZ2VyLFxuKSB7XG4gIC8vIENoZWNrIGlmIHVzZXIgaXMgYWxyZWFkeSBhIG1lbWJlclxuICBjb25zdCBleGlzdGluZ1VzZXIgPSBhd2FpdCBkYi5hZG1pbi5maW5kRmlyc3Qoe1xuICAgIHdoZXJlOiB7IGVtYWlsLCB0ZW5hbnRJZCB9LFxuICB9KTtcblxuICBpZiAoZXhpc3RpbmdVc2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBpcyBhbHJlYWR5IGEgbWVtYmVyIG9mIHRoaXMgdGVuYW50XCIpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgcGVuZGluZyBpbnZpdGF0aW9uXG4gIGNvbnN0IGV4aXN0aW5nUGVuZGluZ0ludml0YXRpb24gPSBhd2FpdCBkYi50ZW5hbnRJbnZpdGF0aW9uLmZpbmRGaXJzdCh7XG4gICAgd2hlcmU6IHsgZW1haWwsIHRlbmFudElkLCBzdGF0dXM6IEludml0YXRpb25TdGF0dXMucGVuZGluZyB9LFxuICB9KTtcblxuICBpZiAoZXhpc3RpbmdQZW5kaW5nSW52aXRhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgYWxyZWFkeSBoYXMgYSBwZW5kaW5nIGludml0YXRpb25cIik7XG4gIH1cblxuICAvLyBJZiB0aGVyZSdzIGEgY2FuY2VsbGVkIGludml0YXRpb24sIHdlJ2xsIHVwZGF0ZSBpdCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZVxuICBjb25zdCBleGlzdGluZ0NhbmNlbGxlZEludml0YXRpb24gPSBhd2FpdCBkYi50ZW5hbnRJbnZpdGF0aW9uLmZpbmRGaXJzdCh7XG4gICAgd2hlcmU6IHsgZW1haWwsIHRlbmFudElkLCBzdGF0dXM6IEludml0YXRpb25TdGF0dXMuY2FuY2VsbGVkIH0sXG4gIH0pO1xuXG4gIC8vIFZlcmlmeSB0aGUgaW52aXRlciBleGlzdHNcbiAgY29uc3QgaW52aXRlciA9IGF3YWl0IGRiLmFkbWluLmZpbmRVbmlxdWUoe1xuICAgIHdoZXJlOiB7IGlkOiBpbnZpdGVkQnlJZCB9LFxuICB9KTtcblxuICBpZiAoIWludml0ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludml0ZXIgSURcIik7XG4gIH1cblxuICBjb25zdCB0b2tlbiA9IHJhbmRvbUJ5dGVzKDMyKS50b1N0cmluZyhcImhleFwiKTtcbiAgY29uc3QgZXhwaXJlc0F0ID0gYWRkRGF5cyhuZXcgRGF0ZSgpLCA3KTsgLy8gNyBkYXlzIGV4cGlyYXRpb25cblxuICBsZXQgaW52aXRhdGlvbjtcblxuICBpZiAoZXhpc3RpbmdDYW5jZWxsZWRJbnZpdGF0aW9uKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBjYW5jZWxsZWQgaW52aXRhdGlvblxuICAgIGludml0YXRpb24gPSBhd2FpdCBkYi50ZW5hbnRJbnZpdGF0aW9uLnVwZGF0ZSh7XG4gICAgICB3aGVyZTogeyBpZDogZXhpc3RpbmdDYW5jZWxsZWRJbnZpdGF0aW9uLmlkIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJvbGUsXG4gICAgICAgIGludml0ZWRCeUlkLFxuICAgICAgICB0b2tlbixcbiAgICAgICAgZXhwaXJlc0F0LFxuICAgICAgICBzdGF0dXM6IEludml0YXRpb25TdGF0dXMucGVuZGluZyxcbiAgICAgICAgYWNjZXB0ZWRCeUlkOiBudWxsLCAvLyBDbGVhciBhbnkgcHJldmlvdXMgYWNjZXB0YW5jZVxuICAgICAgfSxcbiAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgaW52aXRlZEJ5OiB7XG4gICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICAgICAgbmFtZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgaW52aXRhdGlvblxuICAgIGludml0YXRpb24gPSBhd2FpdCBkYi50ZW5hbnRJbnZpdGF0aW9uLmNyZWF0ZSh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRlbmFudElkLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgcm9sZSxcbiAgICAgICAgaW52aXRlZEJ5SWQsXG4gICAgICAgIHRva2VuLFxuICAgICAgICBleHBpcmVzQXQsXG4gICAgICB9LFxuICAgICAgaW5jbHVkZToge1xuICAgICAgICBpbnZpdGVkQnk6IHtcbiAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgICAgZW1haWw6IHRydWUsXG4gICAgICAgICAgICBuYW1lOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLy8gRmV0Y2ggaW52aXRlciBhbmQgdGVuYW50XG4gIGNvbnN0IHRlbmFudCA9IGF3YWl0IGRiLnRlbmFudC5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHRlbmFudElkIH0gfSk7XG4gIGNvbnN0IGludml0YXRpb25MaW5rID0gYCR7YmFzZVVybH0vaW52aXRlLyR7aW52aXRhdGlvbi50b2tlbn1gO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgc2VuZFRlbmFudEludml0YXRpb25FbWFpbChcbiAgICAgIGxvZ2dlcixcbiAgICAgIGludml0YXRpb24uZW1haWwsXG4gICAgICBpbnZpdGVyPy5uYW1lIHx8IGludml0ZXI/LmVtYWlsIHx8IFwiU29tZW9uZVwiLFxuICAgICAgdGVuYW50Py5uYW1lIHx8IFwiVGVuYW50XCIsXG4gICAgICBpbnZpdGF0aW9uTGluayxcbiAgICAgIGludml0YXRpb24ucm9sZSxcbiAgICAgIGludml0YXRpb24uZXhwaXJlc0F0LFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCB0byBzZW5kIHRlbmFudCBpbnZpdGF0aW9uIGVtYWlsXCIsIGVycik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkOiBpbnZpdGF0aW9uLmlkLFxuICAgIGVtYWlsOiBpbnZpdGF0aW9uLmVtYWlsLFxuICAgIHJvbGU6IGludml0YXRpb24ucm9sZSxcbiAgICBzdGF0dXM6IGludml0YXRpb24uc3RhdHVzLFxuICAgIGludml0ZWRCeToge1xuICAgICAgaWQ6IGludml0YXRpb24uaW52aXRlZEJ5LmlkLFxuICAgICAgZW1haWw6IGludml0YXRpb24uaW52aXRlZEJ5LmVtYWlsLFxuICAgICAgbmFtZTogaW52aXRhdGlvbi5pbnZpdGVkQnkubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgfSxcbiAgICB0ZW5hbnROYW1lOiB0ZW5hbnQ/Lm5hbWUgfHwgXCJUZW5hbnRcIixcbiAgICB0b2tlbjogaW52aXRhdGlvbi50b2tlbixcbiAgICBleHBpcmVzQXQ6IGludml0YXRpb24uZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCksXG4gICAgY3JlYXRlZEF0OiBpbnZpdGF0aW9uLmNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWNjZXB0SW52aXRhdGlvbihkYjogRGF0YWJhc2UsIHRva2VuOiBzdHJpbmcpIHtcbiAgY29uc3QgaW52aXRhdGlvbiA9IGF3YWl0IGRiLnRlbmFudEludml0YXRpb24uZmluZFVuaXF1ZSh7XG4gICAgd2hlcmU6IHsgdG9rZW4gfSxcbiAgICBpbmNsdWRlOiB7IHRlbmFudDogdHJ1ZSB9LFxuICB9KTtcblxuICBpZiAoIWludml0YXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludml0YXRpb24gdG9rZW5cIik7XG4gIH1cblxuICBpZiAoaW52aXRhdGlvbi5zdGF0dXMgIT09IEludml0YXRpb25TdGF0dXMucGVuZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludml0YXRpb24gaXMgbm8gbG9uZ2VyIHZhbGlkXCIpO1xuICB9XG5cbiAgaWYgKGludml0YXRpb24uZXhwaXJlc0F0IDwgbmV3IERhdGUoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludml0YXRpb24gaGFzIGV4cGlyZWRcIik7XG4gIH1cblxuICAvLyBDaGVjayBpZiB1c2VyIGFscmVhZHkgZXhpc3RzIGluIHRoZSB0ZW5hbnRcbiAgY29uc3QgZXhpc3RpbmdVc2VyID0gYXdhaXQgZGIuYWRtaW4uZmluZEZpcnN0KHtcbiAgICB3aGVyZTogeyBlbWFpbDogaW52aXRhdGlvbi5lbWFpbCwgdGVuYW50SWQ6IGludml0YXRpb24udGVuYW50SWQgfSxcbiAgfSk7XG5cbiAgaWYgKGV4aXN0aW5nVXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgaXMgYWxyZWFkeSBhIG1lbWJlciBvZiB0aGlzIHRlbmFudFwiKTtcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGEgbmV3IHVzZXIgSURcbiAgY29uc3QgdXNlcklkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcblxuICAvLyBDcmVhdGUgdXNlciBpbiBBZG1pbiB0YWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgcm9sZVxuICBjb25zdCBhZG1pblJvbGUgPSBpbnZpdGF0aW9uLnJvbGUgYXMgQWRtaW5Sb2xlO1xuICBhd2FpdCBkYi5hZG1pbi5jcmVhdGUoe1xuICAgIGRhdGE6IHtcbiAgICAgIGlkOiB1c2VySWQsXG4gICAgICB0ZW5hbnRJZDogaW52aXRhdGlvbi50ZW5hbnRJZCxcbiAgICAgIGVtYWlsOiBpbnZpdGF0aW9uLmVtYWlsLFxuICAgICAgcm9sZTogYWRtaW5Sb2xlLFxuICAgICAgZW5hYmxlZDogdHJ1ZSwgLy8gQXV0by1lbmFibGUgdGhlIHVzZXJcbiAgICAgIGVtYWlsVmVyaWZpZWQ6IHRydWUsIC8vIE1hcmsgYXMgdmVyaWZpZWQgc2luY2UgdGhleSBjYW1lIHRocm91Z2ggaW52aXRhdGlvblxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIFVwZGF0ZSBpbnZpdGF0aW9uIHN0YXR1c1xuICBhd2FpdCBkYi50ZW5hbnRJbnZpdGF0aW9uLnVwZGF0ZSh7XG4gICAgd2hlcmU6IHsgaWQ6IGludml0YXRpb24uaWQgfSxcbiAgICBkYXRhOiB7XG4gICAgICBzdGF0dXM6IEludml0YXRpb25TdGF0dXMuYWNjZXB0ZWQsXG4gICAgICBhY2NlcHRlZEJ5SWQ6IHVzZXJJZCxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHRlbmFudElkOiBpbnZpdGF0aW9uLnRlbmFudElkLFxuICAgIHRlbmFudE5hbWU6IGludml0YXRpb24udGVuYW50Lm5hbWUsXG4gICAgcm9sZTogaW52aXRhdGlvbi5yb2xlLFxuICAgIHVzZXJJZDogdXNlcklkLFxuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlclJvbGUoZGI6IERhdGFiYXNlLCB0ZW5hbnRJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcm9sZTogQWRtaW5Sb2xlKSB7XG4gIC8vIENoZWNrIGlmIHVzZXIgZXhpc3RzXG4gIGNvbnN0IGFkbWluID0gYXdhaXQgZGIuYWRtaW4uZmluZEZpcnN0KHtcbiAgICB3aGVyZTogeyBpZDogdXNlcklkLCB0ZW5hbnRJZCB9LFxuICB9KTtcblxuICBpZiAoIWFkbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBpcyBub3QgYSBtZW1iZXIgb2YgdGhpcyB0ZW5hbnRcIik7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGFkbWluJ3Mgcm9sZVxuICBjb25zdCB1cGRhdGVkQWRtaW4gPSBhd2FpdCBkYi5hZG1pbi51cGRhdGUoe1xuICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICBkYXRhOiB7IHJvbGUgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBpZDogdXBkYXRlZEFkbWluLmlkLFxuICAgIGVtYWlsOiB1cGRhdGVkQWRtaW4uZW1haWwsXG4gICAgbmFtZTogdXBkYXRlZEFkbWluLm5hbWUgfHwgYCR7dXBkYXRlZEFkbWluLmdpdmVuTmFtZSB8fCBcIlwifSAke3VwZGF0ZWRBZG1pbi5mYW1pbHlOYW1lIHx8IFwiXCJ9YC50cmltKCkgfHwgdW5kZWZpbmVkLFxuICAgIHJvbGU6IHVwZGF0ZWRBZG1pbi5yb2xlLFxuICAgIGNyZWF0ZWRBdDogdXBkYXRlZEFkbWluLmNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogdXBkYXRlZEFkbWluLnVwZGF0ZWRBdC50b0lTT1N0cmluZygpLFxuICB9O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVtb3ZlVXNlckZyb21UZW5hbnQoZGI6IERhdGFiYXNlLCB0ZW5hbnRJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZykge1xuICAvLyBDaGVjayBpZiB1c2VyIGV4aXN0c1xuICBjb25zdCBhZG1pbiA9IGF3YWl0IGRiLmFkbWluLmZpbmRGaXJzdCh7XG4gICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCwgdGVuYW50SWQgfSxcbiAgfSk7XG5cbiAgaWYgKCFhZG1pbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgaXMgbm90IGEgbWVtYmVyIG9mIHRoaXMgdGVuYW50XCIpO1xuICB9XG5cbiAgLy8gRGVsZXRlIGZyb20gYWRtaW4gdGFibGVcbiAgYXdhaXQgZGIuYWRtaW4uZGVsZXRlKHsgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9IH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FuY2VsSW52aXRhdGlvbihkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIGludml0YXRpb25JZDogc3RyaW5nKSB7XG4gIGNvbnN0IGludml0YXRpb24gPSBhd2FpdCBkYi50ZW5hbnRJbnZpdGF0aW9uLmZpbmRGaXJzdCh7XG4gICAgd2hlcmU6IHsgaWQ6IGludml0YXRpb25JZCwgdGVuYW50SWQgfSxcbiAgfSk7XG5cbiAgaWYgKCFpbnZpdGF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52aXRhdGlvbiBub3QgZm91bmRcIik7XG4gIH1cblxuICBpZiAoaW52aXRhdGlvbi5zdGF0dXMgIT09IEludml0YXRpb25TdGF0dXMucGVuZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYW5jZWwgbm9uLXBlbmRpbmcgaW52aXRhdGlvblwiKTtcbiAgfVxuXG4gIHJldHVybiBkYi50ZW5hbnRJbnZpdGF0aW9uLnVwZGF0ZSh7XG4gICAgd2hlcmU6IHsgaWQ6IGludml0YXRpb25JZCB9LFxuICAgIGRhdGE6IHsgc3RhdHVzOiBJbnZpdGF0aW9uU3RhdHVzLmNhbmNlbGxlZCB9LFxuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUZW5hbnRzKGRiOiBEYXRhYmFzZSwgdXNlcklkOiBzdHJpbmcpIHtcbiAgLy8gR2V0IHVzZXIncyB0ZW5hbnRzIGZyb20gYWRtaW4gdGFibGUgKHdoaWNoIG5vdyBpbmNsdWRlcyBhbGwgcm9sZXMpXG4gIGNvbnN0IGFkbWluVGVuYW50cyA9IGF3YWl0IGRiLmFkbWluLmZpbmRNYW55KHtcbiAgICB3aGVyZTogeyBpZDogdXNlcklkIH0sXG4gICAgaW5jbHVkZToge1xuICAgICAgdGVuYW50OiB7XG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIG5hbWU6IHRydWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgb3JkZXJCeTogeyBjcmVhdGVkQXQ6IFwiYXNjXCIgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIGFkbWluVGVuYW50cy5tYXAoKGFkbWluKSA9PiAoe1xuICAgIGlkOiBhZG1pbi50ZW5hbnQuaWQsXG4gICAgbmFtZTogYWRtaW4udGVuYW50Lm5hbWUsXG4gICAgZGVzY3JpcHRpb246IGFkbWluLnRlbmFudC5kZXNjcmlwdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgcm9sZTogYWRtaW4ucm9sZSxcbiAgICBqb2luZWRBdDogYWRtaW4uY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCksXG4gIH0pKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzVXNlclRlbmFudEFkbWluKGRiOiBEYXRhYmFzZSwgdGVuYW50SWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgYWRtaW4gPSBhd2FpdCBkYi5hZG1pbi5maW5kRmlyc3Qoe1xuICAgIHdoZXJlOiB7IGlkOiB1c2VySWQsIHRlbmFudElkIH0sXG4gIH0pO1xuXG4gIHJldHVybiAhIWFkbWluO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SW52aXRhdGlvbkJ5VG9rZW4oZGI6IERhdGFiYXNlLCB0b2tlbjogc3RyaW5nKSB7XG4gIGNvbnN0IGludml0YXRpb24gPSBhd2FpdCBkYi50ZW5hbnRJbnZpdGF0aW9uLmZpbmRVbmlxdWUoe1xuICAgIHdoZXJlOiB7IHRva2VuIH0sXG4gICAgaW5jbHVkZToge1xuICAgICAgdGVuYW50OiB7XG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIG5hbWU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgaW52aXRlZEJ5OiB7XG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIGVtYWlsOiB0cnVlLFxuICAgICAgICAgIG5hbWU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuXG4gIGlmICghaW52aXRhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW52aXRhdGlvbiB0b2tlblwiKTtcbiAgfVxuXG4gIGlmIChpbnZpdGF0aW9uLnN0YXR1cyAhPT0gSW52aXRhdGlvblN0YXR1cy5wZW5kaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52aXRhdGlvbiBpcyBubyBsb25nZXIgdmFsaWRcIik7XG4gIH1cblxuICBpZiAoaW52aXRhdGlvbi5leHBpcmVzQXQgPCBuZXcgRGF0ZSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52aXRhdGlvbiBoYXMgZXhwaXJlZFwiKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaWQ6IGludml0YXRpb24uaWQsXG4gICAgZW1haWw6IGludml0YXRpb24uZW1haWwsXG4gICAgcm9sZTogaW52aXRhdGlvbi5yb2xlLFxuICAgIHN0YXR1czogaW52aXRhdGlvbi5zdGF0dXMsXG4gICAgdGVuYW50TmFtZTogaW52aXRhdGlvbi50ZW5hbnQubmFtZSxcbiAgICBpbnZpdGVkQnk6IHtcbiAgICAgIGlkOiBpbnZpdGF0aW9uLmludml0ZWRCeS5pZCxcbiAgICAgIGVtYWlsOiBpbnZpdGF0aW9uLmludml0ZWRCeS5lbWFpbCxcbiAgICAgIG5hbWU6IGludml0YXRpb24uaW52aXRlZEJ5Lm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgIH0sXG4gICAgZXhwaXJlc0F0OiBpbnZpdGF0aW9uLmV4cGlyZXNBdC50b0lTT1N0cmluZygpLFxuICAgIGNyZWF0ZWRBdDogaW52aXRhdGlvbi5jcmVhdGVkQXQudG9JU09TdHJpbmcoKSxcbiAgfTtcbn1cblxuLy8gUm9sZSBjaGVja2luZyBmdW5jdGlvbnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5NYW5hZ2VVc2VycyhkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGFkbWluID0gYXdhaXQgZGIuYWRtaW4uZmluZEZpcnN0KHtcbiAgICB3aGVyZTogeyBpZDogdXNlcklkLCB0ZW5hbnRJZCB9LFxuICB9KTtcblxuICBpZiAoIWFkbWluKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT25seSBhZG1pbnMgYW5kIHN1cGVyYWRtaW5zIGNhbiBtYW5hZ2UgdXNlcnNcbiAgcmV0dXJuIGFkbWluLnJvbGUgPT09IEFkbWluUm9sZS5hZG1pbiB8fCBhZG1pbi5yb2xlID09PSBBZG1pblJvbGUuc3VwZXJhZG1pbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbk1hbmFnZVJvbGVzKGRiOiBEYXRhYmFzZSwgdGVuYW50SWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgYWRtaW4gPSBhd2FpdCBkYi5hZG1pbi5maW5kRmlyc3Qoe1xuICAgIHdoZXJlOiB7IGlkOiB1c2VySWQsIHRlbmFudElkIH0sXG4gIH0pO1xuXG4gIGlmICghYWRtaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBPbmx5IGFkbWlucyBhbmQgc3VwZXJhZG1pbnMgY2FuIG1hbmFnZSByb2xlc1xuICByZXR1cm4gYWRtaW4ucm9sZSA9PT0gQWRtaW5Sb2xlLmFkbWluIHx8IGFkbWluLnJvbGUgPT09IEFkbWluUm9sZS5zdXBlcmFkbWluO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FuUmVtb3ZlVXNlcnMoZGI6IERhdGFiYXNlLCB0ZW5hbnRJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBhZG1pbiA9IGF3YWl0IGRiLmFkbWluLmZpbmRGaXJzdCh7XG4gICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCwgdGVuYW50SWQgfSxcbiAgfSk7XG5cbiAgaWYgKCFhZG1pbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE9ubHkgYWRtaW5zIGFuZCBzdXBlcmFkbWlucyBjYW4gcmVtb3ZlIHVzZXJzXG4gIHJldHVybiBhZG1pbi5yb2xlID09PSBBZG1pblJvbGUuYWRtaW4gfHwgYWRtaW4ucm9sZSA9PT0gQWRtaW5Sb2xlLnN1cGVyYWRtaW47XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5JbnZpdGVVc2VycyhkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGFkbWluID0gYXdhaXQgZGIuYWRtaW4uZmluZEZpcnN0KHtcbiAgICB3aGVyZTogeyBpZDogdXNlcklkLCB0ZW5hbnRJZCB9LFxuICB9KTtcblxuICBpZiAoIWFkbWluKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT25seSBhZG1pbnMgYW5kIHN1cGVyYWRtaW5zIGNhbiBpbnZpdGUgdXNlcnNcbiAgcmV0dXJuIGFkbWluLnJvbGUgPT09IEFkbWluUm9sZS5hZG1pbiB8fCBhZG1pbi5yb2xlID09PSBBZG1pblJvbGUuc3VwZXJhZG1pbjtcbn1cbiIsICJpbXBvcnQgeyBBZG1pblJvbGUgfSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcbmltcG9ydCB7IE5leHRGdW5jdGlvbiwgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgU3RhdHVzQ29kZXMgfSBmcm9tIFwiaHR0cC1zdGF0dXMtY29kZXNcIjtcbmltcG9ydCB7IGlzQWRtaW5SZXF1ZXN0LCBUeXBlR3VhcmRFcnJvciB9IGZyb20gXCIuLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCByZXF1aXJlUm9sZSA9IChyZXF1aXJlZFJvbGVzOiBBZG1pblJvbGVbXSkgPT4ge1xuICByZXR1cm4gKHJlcTogUmVxdWVzdCwgcmVzOiBSZXNwb25zZSwgbmV4dDogTmV4dEZ1bmN0aW9uKSA9PiB7XG4gICAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyUm9sZSA9IHJlcS5hZG1pbi5yb2xlO1xuXG4gICAgaWYgKCFyZXF1aXJlZFJvbGVzLmluY2x1ZGVzKHVzZXJSb2xlKSkge1xuICAgICAgcmVxLmxvZ2dlci53YXJuKFwiSW5zdWZmaWNpZW50IHBlcm1pc3Npb25zXCIsIHtcbiAgICAgICAgdXNlclJvbGUsXG4gICAgICAgIHJlcXVpcmVkUm9sZXMsXG4gICAgICAgIHVzZXJJZDogcmVxLmFkbWluLmlkLFxuICAgICAgICBwYXRoOiByZXEucGF0aCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5GT1JCSURERU4pLmpzb24oe1xuICAgICAgICBlcnJvcjogXCJpbnN1ZmZpY2llbnRfcGVybWlzc2lvbnNcIixcbiAgICAgICAgZXJyb3JEZXNjcmlwdGlvbjogXCJZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb25cIixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5leHQoKTtcbiAgfTtcbn07XG5cbi8vIENvbnZlbmllbmNlIG1pZGRsZXdhcmUgZm9yIHNwZWNpZmljIHJvbGVzXG5leHBvcnQgY29uc3QgcmVxdWlyZUFkbWluID0gcmVxdWlyZVJvbGUoW0FkbWluUm9sZS5hZG1pbiwgQWRtaW5Sb2xlLnN1cGVyYWRtaW5dKTtcbmV4cG9ydCBjb25zdCByZXF1aXJlU3VwZXJBZG1pbiA9IHJlcXVpcmVSb2xlKFtBZG1pblJvbGUuc3VwZXJhZG1pbl0pO1xuZXhwb3J0IGNvbnN0IHJlcXVpcmVNZW1iZXIgPSByZXF1aXJlUm9sZShbQWRtaW5Sb2xlLmFkbWluLCBBZG1pblJvbGUuc3VwZXJhZG1pbl0pO1xuIiwgImltcG9ydCB7IFJvdXRlciB9IGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBkZWxldGVVc2VyVG9rZW5zLCBsaXN0VXNlclRva2VucywgcmV2b2tlUHJvdmlkZXJUb2tlbiB9IGZyb20gXCIuLi9jb250cm9sbGVycy90b2tlbnMuY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IHsgYmxvY2tVc2VyLCBnZXRVc2VyLCBsaXN0VXNlcnMgfSBmcm9tIFwiLi4vY29udHJvbGxlcnMvdXNlcnMuY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IHsgYWRtaW5TZXNzaW9uTWlkZGxld2FyZSB9IGZyb20gXCIuLi9taWRkbGV3YXJlcy9zZXNzaW9uLm1pZGRsZXdhcmUuanNcIjtcblxuY29uc3Qgcm91dGVyOiBSb3V0ZXIgPSBSb3V0ZXIoKTtcblxucm91dGVyLmdldChcIi9cIiwgbGlzdFVzZXJzKTtcbnJvdXRlci5nZXQoXCIvOnVzZXJJZFwiLCBnZXRVc2VyKTtcbnJvdXRlci5wb3N0KFwiLzp1c2VySWRcIiwgYmxvY2tVc2VyKTtcblxucm91dGVyLmdldChcIi86dXNlcklkL3Rva2Vuc1wiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCBsaXN0VXNlclRva2Vucyk7XG5yb3V0ZXIuZGVsZXRlKFwiLzp1c2VySWQvdG9rZW5zXCIsIGFkbWluU2Vzc2lvbk1pZGRsZXdhcmUsIGRlbGV0ZVVzZXJUb2tlbnMpO1xucm91dGVyLmRlbGV0ZShcIi86dXNlcklkL3Rva2Vucy86dG9rZW5JZFwiLCBhZG1pblNlc3Npb25NaWRkbGV3YXJlLCByZXZva2VQcm92aWRlclRva2VuKTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVyO1xuIiwgImltcG9ydCB7IFByb3ZpZGVyVG9rZW4gfSBmcm9tIFwiQGFnZW50YnJpZGdlL2FwaVwiO1xuaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgU3RhdHVzQ29kZXMgfSBmcm9tIFwiaHR0cC1zdGF0dXMtY29kZXNcIjtcbmltcG9ydCAqIGFzIHRva2Vuc1NlcnZpY2UgZnJvbSBcIi4uL3NlcnZpY2VzL3Rva2Vucy5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBpc0FkbWluUmVxdWVzdCwgVHlwZUd1YXJkRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvcmVxLWd1YXJkcy5qc1wiO1xuXG5leHBvcnQgY29uc3QgbGlzdFVzZXJUb2tlbnMgPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdDx7IHVzZXJJZD86IHN0cmluZyB9LCBvYmplY3QsIG9iamVjdCwgeyBpbmNsdWRlRXhwaXJlZD86IHN0cmluZzsgcHJvdmlkZXI/OiBzdHJpbmc7IHNjb3BlPzogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgaWYgKCFyZXEucGFyYW1zLnVzZXJJZCkge1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QpLmpzb24oeyBlcnJvcjogXCJVc2VyIElEIGlzIHJlcXVpcmVkXCIgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5kZWJ1ZyhcIkxpc3RpbmcgdXNlciB0b2tlbnNcIiwge1xuICAgIHVzZXJJZDogcmVxLnBhcmFtcy51c2VySWQsXG4gICAgcXVlcnk6IHJlcS5xdWVyeSxcbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB0b2tlbnM6IFByb3ZpZGVyVG9rZW5bXSA9IGF3YWl0IHRva2Vuc1NlcnZpY2UubGlzdFVzZXJUb2tlbnMocmVxLmRiLCByZXEucGFyYW1zLnVzZXJJZCwgcmVxLmFkbWluLnRlbmFudElkLCB7XG4gICAgICBpbmNsdWRlRXhwaXJlZDogcmVxLnF1ZXJ5LmluY2x1ZGVFeHBpcmVkID09PSBcInRydWVcIixcbiAgICAgIHByb3ZpZGVyTmFtZTogcmVxLnF1ZXJ5LnByb3ZpZGVyIGFzIHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgIHNjb3BlOiByZXEucXVlcnkuc2NvcGUgYXMgc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgcmVzLmpzb24odG9rZW5zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxpc3QgdXNlciB0b2tlbnNcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHsgZXJyb3I6IFwiRmFpbGVkIHRvIGxpc3QgdXNlciB0b2tlbnNcIiB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJldm9rZVByb3ZpZGVyVG9rZW4gPSBhc3luYyAocmVxOiBSZXF1ZXN0PHsgdXNlcklkOiBzdHJpbmc7IHRva2VuSWQ6IHN0cmluZyB9PiwgcmVzOiBSZXNwb25zZSkgPT4ge1xuICBpZiAoIWlzQWRtaW5SZXF1ZXN0KHJlcSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUd1YXJkRXJyb3IoKTtcbiAgfVxuXG4gIHJlcS5sb2dnZXIuaW5mbyhcIlJldm9raW5nIHByb3ZpZGVyIHRva2VuXCIsIHtcbiAgICB1c2VySWQ6IHJlcS5wYXJhbXMudXNlcklkLFxuICAgIHRva2VuSWQ6IHJlcS5wYXJhbXMudG9rZW5JZCxcbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyRXhpc3RzID0gYXdhaXQgdG9rZW5zU2VydmljZS52ZXJpZnlVc2VyRXhpc3RzKHJlcS5kYiwgcmVxLnBhcmFtcy51c2VySWQsIHJlcS5hZG1pbi50ZW5hbnRJZCk7XG5cbiAgICBpZiAoIXVzZXJFeGlzdHMpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgZXJyb3I6IFwiVXNlciBub3QgZm91bmRcIiB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCB0b2tlbnNTZXJ2aWNlLnJldm9rZVRva2VuKHJlcS5kYiwgcmVxLnBhcmFtcy50b2tlbklkLCByZXEucGFyYW1zLnVzZXJJZCk7XG5cbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk5PX0NPTlRFTlQpLnNlbmQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHJldm9rZSBwcm92aWRlciB0b2tlblwiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gcmV2b2tlIHByb3ZpZGVyIHRva2VuXCIgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVVc2VyVG9rZW5zID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHVzZXJJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5pbmZvKFwiRGVsZXRpbmcgdXNlciB0b2tlbnNcIiwgeyB1c2VySWQ6IHJlcS5wYXJhbXMudXNlcklkIH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRva2Vuc1NlcnZpY2UuZ2V0VXNlckJ5SWRTbGltKHJlcS5kYiwgcmVxLnBhcmFtcy51c2VySWQsIHJlcS5hZG1pbi50ZW5hbnRJZCk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgZXJyb3I6IFwiVXNlciBub3QgZm91bmRcIiB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCB0b2tlbnNTZXJ2aWNlLmRlbGV0ZVVzZXJUb2tlbnMocmVxLmRiLCByZXEucGFyYW1zLnVzZXJJZCk7XG5cbiAgICB0b2tlbnNTZXJ2aWNlLmNsZWFyVXNlclRva2VuQ2FjaGUodXNlci5lbWFpbCk7XG5cbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk5PX0NPTlRFTlQpLnNlbmQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGRlbGV0ZSB1c2VyIHRva2Vuc1wiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gZGVsZXRlIHVzZXIgdG9rZW5zXCIgfSk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHsgUHJvdmlkZXJUb2tlbiB9IGZyb20gXCJAYWdlbnRicmlkZ2UvYXBpXCI7XG5pbXBvcnQgeyBQcm92aWRlclRva2VuIGFzIFByaXNtYVByb3ZpZGVyVG9rZW4gfSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSBcIi4uL3V0aWxzL2Nvbm5lY3Rpb24uanNcIjtcbmltcG9ydCB7IENhY2hlSXRlbVR5cGUsIGNsZWFyQ2FjaGVCeVBhcnRpYWxLZXkgfSBmcm9tIFwiLi9jYWNoZS5zZXJ2aWNlLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBtYXBUb2tlbiA9ICh0b2tlbjogUHJpc21hUHJvdmlkZXJUb2tlbiAmIHsgcHJvdmlkZXI6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0gfSk6IFByb3ZpZGVyVG9rZW4gPT4gKHtcbiAgaWQ6IHRva2VuLmlkLFxuICBwcm92aWRlcklkOiB0b2tlbi5wcm92aWRlci5pZCxcbiAgcHJvdmlkZXJOYW1lOiB0b2tlbi5wcm92aWRlci5uYW1lLFxuICBzY29wZXM6IHRva2VuLnNjb3BlcyxcbiAgaXNzdWVkQXQ6IHRva2VuLmlzc3VlZEF0LnRvSVNPU3RyaW5nKCksXG4gIGV4cGlyZXNBdDogdG9rZW4uZXhwaXJlc0F0ID8gdG9rZW4uZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCkgOiB1bmRlZmluZWQsXG59KTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3RVc2VyVG9rZW5zKFxuICBkYjogRGF0YWJhc2UsXG4gIHVzZXJJZDogc3RyaW5nLFxuICB0ZW5hbnRJZDogc3RyaW5nLFxuICBvcHRpb25zOiB7XG4gICAgaW5jbHVkZUV4cGlyZWQ/OiBib29sZWFuO1xuICAgIHByb3ZpZGVyTmFtZT86IHN0cmluZztcbiAgICBzY29wZT86IHN0cmluZztcbiAgfSxcbik6IFByb21pc2U8UHJvdmlkZXJUb2tlbltdPiB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG5cbiAgY29uc3QgdG9rZW5zID0gYXdhaXQgZGIucHJvdmlkZXJUb2tlbi5maW5kTWFueSh7XG4gICAgd2hlcmU6IHtcbiAgICAgIHVzZXJJZDogdXNlcklkLFxuICAgICAgdXNlcjoge1xuICAgICAgICB0ZW5hbnRJZCxcbiAgICAgIH0sXG4gICAgICAuLi4ob3B0aW9ucy5pbmNsdWRlRXhwaXJlZCAhPT0gdHJ1ZSA/IHsgT1I6IFt7IGV4cGlyZXNBdDogeyBndGU6IG5vdyB9IH0sIHsgZXhwaXJlc0F0OiBudWxsIH1dIH0gOiB7fSksXG4gICAgICAuLi4ob3B0aW9ucy5wcm92aWRlck5hbWUgPyB7IHByb3ZpZGVyOiB7IG5hbWU6IG9wdGlvbnMucHJvdmlkZXJOYW1lIH0gfSA6IHt9KSxcbiAgICAgIC4uLihvcHRpb25zLnNjb3BlID8geyBzY29wZXM6IHsgaGFzOiBvcHRpb25zLnNjb3BlIH0gfSA6IHt9KSxcbiAgICB9LFxuICAgIG9yZGVyQnk6IFtcbiAgICAgIHtcbiAgICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgICBuYW1lOiBcImFzY1wiLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYXNjXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgaW5jbHVkZToge1xuICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgbmFtZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIHRva2Vuc1xuICAgIC5maWx0ZXIoKHRva2VuKTogdG9rZW4gaXMgUHJpc21hUHJvdmlkZXJUb2tlbiAmIHsgcHJvdmlkZXI6IHsgaWQ6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0gfSA9PlxuICAgICAgQm9vbGVhbih0b2tlbi5wcm92aWRlciksXG4gICAgKVxuICAgIC5tYXAobWFwVG9rZW4pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5VXNlckV4aXN0cyhkYjogRGF0YWJhc2UsIHVzZXJJZDogc3RyaW5nLCB0ZW5hbnRJZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IHVzZXIgPSBhd2FpdCBkYi5lbmRVc2VyLmZpbmRVbmlxdWUoe1xuICAgIHdoZXJlOiB7XG4gICAgICBpZDogdXNlcklkLFxuICAgICAgdGVuYW50SWQsXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuICEhdXNlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJCeUlkU2xpbShkYjogRGF0YWJhc2UsIHVzZXJJZDogc3RyaW5nLCB0ZW5hbnRJZDogc3RyaW5nKSB7XG4gIHJldHVybiBhd2FpdCBkYi5lbmRVc2VyLmZpbmRVbmlxdWUoe1xuICAgIHdoZXJlOiB7XG4gICAgICBpZDogdXNlcklkLFxuICAgICAgdGVuYW50SWQsXG4gICAgfSxcbiAgICBzZWxlY3Q6IHtcbiAgICAgIGlkOiB0cnVlLFxuICAgICAgZW1haWw6IHRydWUsXG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXZva2VUb2tlbihkYjogRGF0YWJhc2UsIHRva2VuSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgZGIucHJvdmlkZXJUb2tlbi5kZWxldGUoe1xuICAgIHdoZXJlOiB7XG4gICAgICBpZDogdG9rZW5JZCxcbiAgICAgIHVzZXJJZDogdXNlcklkLFxuICAgIH0sXG4gIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVXNlclRva2VucyhkYjogRGF0YWJhc2UsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGF3YWl0IGRiLnByb3ZpZGVyVG9rZW4uZGVsZXRlTWFueSh7XG4gICAgd2hlcmU6IHtcbiAgICAgIHVzZXJJZDogdXNlcklkLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYXJVc2VyVG9rZW5DYWNoZShlbWFpbDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNsZWFyQ2FjaGVCeVBhcnRpYWxLZXkoQ2FjaGVJdGVtVHlwZS5FTkRVU0VSX1RPS0VOLCBlbWFpbCk7XG59XG4iLCAiaW1wb3J0IHsgUmVxdWVzdCwgUmVzcG9uc2UgfSBmcm9tIFwiZXhwcmVzc1wiO1xuaW1wb3J0IHsgU3RhdHVzQ29kZXMgfSBmcm9tIFwiaHR0cC1zdGF0dXMtY29kZXNcIjtcbmltcG9ydCB7IENhY2hlSXRlbVR5cGUsIGNsZWFyQ2FjaGVCeVR5cGUgfSBmcm9tIFwiLi4vc2VydmljZXMvY2FjaGUuc2VydmljZS5qc1wiO1xuaW1wb3J0ICogYXMgdXNlcnNTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy91c2Vycy5zZXJ2aWNlLmpzXCI7XG5pbXBvcnQgeyBxdWVyeVRvQm9vbGVhbiB9IGZyb20gXCIuLi91dGlscy9xc1BhcnNlcnMuanNcIjtcbmltcG9ydCB7IGlzQWRtaW5SZXF1ZXN0LCBUeXBlR3VhcmRFcnJvciB9IGZyb20gXCIuLi91dGlscy9yZXEtZ3VhcmRzLmpzXCI7XG5cbmV4cG9ydCBjb25zdCBsaXN0VXNlcnMgPSBhc3luYyAoXG4gIHJlcTogUmVxdWVzdDxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBvYmplY3QsIG9iamVjdCwgeyBzZWFyY2g/OiBzdHJpbmc7IHBhZ2U/OiBzdHJpbmc7IGxpbWl0Pzogc3RyaW5nIH0+LFxuICByZXM6IFJlc3BvbnNlLFxuKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5kZWJ1ZyhcIkxpc3RpbmcgdXNlcnNcIiwgeyBxdWVyeTogcmVxLnF1ZXJ5IH0pO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdGVuYW50SWQgPSByZXEuYWRtaW4udGVuYW50SWQ7XG4gICAgY29uc3QgcGFnZSA9IHJlcS5xdWVyeS5wYWdlID8gcGFyc2VJbnQocmVxLnF1ZXJ5LnBhZ2UgYXMgc3RyaW5nKSA6IDE7XG4gICAgY29uc3QgbGltaXQgPSByZXEucXVlcnkubGltaXQgPyBwYXJzZUludChyZXEucXVlcnkubGltaXQgYXMgc3RyaW5nKSA6IDIwO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXNlcnNTZXJ2aWNlLmxpc3RVc2VycyhyZXEuZGIsIHRlbmFudElkLCByZXEucXVlcnkuc2VhcmNoIGFzIHN0cmluZywgcGFnZSwgbGltaXQpO1xuXG4gICAgcmVzLmpzb24ocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGxpc3QgdXNlcnNcIiwgZXJyb3IpO1xuICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuSU5URVJOQUxfU0VSVkVSX0VSUk9SKS5qc29uKHsgZXJyb3I6IFwiRmFpbGVkIHRvIGxpc3QgdXNlcnNcIiB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXIgPSBhc3luYyAocmVxOiBSZXF1ZXN0PHsgdXNlcklkOiBzdHJpbmcgfT4sIHJlczogUmVzcG9uc2UpID0+IHtcbiAgaWYgKCFpc0FkbWluUmVxdWVzdChyZXEpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVHdWFyZEVycm9yKCk7XG4gIH1cblxuICByZXEubG9nZ2VyLmRlYnVnKFwiR2V0dGluZyB1c2VyXCIsIHsgdXNlcklkOiByZXEucGFyYW1zLnVzZXJJZCB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRlbmFudElkID0gcmVxLmFkbWluLnRlbmFudElkO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB1c2Vyc1NlcnZpY2UuZ2V0VXNlcihyZXEuZGIsIHJlcS5wYXJhbXMudXNlcklkLCB0ZW5hbnRJZCk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHJlcy5zdGF0dXMoU3RhdHVzQ29kZXMuTk9UX0ZPVU5EKS5qc29uKHsgZXJyb3I6IFwiVXNlciBub3QgZm91bmRcIiB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXMuanNvbih1c2VyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCB1c2VyXCIsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLklOVEVSTkFMX1NFUlZFUl9FUlJPUikuanNvbih7IGVycm9yOiBcIkZhaWxlZCB0byBnZXQgdXNlclwiIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmxvY2tVc2VyID0gYXN5bmMgKHJlcTogUmVxdWVzdDx7IHVzZXJJZDogc3RyaW5nIH0+LCByZXM6IFJlc3BvbnNlKSA9PiB7XG4gIGlmICghaXNBZG1pblJlcXVlc3QocmVxKSkge1xuICAgIHRocm93IG5ldyBUeXBlR3VhcmRFcnJvcigpO1xuICB9XG5cbiAgcmVxLmxvZ2dlci5pbmZvKFwiQmxvY2tpbmcgdXNlciBzZXJ2ZXIgYWNjZXNzXCIsIHsgdXNlcklkOiByZXEucGFyYW1zLnVzZXJJZCwgYmxvY2s6IHJlcS5xdWVyeS5ibG9jayB9KTtcblxuICB0cnkge1xuICAgIGNvbnN0IHRlbmFudElkID0gcmVxLmFkbWluLnRlbmFudElkO1xuXG4gICAgY29uc3QgYmxvY2tlZCA9IHF1ZXJ5VG9Cb29sZWFuKHJlcS5xdWVyeS5ibG9jayk7XG5cbiAgICBpZiAoYmxvY2tlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLkJBRF9SRVFVRVNUKS5qc29uKHsgZXJyb3I6IFwiSW52YWxpZCAnYmxvY2snIHBhcmFtZXRlci4gRXhwZWN0ZWQgJ3RydWUnIG9yICdmYWxzZScuXCIgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgdXNlcnNTZXJ2aWNlLmJsb2NrVXNlclNlcnZlckFjY2VzcyhyZXEuZGIsIHJlcS5wYXJhbXMudXNlcklkLCB0ZW5hbnRJZCwgYmxvY2tlZCk7XG5cbiAgICBjbGVhckNhY2hlQnlUeXBlKENhY2hlSXRlbVR5cGUuU0VSVkVSX0FDQ0VTUyk7XG5cbiAgICByZXMuc3RhdHVzKFN0YXR1c0NvZGVzLk9LKS5qc29uKHsgYmxvY2tlZCB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXEubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGJsb2NrIHVzZXIgc2VydmVyIGFjY2Vzc1wiLCBlcnJvcik7XG4gICAgcmVzLnN0YXR1cyhTdGF0dXNDb2Rlcy5JTlRFUk5BTF9TRVJWRVJfRVJST1IpLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gYmxvY2sgdXNlciBzZXJ2ZXIgYWNjZXNzXCIgfSk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHsgVXNlciB9IGZyb20gXCJAYWdlbnRicmlkZ2UvYXBpXCI7XG5pbXBvcnQgeyBFbmRVc2VyIH0gZnJvbSBcIkBwcmlzbWEvY2xpZW50XCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBR0VfU0laRSB9IGZyb20gXCIuLi91dGlscy9jb25maWcuanNcIjtcbmltcG9ydCB7IERhdGFiYXNlIH0gZnJvbSBcIi4uL3V0aWxzL2Nvbm5lY3Rpb24uanNcIjtcblxuY29uc3QgbWFwVXNlciA9ICh1c2VyOiBFbmRVc2VyKTogVXNlciA9PiAoe1xuICAuLi51c2VyLFxuICBwaWN0dXJlOiB1c2VyLnBpY3R1cmUgfHwgdW5kZWZpbmVkLFxuICBjcmVhdGVkQXQ6IHVzZXIuY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCksXG59KTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3RVc2VycyhkYjogRGF0YWJhc2UsIHRlbmFudElkOiBzdHJpbmcsIHNlYXJjaD86IHN0cmluZywgcGFnZSA9IDEsIGxpbWl0ID0gREVGQVVMVF9QQUdFX1NJWkUpIHtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCBkYi5lbmRVc2VyLmZpbmRNYW55KHtcbiAgICB3aGVyZToge1xuICAgICAgdGVuYW50SWQsXG4gICAgICAuLi4oc2VhcmNoID8geyBlbWFpbDogeyBjb250YWluczogc2VhcmNoLCBtb2RlOiBcImluc2Vuc2l0aXZlXCIgfSB9IDoge30pLFxuICAgIH0sXG4gICAgb3JkZXJCeTogW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcImFzY1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiYXNjXCIsXG4gICAgICB9LFxuICAgIF0sXG4gICAgdGFrZTogbGltaXQsXG4gICAgc2tpcDogKHBhZ2UgLSAxKSAqIGxpbWl0LFxuICB9KTtcblxuICBjb25zdCB0b3RhbFVzZXJzID0gYXdhaXQgZGIuZW5kVXNlci5jb3VudCh7XG4gICAgd2hlcmU6IHtcbiAgICAgIHRlbmFudElkLFxuICAgICAgLi4uKHNlYXJjaCA/IHsgZW1haWw6IHsgY29udGFpbnM6IHNlYXJjaCwgbW9kZTogXCJpbnNlbnNpdGl2ZVwiIH0gfSA6IHt9KSxcbiAgICB9LFxuICB9KTtcblxuICBjb25zdCB0b3RhbFBhZ2VzID0gTWF0aC5jZWlsKHRvdGFsVXNlcnMgLyBsaW1pdCk7XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiB1c2Vycy5tYXAobWFwVXNlciksXG4gICAgcGFnaW5hdGlvbjoge1xuICAgICAgdG90YWxJdGVtczogdG90YWxVc2VycyxcbiAgICAgIHRvdGFsUGFnZXMsXG4gICAgICBjdXJyZW50UGFnZTogcGFnZSxcbiAgICAgIGl0ZW1zUGVyUGFnZTogbGltaXQsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXIoZGI6IERhdGFiYXNlLCB1c2VySWQ6IHN0cmluZywgdGVuYW50SWQ6IHN0cmluZykge1xuICBjb25zdCB1c2VyID0gYXdhaXQgZGIuZW5kVXNlci5maW5kVW5pcXVlKHtcbiAgICB3aGVyZToge1xuICAgICAgaWQ6IHVzZXJJZCxcbiAgICAgIHRlbmFudElkLFxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gdXNlciA/IG1hcFVzZXIodXNlcikgOiBudWxsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmxvY2tVc2VyU2VydmVyQWNjZXNzKGRiOiBEYXRhYmFzZSwgdXNlcklkOiBzdHJpbmcsIHRlbmFudElkOiBzdHJpbmcsIGJsb2NrZWQ6IGJvb2xlYW4pIHtcbiAgcmV0dXJuIGRiLmVuZFVzZXIudXBkYXRlTWFueSh7XG4gICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCwgdGVuYW50SWQgfSxcbiAgICBkYXRhOiB7IGVuYWJsZWQ6ICFibG9ja2VkIH0sXG4gIH0pO1xufVxuIiwgImltcG9ydCB7IFBhcnNlZFFzIH0gZnJvbSBcInFzXCI7XG5cbmV4cG9ydCBjb25zdCBxdWVyeVRvQm9vbGVhbiA9IChxdWVyeTogc3RyaW5nIHwgUGFyc2VkUXMgfCAoc3RyaW5nIHwgUGFyc2VkUXMpW10gfCB1bmRlZmluZWQpOiBib29sZWFuIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgcXVlcnkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIGlmICh0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcXVlcnkudG9Mb3dlckNhc2UoKSA9PT0gXCJ0cnVlXCI7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQWEsWUFFQTtBQUZiO0FBQUE7QUFBQTtBQUFPLElBQU0sYUFBYSxRQUFRLElBQUksYUFBYTtBQUU1QyxJQUFNLG9CQUFvQjtBQUFBO0FBQUE7OztBQ0ZqQyxxQkFDQSxnQkFPTSxRQWNDO0FBdEJQO0FBQUE7QUFBQTtBQUFBLHNCQUFtQjtBQUNuQixxQkFBb0I7QUFDcEI7QUFFQSxvQkFBQUEsUUFBTyxLQUFLO0FBQUEsTUFDVixjQUFjO0FBQUEsSUFDaEIsQ0FBQztBQUVELElBQU0sU0FBUyxlQUFBQyxRQUFRLGFBQWE7QUFBQSxNQUNsQyxPQUFPLFFBQVEsSUFBSSxhQUFhO0FBQUEsTUFDaEMsUUFBUSxlQUFBQSxRQUFRLE9BQU87QUFBQSxRQUNyQixlQUFBQSxRQUFRLE9BQU8sVUFBVTtBQUFBLFFBQ3pCLGVBQUFBLFFBQVEsT0FBTyxLQUFLO0FBQUEsUUFDcEIsZUFBQUEsUUFBUSxPQUFPLE9BQU8sRUFBRSxPQUFPLEtBQUssQ0FBQztBQUFBLE1BQ3ZDO0FBQUEsTUFDQSxZQUFZO0FBQUEsUUFDVixJQUFJLGVBQUFBLFFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FB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QUFDcEIsTUFBSSxhQUFhLEdBQUcsR0FBRztBQUNyQixRQUFJLE9BQU8sTUFBTSxrQkFBa0IsSUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLEVBQUU7QUFBQSxFQUM3RDtBQUNBLE1BQUksT0FBTyx1Q0FBWSxTQUFTLEVBQUUsS0FBSztBQUFBLElBQ3JDLE9BQU87QUFBQSxFQUNULENBQUM7QUFDSCxDQUFDO0FBRUQsSUFBSSxJQUFJLFlBQVk7QUFFcEIsSUFBSTtBQUNGLFFBQU0sU0FBUyxJQUFJLE9BQU8sTUFBTSxNQUFNO0FBQ3BDLG1CQUFPLEtBQUssNkJBQTZCLElBQUksRUFBRTtBQUFBLEVBQ2pELENBQUM7QUFFRCxTQUFPLEdBQUcsU0FBUyxDQUFDLFFBQStCO0FBQ2pELFFBQUksSUFBSSxTQUFTLGNBQWM7QUFDN0IscUJBQU8sTUFBTSxRQUFRLElBQUksb0JBQW9CO0FBQUEsSUFDL0MsT0FBTztBQUNMLHFCQUFPLE1BQU0sMkJBQTJCLEdBQUc7QUFBQSxJQUM3QztBQUNBLFlBQVEsS0FBSyxDQUFDO0FBQUEsRUFDaEIsQ0FBQztBQUNILFNBQVMsR0FBRztBQUNWLGlCQUFPLE1BQU0sMkNBQTJDLENBQUM7QUFFekQscUJBQW1CLEVBQUUsUUFBUSxNQUFNLFFBQVEsS0FBSyxDQUFDLENBQUM7QUFDcEQ7IiwKICAibmFtZXMiOiBbInRyYWNlciIsICJ3aW5zdG9uIiwgIkNhY2hlSXRlbVR5cGUiLCAiTm9kZUNhY2hlIiwgImp3dCIsICJzbmFrZUNhc2UiLCAiZ3JvdXBCeSIsICJwcm92aWRlcnMiLCAidG9vbCIsICJzbmFrZUNhc2UiLCAib21pdCIsICJpbXBvcnRfb21pdCIsICJpbXBvcnRfc25ha2VDYXNlIiwgImltcG9ydF9leHByZXNzIiwgImltcG9ydF9odHRwX3N0YXR1c19jb2RlcyIsICJsb2dnZXIiLCAiY3J5cHRvIiwgImltcG9ydF9jbGllbnQiLCAiaW1wb3J0X2h0dHBfc3RhdHVzX2NvZGVzIiwgImltcG9ydF9odHRwX3N0YXR1c19jb2RlcyIsICJsb2dnZXIiLCAiY2FsbGJhY2tVcmwiLCAiYXhpb3MiLCAicXMiLCAib21pdCIsICJjcnlwdG8iLCAidG9rZW4iLCAicmVxIiwgImltcG9ydF9odHRwX3N0YXR1c19jb2RlcyIsICJpbXBvcnRfY2xpZW50IiwgImxvZ2dlciIsICJhcHBTZWNyZXRzIiwgIm5vZGVtYWlsZXIiLCAibG9nZ2VyIiwgImV4aXN0aW5nQWRtaW4iLCAiYWRtaW4iLCAic2VuZEFkbWluQXBwcm92ZWROb3RpZmljYXRpb24iLCAic2VuZEFkbWluQXBwcm92ZWROb3RpZmljYXRpb24iLCAiaW1wb3J0X2V4cHJlc3MiLCAiaW1wb3J0X3pvZCIsICJwcmlzbWEiLCAiY29uZmlnIiwgInRvb2wiLCAiY3JlYXRlVG9vbCIsICJnZW5lcmF0ZVJlcXVlc3RPdmVycmlkZXMiLCAicHJpc21hIiwgImNvbmZpZyIsICJjb25maWciLCAidG9vbCIsICJyb3V0ZXIiLCAiZ2VuZXJhdGVUZXh0IiwgIm9wZW5haSIsICJpbXBvcnRfZXhwcmVzcyIsICJhcHBTZWNyZXRzIiwgImFuYWx5dGljcyIsICJsb2dnZXIiLCAicm91dGVyIiwgImltcG9ydF9leHByZXNzIiwgImltcG9ydF9odHRwX3N0YXR1c19jb2RlcyIsICJsaXN0Rm9sZGVycyIsICJjcmVhdGVGb2xkZXIiLCAidXBkYXRlRm9sZGVyIiwgImRlbGV0ZUZvbGRlciIsICJyb3V0ZXIiLCAibGlzdEZvbGRlcnMiLCAiY3JlYXRlRm9sZGVyIiwgInVwZGF0ZUZvbGRlciIsICJkZWxldGVGb2xkZXIiLCAiaW1wb3J0X2V4cHJlc3MiLCAiaW1wb3J0X2h0dHBfc3RhdHVzX2NvZGVzIiwgInJvdXRlciIsICJleHByZXNzIiwgImltcG9ydF9leHByZXNzIiwgImltcG9ydF9odHRwX3N0YXR1c19jb2RlcyIsICJpbXBvcnRfYXhpb3MiLCAiaW1wb3J0X3pvZCIsICJsb2dnZXIiLCAic2NoZW1hIiwgImJhc2VVcmwiLCAiY29uZmlnIiwgIkhhbmRsZWJhcnMiLCAibG9nZ2VyIiwgInRvb2wiLCAiYmFzZVVybCIsICJjb25maWciLCAiYXhpb3MiLCAiand0IiwgInRvb2wiLCAibG9nZ2VyIiwgImlzRW1wdHkiLCAiYXV0aFVybCIsICJsb2dnZXIiLCAiaW1wb3J0X2pzb253ZWJ0b2tlbiIsICJsb2dnZXIiLCAiand0IiwgInB1YmxpY0tleSIsICJsb2dnZXIiLCAiY29uZmlnIiwgInZlcmlmeUVuZFVzZXJUb2tlbiIsICJsb2dnZXIiLCAiY29uZmlnIiwgImxvZ2dlciIsICJsb2dnZXIiLCAiY29uZmlnIiwgInRvb2wiLCAicm91dGVyIiwgInJvdXRlciIsICJpbXBvcnRfZXhwcmVzcyIsICJpbXBvcnRfYXhpb3MiLCAiaW1wb3J0X2h0dHBfc3RhdHVzX2NvZGVzIiwgImF4aW9zIiwgInJvdXRlciIsICJleHByZXNzIiwgImltcG9ydF9leHByZXNzIiwgImltcG9ydF9heGlvcyIsICJjcnlwdG8iLCAiaW1wb3J0X2h0dHBfc3RhdHVzX2NvZGVzIiwgImdldFNlcnZlckJ5SWQiLCAiY3J5cHRvIiwgImJhc2VVcmwiLCAicmVkaXJlY3RVcmwiLCAiYXhpb3MiLCAiY2xpZW50IiwgInJvdXRlciIsICJpbXBvcnRfZXhwcmVzcyIsICJpbXBvcnRfaHR0cF9zdGF0dXNfY29kZXMiLCAiY29uZmlnIiwgImltcG9ydF9odHRwX3N0YXR1c19jb2RlcyIsICJyb3V0ZXIiLCAiZXhwcmVzcyIsICJpbXBvcnRfZXhwcmVzcyIsICJpbXBvcnRfaHR0cF9zdGF0dXNfY29kZXMiLCAiaW1wb3J0X29taXQiLCAib21pdCIsICJyb3V0ZXIiLCAiaW1wb3J0X2V4cHJlc3MiLCAiaW1wb3J0X2h0dHBfc3RhdHVzX2NvZGVzIiwgImNvbmZpZyIsICJyb3V0ZXIiLCAiaW1wb3J0X2V4cHJlc3MiLCAiaW1wb3J0X2h0dHBfc3RhdHVzX2NvZGVzIiwgImNyZWF0ZVNlcnZlciIsICJjbGVhckNhY2hlIiwgImNsZWFyQ2FjaGVCeVBhcnRpYWxLZXkiLCAieWFtbCIsICJjcmVhdGVUb29sIiwgInRvb2wiLCAicmVzIiwgInJvdXRlciIsICJjcmVhdGVTZXJ2ZXIiLCAiY3JlYXRlVG9vbCIsICJpbXBvcnRfZXhwcmVzcyIsICJpbXBvcnRfaHR0cF9zdGF0dXNfY29kZXMiLCAiaW1wb3J0X2NsaWVudCIsICJpbXBvcnRfY3J5cHRvIiwgImJhc2VVcmwiLCAibG9nZ2VyIiwgImdldFRlbmFudFVzZXJzIiwgImdldFRlbmFudEludml0YXRpb25zIiwgImNyZWF0ZUludml0YXRpb24iLCAiZ2V0SW52aXRhdGlvbkJ5VG9rZW4iLCAiYWNjZXB0SW52aXRhdGlvbiIsICJ1cGRhdGVVc2VyUm9sZSIsICJjYW5NYW5hZ2VSb2xlcyIsICJyZW1vdmVVc2VyRnJvbVRlbmFudCIsICJjYW5SZW1vdmVVc2VycyIsICJjYW5jZWxJbnZpdGF0aW9uIiwgImdldFVzZXJUZW5hbnRzIiwgImltcG9ydF9jbGllbnQiLCAiaW1wb3J0X2h0dHBfc3RhdHVzX2NvZGVzIiwgInJvdXRlciIsICJnZXRUZW5hbnRVc2VycyIsICJnZXRUZW5hbnRJbnZpdGF0aW9ucyIsICJjcmVhdGVJbnZpdGF0aW9uIiwgInVwZGF0ZVVzZXJSb2xlIiwgInJlbW92ZVVzZXJGcm9tVGVuYW50IiwgImNhbmNlbEludml0YXRpb24iLCAiZ2V0SW52aXRhdGlvbkJ5VG9rZW4iLCAiYWNjZXB0SW52aXRhdGlvbiIsICJnZXRVc2VyVGVuYW50cyIsICJpbXBvcnRfZXhwcmVzcyIsICJpbXBvcnRfaHR0cF9zdGF0dXNfY29kZXMiLCAibGlzdFVzZXJUb2tlbnMiLCAiZGVsZXRlVXNlclRva2VucyIsICJpbXBvcnRfaHR0cF9zdGF0dXNfY29kZXMiLCAibGlzdFVzZXJzIiwgImdldFVzZXIiLCAicm91dGVyIiwgImxpc3RVc2VycyIsICJnZXRVc2VyIiwgImxpc3RVc2VyVG9rZW5zIiwgImRlbGV0ZVVzZXJUb2tlbnMiLCAiZXhwcmVzcyIsICJjb3JzIl0KfQo=
